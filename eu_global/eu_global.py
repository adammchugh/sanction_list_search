#!/usr/bin/env python
# -*- coding: utf-8 -*-

#
# Generated Fri Jun  8 12:39:26 2018 by generateDS.py version 2.29.14.
# Python 3.6.4 (default, Mar  1 2018, 18:36:42)  [GCC 4.2.1 Compatible Apple LLVM 9.0.0 (clang-900.0.39.2)]
#
# Command line options:
#   ('-o', 'eu_global.py')
#   ('-s', 'eu_global_subs.py')
#
# Command line arguments:
#   schema_1_1.xsd
#
# Command line:
#   ../generateDS.py -o "eu_global.py" -s "eu_global_subs.py" schema_1_1.xsd
#
# Current working directory (os.getcwd()):
#   eu_global
#

import sys
import re as re_
import base64
import datetime as datetime_
import warnings as warnings_
try:
    from lxml import etree as etree_
except ImportError:
    from xml.etree import ElementTree as etree_


Validate_simpletypes_ = True
if sys.version_info.major == 2:
    BaseStrType_ = basestring
else:
    BaseStrType_ = str


def parsexml_(infile, parser=None, **kwargs):
    if parser is None:
        # Use the lxml ElementTree compatible parser so that, e.g.,
        #   we ignore comments.
        try:
            parser = etree_.ETCompatXMLParser()
        except AttributeError:
            # fallback to xml.etree
            parser = etree_.XMLParser()
    doc = etree_.parse(infile, parser=parser, **kwargs)
    return doc

def parsexmlstring_(instring, parser=None, **kwargs):
    if parser is None:
        # Use the lxml ElementTree compatible parser so that, e.g.,
        #   we ignore comments.
        try:
            parser = etree_.ETCompatXMLParser()
        except AttributeError:
            # fallback to xml.etree
            parser = etree_.XMLParser()
    element = etree_.fromstring(instring, parser=parser, **kwargs)
    return element

#
# Namespace prefix definition table (and other attributes, too)
#
# The module generatedsnamespaces, if it is importable, must contain
# a dictionary named GeneratedsNamespaceDefs.  This Python dictionary
# should map element type names (strings) to XML schema namespace prefix
# definitions.  The export method for any class for which there is
# a namespace prefix definition, will export that definition in the
# XML representation of that element.  See the export method of
# any generated element type class for a example of the use of this
# table.
# A sample table is:
#
#     # File: generatedsnamespaces.py
#
#     GenerateDSNamespaceDefs = {
#         "ElementtypeA": "http://www.xxx.com/namespaceA",
#         "ElementtypeB": "http://www.xxx.com/namespaceB",
#     }
#

try:
    from generatedsnamespaces import GenerateDSNamespaceDefs as GenerateDSNamespaceDefs_
except ImportError:
    GenerateDSNamespaceDefs_ = {}

#
# The root super-class for element type classes
#
# Calls to the methods in these classes are generated by generateDS.py.
# You can replace these methods by re-implementing the following class
#   in a module named generatedssuper.py.

try:
    from generatedssuper import GeneratedsSuper
except ImportError as exp:
    
    class GeneratedsSuper(object):
        tzoff_pattern = re_.compile(r'(\+|-)((0\d|1[0-3]):[0-5]\d|14:00)$')
        class _FixedOffsetTZ(datetime_.tzinfo):
            def __init__(self, offset, name):
                self.__offset = datetime_.timedelta(minutes=offset)
                self.__name = name
            def utcoffset(self, dt):
                return self.__offset
            def tzname(self, dt):
                return self.__name
            def dst(self, dt):
                return None
        def gds_format_string(self, input_data, input_name=''):
            return input_data
        def gds_validate_string(self, input_data, node=None, input_name=''):
            if not input_data:
                return ''
            else:
                return input_data
        def gds_format_base64(self, input_data, input_name=''):
            return base64.b64encode(input_data)
        def gds_validate_base64(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_integer(self, input_data, input_name=''):
            return '%d' % input_data
        def gds_validate_integer(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_integer_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_integer_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    int(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of integers')
            return values
        def gds_format_float(self, input_data, input_name=''):
            return ('%.15f' % input_data).rstrip('0')
        def gds_validate_float(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_float_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_float_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of floats')
            return values
        def gds_format_double(self, input_data, input_name=''):
            return '%e' % input_data
        def gds_validate_double(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_double_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_double_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of doubles')
            return values
        def gds_format_boolean(self, input_data, input_name=''):
            return ('%s' % input_data).lower()
        def gds_validate_boolean(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_boolean_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_boolean_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                if value not in ('true', '1', 'false', '0', ):
                    raise_parse_error(
                        node,
                        'Requires sequence of booleans '
                        '("true", "1", "false", "0")')
            return values
        def gds_validate_datetime(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_datetime(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d.%s' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        @classmethod
        def gds_parse_datetime(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            time_parts = input_data.split('.')
            if len(time_parts) > 1:
                micro_seconds = int(float('0.' + time_parts[1]) * 1000000)
                input_data = '%s.%s' % (time_parts[0], micro_seconds, )
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt
        def gds_validate_date(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_date(self, input_data, input_name=''):
            _svalue = '%04d-%02d-%02d' % (
                input_data.year,
                input_data.month,
                input_data.day,
            )
            try:
                if input_data.tzinfo is not None:
                    tzoff = input_data.tzinfo.utcoffset(input_data)
                    if tzoff is not None:
                        total_seconds = tzoff.seconds + (86400 * tzoff.days)
                        if total_seconds == 0:
                            _svalue += 'Z'
                        else:
                            if total_seconds < 0:
                                _svalue += '-'
                                total_seconds *= -1
                            else:
                                _svalue += '+'
                            hours = total_seconds // 3600
                            minutes = (total_seconds - (hours * 3600)) // 60
                            _svalue += '{0:02d}:{1:02d}'.format(
                                hours, minutes)
            except AttributeError:
                pass
            return _svalue
        @classmethod
        def gds_parse_date(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            dt = datetime_.datetime.strptime(input_data, '%Y-%m-%d')
            dt = dt.replace(tzinfo=tz)
            return dt.date()
        def gds_validate_time(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_time(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%02d:%02d:%02d' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%02d:%02d:%02d.%s' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        def gds_validate_simple_patterns(self, patterns, target):
            # pat is a list of lists of strings/patterns.  We should:
            # - AND the outer elements
            # - OR the inner elements
            found1 = True
            for patterns1 in patterns:
                found2 = False
                for patterns2 in patterns1:
                    if re_.search(patterns2, target) is not None:
                        found2 = True
                        break
                if not found2:
                    found1 = False
                    break
            return found1
        @classmethod
        def gds_parse_time(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            if len(input_data.split('.')) > 1:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt.time()
        def gds_str_lower(self, instring):
            return instring.lower()
        def get_path_(self, node):
            path_list = []
            self.get_path_list_(node, path_list)
            path_list.reverse()
            path = '/'.join(path_list)
            return path
        Tag_strip_pattern_ = re_.compile(r'\{.*\}')
        def get_path_list_(self, node, path_list):
            if node is None:
                return
            tag = GeneratedsSuper.Tag_strip_pattern_.sub('', node.tag)
            if tag:
                path_list.append(tag)
            self.get_path_list_(node.getparent(), path_list)
        def get_class_obj_(self, node, default_class=None):
            class_obj1 = default_class
            if 'xsi' in node.nsmap:
                classname = node.get('{%s}type' % node.nsmap['xsi'])
                if classname is not None:
                    names = classname.split(':')
                    if len(names) == 2:
                        classname = names[1]
                    class_obj2 = globals().get(classname)
                    if class_obj2 is not None:
                        class_obj1 = class_obj2
            return class_obj1
        def gds_build_any(self, node, type_name=None):
            return None
        @classmethod
        def gds_reverse_node_mapping(cls, mapping):
            return dict(((v, k) for k, v in mapping.iteritems()))
        @staticmethod
        def gds_encode(instring):
            if sys.version_info.major == 2:
                return instring.encode(ExternalEncoding)
            else:
                return instring
        @staticmethod
        def convert_unicode(instring):
            if isinstance(instring, str):
                result = quote_xml(instring)
            elif sys.version_info.major == 2 and isinstance(instring, unicode):
                result = quote_xml(instring).encode('utf8')
            else:
                result = GeneratedsSuper.gds_encode(str(instring))
            return result
        def __eq__(self, other):
            if type(self) != type(other):
                return False
            return self.__dict__ == other.__dict__
        def __ne__(self, other):
            return not self.__eq__(other)
    
    def getSubclassFromModule_(module, class_):
        '''Get the subclass of a class from a specific module.'''
        name = class_.__name__ + 'Sub'
        if hasattr(module, name):
            return getattr(module, name)
        else:
            return None


#
# If you have installed IPython you can uncomment and use the following.
# IPython is available from http://ipython.scipy.org/.
#

## from IPython.Shell import IPShellEmbed
## args = ''
## ipshell = IPShellEmbed(args,
##     banner = 'Dropping into IPython',
##     exit_msg = 'Leaving Interpreter, back to program.')

# Then use the following line where and when you want to drop into the
# IPython shell:
#    ipshell('<some message> -- Entering ipshell.\nHit Ctrl-D to exit')

#
# Globals
#

ExternalEncoding = 'utf-8'
Tag_pattern_ = re_.compile(r'({.*})?(.*)')
String_cleanup_pat_ = re_.compile(r"[\n\r\s]+")
Namespace_extract_pat_ = re_.compile(r'{(.*)}(.*)')
CDATA_pattern_ = re_.compile(r"<!\[CDATA\[.*?\]\]>", re_.DOTALL)

# Change this to redirect the generated superclass module to use a
# specific subclass module.
CurrentSubclassModule_ = None

#
# Support/utility functions.
#


def showIndent(outfile, level, pretty_print=True):
    if pretty_print:
        for idx in range(level):
            outfile.write('    ')


def quote_xml(inStr):
    "Escape markup chars, but do not modify CDATA sections."
    if not inStr:
        return ''
    s1 = (isinstance(inStr, BaseStrType_) and inStr or '%s' % inStr)
    s2 = ''
    pos = 0
    matchobjects = CDATA_pattern_.finditer(s1)
    for mo in matchobjects:
        s3 = s1[pos:mo.start()]
        s2 += quote_xml_aux(s3)
        s2 += s1[mo.start():mo.end()]
        pos = mo.end()
    s3 = s1[pos:]
    s2 += quote_xml_aux(s3)
    return s2


def quote_xml_aux(inStr):
    s1 = inStr.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    return s1


def quote_attrib(inStr):
    s1 = (isinstance(inStr, BaseStrType_) and inStr or '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    if '"' in s1:
        if "'" in s1:
            s1 = '"%s"' % s1.replace('"', "&quot;")
        else:
            s1 = "'%s'" % s1
    else:
        s1 = '"%s"' % s1
    return s1


def quote_python(inStr):
    s1 = inStr
    if s1.find("'") == -1:
        if s1.find('\n') == -1:
            return "'%s'" % s1
        else:
            return "'''%s'''" % s1
    else:
        if s1.find('"') != -1:
            s1 = s1.replace('"', '\\"')
        if s1.find('\n') == -1:
            return '"%s"' % s1
        else:
            return '"""%s"""' % s1


def get_all_text_(node):
    if node.text is not None:
        text = node.text
    else:
        text = ''
    for child in node:
        if child.tail is not None:
            text += child.tail
    return text


def find_attr_value_(attr_name, node):
    attrs = node.attrib
    attr_parts = attr_name.split(':')
    value = None
    if len(attr_parts) == 1:
        value = attrs.get(attr_name)
    elif len(attr_parts) == 2:
        prefix, name = attr_parts
        namespace = node.nsmap.get(prefix)
        if namespace is not None:
            value = attrs.get('{%s}%s' % (namespace, name, ))
    return value


class GDSParseError(Exception):
    pass


def raise_parse_error(node, msg):
    msg = '%s (element %s/line %d)' % (msg, node.tag, node.sourceline, )
    raise GDSParseError(msg)


class MixedContainer:
    # Constants for category:
    CategoryNone = 0
    CategoryText = 1
    CategorySimple = 2
    CategoryComplex = 3
    # Constants for content_type:
    TypeNone = 0
    TypeText = 1
    TypeString = 2
    TypeInteger = 3
    TypeFloat = 4
    TypeDecimal = 5
    TypeDouble = 6
    TypeBoolean = 7
    TypeBase64 = 8
    def __init__(self, category, content_type, name, value):
        self.category = category
        self.content_type = content_type
        self.name = name
        self.value = value
    def getCategory(self):
        return self.category
    def getContenttype(self, content_type):
        return self.content_type
    def getValue(self):
        return self.value
    def getName(self):
        return self.name
    def export(self, outfile, level, name, namespace,
               pretty_print=True):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                outfile.write(self.value)
        elif self.category == MixedContainer.CategorySimple:
            self.exportSimple(outfile, level, name)
        else:    # category == MixedContainer.CategoryComplex
            self.value.export(
                outfile, level, namespace, name,
                pretty_print=pretty_print)
    def exportSimple(self, outfile, level, name):
        if self.content_type == MixedContainer.TypeString:
            outfile.write('<%s>%s</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeInteger or \
                self.content_type == MixedContainer.TypeBoolean:
            outfile.write('<%s>%d</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeFloat or \
                self.content_type == MixedContainer.TypeDecimal:
            outfile.write('<%s>%f</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeDouble:
            outfile.write('<%s>%g</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeBase64:
            outfile.write('<%s>%s</%s>' % (
                self.name,
                base64.b64encode(self.value),
                self.name))
    def to_etree(self, element):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                if len(element) > 0:
                    if element[-1].tail is None:
                        element[-1].tail = self.value
                    else:
                        element[-1].tail += self.value
                else:
                    if element.text is None:
                        element.text = self.value
                    else:
                        element.text += self.value
        elif self.category == MixedContainer.CategorySimple:
            subelement = etree_.SubElement(
                element, '%s' % self.name)
            subelement.text = self.to_etree_simple()
        else:    # category == MixedContainer.CategoryComplex
            self.value.to_etree(element)
    def to_etree_simple(self):
        if self.content_type == MixedContainer.TypeString:
            text = self.value
        elif (self.content_type == MixedContainer.TypeInteger or
                self.content_type == MixedContainer.TypeBoolean):
            text = '%d' % self.value
        elif (self.content_type == MixedContainer.TypeFloat or
                self.content_type == MixedContainer.TypeDecimal):
            text = '%f' % self.value
        elif self.content_type == MixedContainer.TypeDouble:
            text = '%g' % self.value
        elif self.content_type == MixedContainer.TypeBase64:
            text = '%s' % base64.b64encode(self.value)
        return text
    def exportLiteral(self, outfile, level, name):
        if self.category == MixedContainer.CategoryText:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type,
                    self.name, self.value))
        elif self.category == MixedContainer.CategorySimple:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type,
                    self.name, self.value))
        else:    # category == MixedContainer.CategoryComplex
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s",\n' % (
                    self.category, self.content_type, self.name,))
            self.value.exportLiteral(outfile, level + 1)
            showIndent(outfile, level)
            outfile.write(')\n')


class MemberSpec_(object):
    def __init__(self, name='', data_type='', container=0,
            optional=0, child_attrs=None, choice=None):
        self.name = name
        self.data_type = data_type
        self.container = container
        self.child_attrs = child_attrs
        self.choice = choice
        self.optional = optional
    def set_name(self, name): self.name = name
    def get_name(self): return self.name
    def set_data_type(self, data_type): self.data_type = data_type
    def get_data_type_chain(self): return self.data_type
    def get_data_type(self):
        if isinstance(self.data_type, list):
            if len(self.data_type) > 0:
                return self.data_type[-1]
            else:
                return 'xs:string'
        else:
            return self.data_type
    def set_container(self, container): self.container = container
    def get_container(self): return self.container
    def set_child_attrs(self, child_attrs): self.child_attrs = child_attrs
    def get_child_attrs(self): return self.child_attrs
    def set_choice(self, choice): self.choice = choice
    def get_choice(self): return self.choice
    def set_optional(self, optional): self.optional = optional
    def get_optional(self): return self.optional


def _cast(typ, value):
    if typ is None or value is None:
        return value
    return typ(value)

#
# Data representation classes.
#


class ExportType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, generationDate=None, globalFileId=None, sanctionEntity=None):
        self.original_tagname_ = None
        self.generationDate = _cast(None, generationDate)
        self.globalFileId = _cast(int, globalFileId)
        if sanctionEntity is None:
            self.sanctionEntity = []
        else:
            self.sanctionEntity = sanctionEntity
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ExportType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ExportType.subclass:
            return ExportType.subclass(*args_, **kwargs_)
        else:
            return ExportType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_sanctionEntity(self): return self.sanctionEntity
    def set_sanctionEntity(self, sanctionEntity): self.sanctionEntity = sanctionEntity
    def add_sanctionEntity(self, value): self.sanctionEntity.append(value)
    def insert_sanctionEntity_at(self, index, value): self.sanctionEntity.insert(index, value)
    def replace_sanctionEntity_at(self, index, value): self.sanctionEntity[index] = value
    def get_generationDate(self): return self.generationDate
    def set_generationDate(self, generationDate): self.generationDate = generationDate
    def get_globalFileId(self): return self.globalFileId
    def set_globalFileId(self, globalFileId): self.globalFileId = globalFileId
    def hasContent_(self):
        if (
            self.sanctionEntity
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='fsdexport:', name_='ExportType', namespacedef_='xmlns:fsdexport="http://eu.europa.ec/fpi/fsd/export"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ExportType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ExportType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='fsdexport:', name_='ExportType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='fsdexport:', name_='ExportType'):
        if self.generationDate is not None and 'generationDate' not in already_processed:
            already_processed.add('generationDate')
            outfile.write(' generationDate=%s' % (quote_attrib(self.generationDate), ))
        if self.globalFileId is not None and 'globalFileId' not in already_processed:
            already_processed.add('globalFileId')
            outfile.write(' globalFileId="%s"' % self.gds_format_integer(self.globalFileId, input_name='globalFileId'))
    def exportChildren(self, outfile, level, namespace_='fsdexport:', name_='ExportType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for sanctionEntity_ in self.sanctionEntity:
            sanctionEntity_.export(outfile, level, namespace_, name_='sanctionEntity', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('generationDate', node)
        if value is not None and 'generationDate' not in already_processed:
            already_processed.add('generationDate')
            self.generationDate = value
        value = find_attr_value_('globalFileId', node)
        if value is not None and 'globalFileId' not in already_processed:
            already_processed.add('globalFileId')
            try:
                self.globalFileId = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'sanctionEntity':
            obj_ = SanctionEntityType.factory()
            obj_.build(child_)
            self.sanctionEntity.append(obj_)
            obj_.original_tagname_ = 'sanctionEntity'
# end class ExportType


class OperableType(GeneratedsSuper):
    """OperableType contains all the elements and attributes common to all
    the operables. This is an abstract type, so no element of this
    type will be present in the XML. The logical ID is a unique
    logical identifier of a sanctioned entity, of a regulation or of
    a detail of a sanction entity. This information is also provided
    to external actors for help, especially when entity multiple
    aliases make it difficult the identification task. For entities
    imported from previous database, the old value is retained."""
    subclass = None
    superclass = None
    def __init__(self, logicalId=None, remark=None, additionalInformation=None, extensiontype_=None):
        self.original_tagname_ = None
        self.logicalId = _cast(int, logicalId)
        if remark is None:
            self.remark = []
        else:
            self.remark = remark
        if additionalInformation is None:
            self.additionalInformation = []
        else:
            self.additionalInformation = additionalInformation
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, OperableType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if OperableType.subclass:
            return OperableType.subclass(*args_, **kwargs_)
        else:
            return OperableType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_remark(self): return self.remark
    def set_remark(self, remark): self.remark = remark
    def add_remark(self, value): self.remark.append(value)
    def insert_remark_at(self, index, value): self.remark.insert(index, value)
    def replace_remark_at(self, index, value): self.remark[index] = value
    def get_additionalInformation(self): return self.additionalInformation
    def set_additionalInformation(self, additionalInformation): self.additionalInformation = additionalInformation
    def add_additionalInformation(self, value): self.additionalInformation.append(value)
    def insert_additionalInformation_at(self, index, value): self.additionalInformation.insert(index, value)
    def replace_additionalInformation_at(self, index, value): self.additionalInformation[index] = value
    def get_logicalId(self): return self.logicalId
    def set_logicalId(self, logicalId): self.logicalId = logicalId
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def validate_UnlimitedTextType(self, value):
        # Validate type UnlimitedTextType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            pass
    def hasContent_(self):
        if (
            self.remark or
            self.additionalInformation
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='fsdexport:', name_='OperableType', namespacedef_='xmlns:fsdexport="http://eu.europa.ec/fpi/fsd/export"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('OperableType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='OperableType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='fsdexport:', name_='OperableType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='fsdexport:', name_='OperableType'):
        if self.logicalId is not None and 'logicalId' not in already_processed:
            already_processed.add('logicalId')
            outfile.write(' logicalId="%s"' % self.gds_format_integer(self.logicalId, input_name='logicalId'))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='fsdexport:', name_='OperableType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for remark_ in self.remark:
            showIndent(outfile, level, pretty_print)
            outfile.write('<fsdexport:remark>%s</fsdexport:remark>%s' % (self.gds_encode(self.gds_format_string(quote_xml(remark_), input_name='remark')), eol_))
        for additionalInformation_ in self.additionalInformation:
            additionalInformation_.export(outfile, level, namespace_, name_='additionalInformation', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('logicalId', node)
        if value is not None and 'logicalId' not in already_processed:
            already_processed.add('logicalId')
            try:
                self.logicalId = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'remark':
            remark_ = child_.text
            remark_ = self.gds_validate_string(remark_, node, 'remark')
            self.remark.append(remark_)
            # validate type UnlimitedTextType
            self.validate_UnlimitedTextType(self.remark[-1])
        elif nodeName_ == 'additionalInformation':
            obj_ = AdditionalInfoType.factory()
            obj_.build(child_)
            self.additionalInformation.append(obj_)
            obj_.original_tagname_ = 'additionalInformation'
# end class OperableType


class RegulationType(OperableType):
    """The regulation is a type that describes the information related to
    an official publication."""
    subclass = None
    superclass = OperableType
    def __init__(self, logicalId=None, remark=None, additionalInformation=None, regulationType=None, organisationType=None, publicationDate=None, entryIntoForceDate=None, numberTitle=None, programme=None, publicationUrl=None, corrigendum=None):
        self.original_tagname_ = None
        super(RegulationType, self).__init__(logicalId, remark, additionalInformation, )
        self.regulationType = _cast(None, regulationType)
        self.organisationType = _cast(None, organisationType)
        self.publicationDate = _cast(None, publicationDate)
        self.entryIntoForceDate = _cast(None, entryIntoForceDate)
        self.numberTitle = _cast(None, numberTitle)
        self.programme = _cast(None, programme)
        self.publicationUrl = publicationUrl
        self.validate_DefaultUrlType(self.publicationUrl)
        if corrigendum is None:
            self.corrigendum = []
        else:
            self.corrigendum = corrigendum
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RegulationType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RegulationType.subclass:
            return RegulationType.subclass(*args_, **kwargs_)
        else:
            return RegulationType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_publicationUrl(self): return self.publicationUrl
    def set_publicationUrl(self, publicationUrl): self.publicationUrl = publicationUrl
    def get_corrigendum(self): return self.corrigendum
    def set_corrigendum(self, corrigendum): self.corrigendum = corrigendum
    def add_corrigendum(self, value): self.corrigendum.append(value)
    def insert_corrigendum_at(self, index, value): self.corrigendum.insert(index, value)
    def replace_corrigendum_at(self, index, value): self.corrigendum[index] = value
    def get_regulationType(self): return self.regulationType
    def set_regulationType(self, regulationType): self.regulationType = regulationType
    def get_organisationType(self): return self.organisationType
    def set_organisationType(self, organisationType): self.organisationType = organisationType
    def get_publicationDate(self): return self.publicationDate
    def set_publicationDate(self, publicationDate): self.publicationDate = publicationDate
    def get_entryIntoForceDate(self): return self.entryIntoForceDate
    def set_entryIntoForceDate(self, entryIntoForceDate): self.entryIntoForceDate = entryIntoForceDate
    def get_numberTitle(self): return self.numberTitle
    def set_numberTitle(self, numberTitle): self.numberTitle = numberTitle
    def get_programme(self): return self.programme
    def set_programme(self, programme): self.programme = programme
    def validate_DefaultUrlType(self, value):
        # Validate type DefaultUrlType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 512:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on DefaultUrlType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.publicationUrl is not None or
            self.corrigendum or
            super(RegulationType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='fsdexport:', name_='RegulationType', namespacedef_='xmlns:fsdexport="http://eu.europa.ec/fpi/fsd/export"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('RegulationType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RegulationType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='fsdexport:', name_='RegulationType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='fsdexport:', name_='RegulationType'):
        super(RegulationType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='RegulationType')
        if self.regulationType is not None and 'regulationType' not in already_processed:
            already_processed.add('regulationType')
            outfile.write(' regulationType=%s' % (quote_attrib(self.regulationType), ))
        if self.organisationType is not None and 'organisationType' not in already_processed:
            already_processed.add('organisationType')
            outfile.write(' organisationType=%s' % (quote_attrib(self.organisationType), ))
        if self.publicationDate is not None and 'publicationDate' not in already_processed:
            already_processed.add('publicationDate')
            outfile.write(' publicationDate=%s' % (quote_attrib(self.publicationDate), ))
        if self.entryIntoForceDate is not None and 'entryIntoForceDate' not in already_processed:
            already_processed.add('entryIntoForceDate')
            outfile.write(' entryIntoForceDate=%s' % (quote_attrib(self.entryIntoForceDate), ))
        if self.numberTitle is not None and 'numberTitle' not in already_processed:
            already_processed.add('numberTitle')
            outfile.write(' numberTitle=%s' % (quote_attrib(self.numberTitle), ))
        if self.programme is not None and 'programme' not in already_processed:
            already_processed.add('programme')
            outfile.write(' programme=%s' % (quote_attrib(self.programme), ))
    def exportChildren(self, outfile, level, namespace_='fsdexport:', name_='RegulationType', fromsubclass_=False, pretty_print=True):
        super(RegulationType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.publicationUrl is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<fsdexport:publicationUrl>%s</fsdexport:publicationUrl>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.publicationUrl), input_name='publicationUrl')), eol_))
        for corrigendum_ in self.corrigendum:
            corrigendum_.export(outfile, level, namespace_, name_='corrigendum', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('regulationType', node)
        if value is not None and 'regulationType' not in already_processed:
            already_processed.add('regulationType')
            self.regulationType = value
        value = find_attr_value_('organisationType', node)
        if value is not None and 'organisationType' not in already_processed:
            already_processed.add('organisationType')
            self.organisationType = value
        value = find_attr_value_('publicationDate', node)
        if value is not None and 'publicationDate' not in already_processed:
            already_processed.add('publicationDate')
            self.publicationDate = value
        value = find_attr_value_('entryIntoForceDate', node)
        if value is not None and 'entryIntoForceDate' not in already_processed:
            already_processed.add('entryIntoForceDate')
            self.entryIntoForceDate = value
        value = find_attr_value_('numberTitle', node)
        if value is not None and 'numberTitle' not in already_processed:
            already_processed.add('numberTitle')
            self.numberTitle = value
        value = find_attr_value_('programme', node)
        if value is not None and 'programme' not in already_processed:
            already_processed.add('programme')
            self.programme = value
        super(RegulationType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'publicationUrl':
            publicationUrl_ = child_.text
            publicationUrl_ = self.gds_validate_string(publicationUrl_, node, 'publicationUrl')
            self.publicationUrl = publicationUrl_
            # validate type DefaultUrlType
            self.validate_DefaultUrlType(self.publicationUrl)
        elif nodeName_ == 'corrigendum':
            obj_ = RegulationSummaryType.factory()
            obj_.build(child_)
            self.corrigendum.append(obj_)
            obj_.original_tagname_ = 'corrigendum'
        super(RegulationType, self).buildChildren(child_, node, nodeName_, True)
# end class RegulationType


class RegulationSummaryType(GeneratedsSuper):
    """The regulation summary is a type that contains the main information
    about a regulation."""
    subclass = None
    superclass = None
    def __init__(self, regulationType=None, publicationDate=None, numberTitle=None, publicationUrl=None):
        self.original_tagname_ = None
        self.regulationType = _cast(None, regulationType)
        self.publicationDate = _cast(None, publicationDate)
        self.numberTitle = _cast(None, numberTitle)
        self.publicationUrl = _cast(None, publicationUrl)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RegulationSummaryType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RegulationSummaryType.subclass:
            return RegulationSummaryType.subclass(*args_, **kwargs_)
        else:
            return RegulationSummaryType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_regulationType(self): return self.regulationType
    def set_regulationType(self, regulationType): self.regulationType = regulationType
    def get_publicationDate(self): return self.publicationDate
    def set_publicationDate(self, publicationDate): self.publicationDate = publicationDate
    def get_numberTitle(self): return self.numberTitle
    def set_numberTitle(self, numberTitle): self.numberTitle = numberTitle
    def get_publicationUrl(self): return self.publicationUrl
    def set_publicationUrl(self, publicationUrl): self.publicationUrl = publicationUrl
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='fsdexport:', name_='RegulationSummaryType', namespacedef_='xmlns:fsdexport="http://eu.europa.ec/fpi/fsd/export"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('RegulationSummaryType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RegulationSummaryType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='fsdexport:', name_='RegulationSummaryType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='fsdexport:', name_='RegulationSummaryType'):
        if self.regulationType is not None and 'regulationType' not in already_processed:
            already_processed.add('regulationType')
            outfile.write(' regulationType=%s' % (quote_attrib(self.regulationType), ))
        if self.publicationDate is not None and 'publicationDate' not in already_processed:
            already_processed.add('publicationDate')
            outfile.write(' publicationDate=%s' % (quote_attrib(self.publicationDate), ))
        if self.numberTitle is not None and 'numberTitle' not in already_processed:
            already_processed.add('numberTitle')
            outfile.write(' numberTitle=%s' % (quote_attrib(self.numberTitle), ))
        if self.publicationUrl is not None and 'publicationUrl' not in already_processed:
            already_processed.add('publicationUrl')
            outfile.write(' publicationUrl=%s' % (quote_attrib(self.publicationUrl), ))
    def exportChildren(self, outfile, level, namespace_='fsdexport:', name_='RegulationSummaryType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('regulationType', node)
        if value is not None and 'regulationType' not in already_processed:
            already_processed.add('regulationType')
            self.regulationType = value
        value = find_attr_value_('publicationDate', node)
        if value is not None and 'publicationDate' not in already_processed:
            already_processed.add('publicationDate')
            self.publicationDate = value
        value = find_attr_value_('numberTitle', node)
        if value is not None and 'numberTitle' not in already_processed:
            already_processed.add('numberTitle')
            self.numberTitle = value
        value = find_attr_value_('publicationUrl', node)
        if value is not None and 'publicationUrl' not in already_processed:
            already_processed.add('publicationUrl')
            self.publicationUrl = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class RegulationSummaryType


class SanctionEntityType(OperableType):
    """The sanction entity is a type that describes all that the system
    knows about an entity that is currently sanctioned. The
    delisting date is the date from which the entity should not be
    sanctioned anymore for the regulation. The designation date is
    the date of the first time the entity has been identified to be
    sanctioned."""
    subclass = None
    superclass = OperableType
    def __init__(self, logicalId=None, remark=None, additionalInformation=None, delistingDate=None, designationDate=None, designationDetails=None, unitedNationId=None, euReferenceNumber=None, regulation=None, subjectType=None, nameAlias=None, citizenship=None, birthdate=None, address=None, identification=None):
        self.original_tagname_ = None
        super(SanctionEntityType, self).__init__(logicalId, remark, additionalInformation, )
        self.delistingDate = _cast(None, delistingDate)
        self.designationDate = _cast(None, designationDate)
        self.designationDetails = _cast(None, designationDetails)
        self.unitedNationId = _cast(None, unitedNationId)
        self.euReferenceNumber = _cast(None, euReferenceNumber)
        self.regulation = regulation
        self.subjectType = subjectType
        if nameAlias is None:
            self.nameAlias = []
        else:
            self.nameAlias = nameAlias
        if citizenship is None:
            self.citizenship = []
        else:
            self.citizenship = citizenship
        if birthdate is None:
            self.birthdate = []
        else:
            self.birthdate = birthdate
        if address is None:
            self.address = []
        else:
            self.address = address
        if identification is None:
            self.identification = []
        else:
            self.identification = identification
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SanctionEntityType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SanctionEntityType.subclass:
            return SanctionEntityType.subclass(*args_, **kwargs_)
        else:
            return SanctionEntityType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_regulation(self): return self.regulation
    def set_regulation(self, regulation): self.regulation = regulation
    def get_subjectType(self): return self.subjectType
    def set_subjectType(self, subjectType): self.subjectType = subjectType
    def get_nameAlias(self): return self.nameAlias
    def set_nameAlias(self, nameAlias): self.nameAlias = nameAlias
    def add_nameAlias(self, value): self.nameAlias.append(value)
    def insert_nameAlias_at(self, index, value): self.nameAlias.insert(index, value)
    def replace_nameAlias_at(self, index, value): self.nameAlias[index] = value
    def get_citizenship(self): return self.citizenship
    def set_citizenship(self, citizenship): self.citizenship = citizenship
    def add_citizenship(self, value): self.citizenship.append(value)
    def insert_citizenship_at(self, index, value): self.citizenship.insert(index, value)
    def replace_citizenship_at(self, index, value): self.citizenship[index] = value
    def get_birthdate(self): return self.birthdate
    def set_birthdate(self, birthdate): self.birthdate = birthdate
    def add_birthdate(self, value): self.birthdate.append(value)
    def insert_birthdate_at(self, index, value): self.birthdate.insert(index, value)
    def replace_birthdate_at(self, index, value): self.birthdate[index] = value
    def get_address(self): return self.address
    def set_address(self, address): self.address = address
    def add_address(self, value): self.address.append(value)
    def insert_address_at(self, index, value): self.address.insert(index, value)
    def replace_address_at(self, index, value): self.address[index] = value
    def get_identification(self): return self.identification
    def set_identification(self, identification): self.identification = identification
    def add_identification(self, value): self.identification.append(value)
    def insert_identification_at(self, index, value): self.identification.insert(index, value)
    def replace_identification_at(self, index, value): self.identification[index] = value
    def get_delistingDate(self): return self.delistingDate
    def set_delistingDate(self, delistingDate): self.delistingDate = delistingDate
    def get_designationDate(self): return self.designationDate
    def set_designationDate(self, designationDate): self.designationDate = designationDate
    def get_designationDetails(self): return self.designationDetails
    def set_designationDetails(self, designationDetails): self.designationDetails = designationDetails
    def get_unitedNationId(self): return self.unitedNationId
    def set_unitedNationId(self, unitedNationId): self.unitedNationId = unitedNationId
    def get_euReferenceNumber(self): return self.euReferenceNumber
    def set_euReferenceNumber(self, euReferenceNumber): self.euReferenceNumber = euReferenceNumber
    def hasContent_(self):
        if (
            self.regulation is not None or
            self.subjectType is not None or
            self.nameAlias or
            self.citizenship or
            self.birthdate or
            self.address or
            self.identification or
            super(SanctionEntityType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='fsdexport:', name_='SanctionEntityType', namespacedef_='xmlns:fsdexport="http://eu.europa.ec/fpi/fsd/export"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SanctionEntityType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SanctionEntityType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='fsdexport:', name_='SanctionEntityType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='fsdexport:', name_='SanctionEntityType'):
        super(SanctionEntityType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='SanctionEntityType')
        if self.delistingDate is not None and 'delistingDate' not in already_processed:
            already_processed.add('delistingDate')
            outfile.write(' delistingDate=%s' % (quote_attrib(self.delistingDate), ))
        if self.designationDate is not None and 'designationDate' not in already_processed:
            already_processed.add('designationDate')
            outfile.write(' designationDate=%s' % (quote_attrib(self.designationDate), ))
        if self.designationDetails is not None and 'designationDetails' not in already_processed:
            already_processed.add('designationDetails')
            outfile.write(' designationDetails=%s' % (quote_attrib(self.designationDetails), ))
        if self.unitedNationId is not None and 'unitedNationId' not in already_processed:
            already_processed.add('unitedNationId')
            outfile.write(' unitedNationId=%s' % (quote_attrib(self.unitedNationId), ))
        if self.euReferenceNumber is not None and 'euReferenceNumber' not in already_processed:
            already_processed.add('euReferenceNumber')
            outfile.write(' euReferenceNumber=%s' % (quote_attrib(self.euReferenceNumber), ))
    def exportChildren(self, outfile, level, namespace_='fsdexport:', name_='SanctionEntityType', fromsubclass_=False, pretty_print=True):
        super(SanctionEntityType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.regulation is not None:
            self.regulation.export(outfile, level, namespace_, name_='regulation', pretty_print=pretty_print)
        if self.subjectType is not None:
            self.subjectType.export(outfile, level, namespace_, name_='subjectType', pretty_print=pretty_print)
        for nameAlias_ in self.nameAlias:
            nameAlias_.export(outfile, level, namespace_, name_='nameAlias', pretty_print=pretty_print)
        for citizenship_ in self.citizenship:
            citizenship_.export(outfile, level, namespace_, name_='citizenship', pretty_print=pretty_print)
        for birthdate_ in self.birthdate:
            birthdate_.export(outfile, level, namespace_, name_='birthdate', pretty_print=pretty_print)
        for address_ in self.address:
            address_.export(outfile, level, namespace_, name_='address', pretty_print=pretty_print)
        for identification_ in self.identification:
            identification_.export(outfile, level, namespace_, name_='identification', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('delistingDate', node)
        if value is not None and 'delistingDate' not in already_processed:
            already_processed.add('delistingDate')
            self.delistingDate = value
        value = find_attr_value_('designationDate', node)
        if value is not None and 'designationDate' not in already_processed:
            already_processed.add('designationDate')
            self.designationDate = value
        value = find_attr_value_('designationDetails', node)
        if value is not None and 'designationDetails' not in already_processed:
            already_processed.add('designationDetails')
            self.designationDetails = value
        value = find_attr_value_('unitedNationId', node)
        if value is not None and 'unitedNationId' not in already_processed:
            already_processed.add('unitedNationId')
            self.unitedNationId = value
        value = find_attr_value_('euReferenceNumber', node)
        if value is not None and 'euReferenceNumber' not in already_processed:
            already_processed.add('euReferenceNumber')
            self.euReferenceNumber = value
        super(SanctionEntityType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'regulation':
            obj_ = RegulationType.factory()
            obj_.build(child_)
            self.regulation = obj_
            obj_.original_tagname_ = 'regulation'
        elif nodeName_ == 'subjectType':
            obj_ = SubjectTypeType.factory()
            obj_.build(child_)
            self.subjectType = obj_
            obj_.original_tagname_ = 'subjectType'
        elif nodeName_ == 'nameAlias':
            obj_ = NameAliasType.factory()
            obj_.build(child_)
            self.nameAlias.append(obj_)
            obj_.original_tagname_ = 'nameAlias'
        elif nodeName_ == 'citizenship':
            obj_ = CitizenshipType.factory()
            obj_.build(child_)
            self.citizenship.append(obj_)
            obj_.original_tagname_ = 'citizenship'
        elif nodeName_ == 'birthdate':
            obj_ = BirthdateType.factory()
            obj_.build(child_)
            self.birthdate.append(obj_)
            obj_.original_tagname_ = 'birthdate'
        elif nodeName_ == 'address':
            obj_ = AddressType.factory()
            obj_.build(child_)
            self.address.append(obj_)
            obj_.original_tagname_ = 'address'
        elif nodeName_ == 'identification':
            obj_ = IdentificationType.factory()
            obj_.build(child_)
            self.identification.append(obj_)
            obj_.original_tagname_ = 'identification'
        super(SanctionEntityType, self).buildChildren(child_, node, nodeName_, True)
# end class SanctionEntityType


class SubjectTypeType(GeneratedsSuper):
    """The subject type is a type that gives information about the kind of
    entity that is sanctioned."""
    subclass = None
    superclass = None
    def __init__(self, code=None, classificationCode=None):
        self.original_tagname_ = None
        self.code = _cast(None, code)
        self.classificationCode = _cast(None, classificationCode)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SubjectTypeType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SubjectTypeType.subclass:
            return SubjectTypeType.subclass(*args_, **kwargs_)
        else:
            return SubjectTypeType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_code(self): return self.code
    def set_code(self, code): self.code = code
    def get_classificationCode(self): return self.classificationCode
    def set_classificationCode(self, classificationCode): self.classificationCode = classificationCode
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='fsdexport:', name_='SubjectTypeType', namespacedef_='xmlns:fsdexport="http://eu.europa.ec/fpi/fsd/export"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SubjectTypeType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SubjectTypeType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='fsdexport:', name_='SubjectTypeType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='fsdexport:', name_='SubjectTypeType'):
        if self.code is not None and 'code' not in already_processed:
            already_processed.add('code')
            outfile.write(' code=%s' % (quote_attrib(self.code), ))
        if self.classificationCode is not None and 'classificationCode' not in already_processed:
            already_processed.add('classificationCode')
            outfile.write(' classificationCode=%s' % (quote_attrib(self.classificationCode), ))
    def exportChildren(self, outfile, level, namespace_='fsdexport:', name_='SubjectTypeType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('code', node)
        if value is not None and 'code' not in already_processed:
            already_processed.add('code')
            self.code = value
        value = find_attr_value_('classificationCode', node)
        if value is not None and 'classificationCode' not in already_processed:
            already_processed.add('classificationCode')
            self.classificationCode = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class SubjectTypeType


class SanctionableType(OperableType):
    """SanctionableType contains all the elements and attributes common to
    all the details of a sanction entity. This is an abstract type,
    so no element of this type will be present in the XML."""
    subclass = None
    superclass = OperableType
    def __init__(self, logicalId=None, remark=None, additionalInformation=None, regulationLanguage=None, regulationSummary=None, extensiontype_=None):
        self.original_tagname_ = None
        super(SanctionableType, self).__init__(logicalId, remark, additionalInformation, extensiontype_, )
        self.regulationLanguage = _cast(None, regulationLanguage)
        self.regulationSummary = regulationSummary
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SanctionableType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SanctionableType.subclass:
            return SanctionableType.subclass(*args_, **kwargs_)
        else:
            return SanctionableType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_regulationSummary(self): return self.regulationSummary
    def set_regulationSummary(self, regulationSummary): self.regulationSummary = regulationSummary
    def get_regulationLanguage(self): return self.regulationLanguage
    def set_regulationLanguage(self, regulationLanguage): self.regulationLanguage = regulationLanguage
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            self.regulationSummary is not None or
            super(SanctionableType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='fsdexport:', name_='SanctionableType', namespacedef_='xmlns:fsdexport="http://eu.europa.ec/fpi/fsd/export"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SanctionableType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SanctionableType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='fsdexport:', name_='SanctionableType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='fsdexport:', name_='SanctionableType'):
        super(SanctionableType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='SanctionableType')
        if self.regulationLanguage is not None and 'regulationLanguage' not in already_processed:
            already_processed.add('regulationLanguage')
            outfile.write(' regulationLanguage=%s' % (quote_attrib(self.regulationLanguage), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='fsdexport:', name_='SanctionableType', fromsubclass_=False, pretty_print=True):
        super(SanctionableType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.regulationSummary is not None:
            self.regulationSummary.export(outfile, level, namespace_, name_='regulationSummary', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('regulationLanguage', node)
        if value is not None and 'regulationLanguage' not in already_processed:
            already_processed.add('regulationLanguage')
            self.regulationLanguage = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(SanctionableType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'regulationSummary':
            obj_ = RegulationSummaryType.factory()
            obj_.build(child_)
            self.regulationSummary = obj_
            obj_.original_tagname_ = 'regulationSummary'
        super(SanctionableType, self).buildChildren(child_, node, nodeName_, True)
# end class SanctionableType


class NameAliasType(SanctionableType):
    """The name alias is a type that describes all that the system knows
    about the name associated to a sanctioned entity. The
    nameLanguage, if present, might be different than the
    regulationLanguage if the name is expressed in another language
    than the one of the regulation. The strong flag means that the
    current name alias is the main on for the sanctioned entity."""
    subclass = None
    superclass = SanctionableType
    def __init__(self, logicalId=None, remark=None, additionalInformation=None, regulationLanguage=None, regulationSummary=None, firstName=None, middleName=None, lastName=None, wholeName=None, function=None, gender=None, title=None, nameLanguage=None, strong=None):
        self.original_tagname_ = None
        super(NameAliasType, self).__init__(logicalId, remark, additionalInformation, regulationLanguage, regulationSummary, )
        self.firstName = _cast(None, firstName)
        self.middleName = _cast(None, middleName)
        self.lastName = _cast(None, lastName)
        self.wholeName = _cast(None, wholeName)
        self.function = _cast(None, function)
        self.gender = _cast(None, gender)
        self.title = _cast(None, title)
        self.nameLanguage = _cast(None, nameLanguage)
        self.strong = _cast(bool, strong)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, NameAliasType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if NameAliasType.subclass:
            return NameAliasType.subclass(*args_, **kwargs_)
        else:
            return NameAliasType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_firstName(self): return self.firstName
    def set_firstName(self, firstName): self.firstName = firstName
    def get_middleName(self): return self.middleName
    def set_middleName(self, middleName): self.middleName = middleName
    def get_lastName(self): return self.lastName
    def set_lastName(self, lastName): self.lastName = lastName
    def get_wholeName(self): return self.wholeName
    def set_wholeName(self, wholeName): self.wholeName = wholeName
    def get_function(self): return self.function
    def set_function(self, function): self.function = function
    def get_gender(self): return self.gender
    def set_gender(self, gender): self.gender = gender
    def get_title(self): return self.title
    def set_title(self, title): self.title = title
    def get_nameLanguage(self): return self.nameLanguage
    def set_nameLanguage(self, nameLanguage): self.nameLanguage = nameLanguage
    def get_strong(self): return self.strong
    def set_strong(self, strong): self.strong = strong
    def hasContent_(self):
        if (
            super(NameAliasType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='fsdexport:', name_='NameAliasType', namespacedef_='xmlns:fsdexport="http://eu.europa.ec/fpi/fsd/export"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('NameAliasType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='NameAliasType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='fsdexport:', name_='NameAliasType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='fsdexport:', name_='NameAliasType'):
        super(NameAliasType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='NameAliasType')
        if self.firstName is not None and 'firstName' not in already_processed:
            already_processed.add('firstName')
            outfile.write(' firstName=%s' % (quote_attrib(self.firstName), ))
        if self.middleName is not None and 'middleName' not in already_processed:
            already_processed.add('middleName')
            outfile.write(' middleName=%s' % (quote_attrib(self.middleName), ))
        if self.lastName is not None and 'lastName' not in already_processed:
            already_processed.add('lastName')
            outfile.write(' lastName=%s' % (quote_attrib(self.lastName), ))
        if self.wholeName is not None and 'wholeName' not in already_processed:
            already_processed.add('wholeName')
            outfile.write(' wholeName=%s' % (quote_attrib(self.wholeName), ))
        if self.function is not None and 'function' not in already_processed:
            already_processed.add('function')
            outfile.write(' function=%s' % (quote_attrib(self.function), ))
        if self.gender is not None and 'gender' not in already_processed:
            already_processed.add('gender')
            outfile.write(' gender=%s' % (quote_attrib(self.gender), ))
        if self.title is not None and 'title' not in already_processed:
            already_processed.add('title')
            outfile.write(' title=%s' % (quote_attrib(self.title), ))
        if self.nameLanguage is not None and 'nameLanguage' not in already_processed:
            already_processed.add('nameLanguage')
            outfile.write(' nameLanguage=%s' % (quote_attrib(self.nameLanguage), ))
        if self.strong is not None and 'strong' not in already_processed:
            already_processed.add('strong')
            outfile.write(' strong=%s' % (quote_attrib(self.strong), ))
    def exportChildren(self, outfile, level, namespace_='fsdexport:', name_='NameAliasType', fromsubclass_=False, pretty_print=True):
        super(NameAliasType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('firstName', node)
        if value is not None and 'firstName' not in already_processed:
            already_processed.add('firstName')
            self.firstName = value
        value = find_attr_value_('middleName', node)
        if value is not None and 'middleName' not in already_processed:
            already_processed.add('middleName')
            self.middleName = value
        value = find_attr_value_('lastName', node)
        if value is not None and 'lastName' not in already_processed:
            already_processed.add('lastName')
            self.lastName = value
        value = find_attr_value_('wholeName', node)
        if value is not None and 'wholeName' not in already_processed:
            already_processed.add('wholeName')
            self.wholeName = value
        value = find_attr_value_('function', node)
        if value is not None and 'function' not in already_processed:
            already_processed.add('function')
            self.function = value
        value = find_attr_value_('gender', node)
        if value is not None and 'gender' not in already_processed:
            already_processed.add('gender')
            self.gender = value
        value = find_attr_value_('title', node)
        if value is not None and 'title' not in already_processed:
            already_processed.add('title')
            self.title = value
        value = find_attr_value_('nameLanguage', node)
        if value is not None and 'nameLanguage' not in already_processed:
            already_processed.add('nameLanguage')
            self.nameLanguage = value
        value = find_attr_value_('strong', node)
        if value is not None and 'strong' not in already_processed:
            already_processed.add('strong')
            self.strong = value
        super(NameAliasType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(NameAliasType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class NameAliasType


class CitizenshipType(SanctionableType):
    """The citizenship is a type that describes all that the system knows
    about the citizenship associated to a sanctioned entity."""
    subclass = None
    superclass = SanctionableType
    def __init__(self, logicalId=None, remark=None, additionalInformation=None, regulationLanguage=None, regulationSummary=None, acquisitionDate=None, disenfranchisementDate=None, region=None, countryIso2Code=None, countryDescription=None):
        self.original_tagname_ = None
        super(CitizenshipType, self).__init__(logicalId, remark, additionalInformation, regulationLanguage, regulationSummary, )
        self.acquisitionDate = _cast(None, acquisitionDate)
        self.disenfranchisementDate = _cast(None, disenfranchisementDate)
        self.region = _cast(None, region)
        self.countryIso2Code = _cast(None, countryIso2Code)
        self.countryDescription = _cast(None, countryDescription)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CitizenshipType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CitizenshipType.subclass:
            return CitizenshipType.subclass(*args_, **kwargs_)
        else:
            return CitizenshipType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_acquisitionDate(self): return self.acquisitionDate
    def set_acquisitionDate(self, acquisitionDate): self.acquisitionDate = acquisitionDate
    def get_disenfranchisementDate(self): return self.disenfranchisementDate
    def set_disenfranchisementDate(self, disenfranchisementDate): self.disenfranchisementDate = disenfranchisementDate
    def get_region(self): return self.region
    def set_region(self, region): self.region = region
    def get_countryIso2Code(self): return self.countryIso2Code
    def set_countryIso2Code(self, countryIso2Code): self.countryIso2Code = countryIso2Code
    def get_countryDescription(self): return self.countryDescription
    def set_countryDescription(self, countryDescription): self.countryDescription = countryDescription
    def hasContent_(self):
        if (
            super(CitizenshipType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='fsdexport:', name_='CitizenshipType', namespacedef_='xmlns:fsdexport="http://eu.europa.ec/fpi/fsd/export"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CitizenshipType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CitizenshipType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='fsdexport:', name_='CitizenshipType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='fsdexport:', name_='CitizenshipType'):
        super(CitizenshipType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='CitizenshipType')
        if self.acquisitionDate is not None and 'acquisitionDate' not in already_processed:
            already_processed.add('acquisitionDate')
            outfile.write(' acquisitionDate=%s' % (quote_attrib(self.acquisitionDate), ))
        if self.disenfranchisementDate is not None and 'disenfranchisementDate' not in already_processed:
            already_processed.add('disenfranchisementDate')
            outfile.write(' disenfranchisementDate=%s' % (quote_attrib(self.disenfranchisementDate), ))
        if self.region is not None and 'region' not in already_processed:
            already_processed.add('region')
            outfile.write(' region=%s' % (quote_attrib(self.region), ))
        if self.countryIso2Code is not None and 'countryIso2Code' not in already_processed:
            already_processed.add('countryIso2Code')
            outfile.write(' countryIso2Code=%s' % (quote_attrib(self.countryIso2Code), ))
        if self.countryDescription is not None and 'countryDescription' not in already_processed:
            already_processed.add('countryDescription')
            outfile.write(' countryDescription=%s' % (quote_attrib(self.countryDescription), ))
    def exportChildren(self, outfile, level, namespace_='fsdexport:', name_='CitizenshipType', fromsubclass_=False, pretty_print=True):
        super(CitizenshipType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('acquisitionDate', node)
        if value is not None and 'acquisitionDate' not in already_processed:
            already_processed.add('acquisitionDate')
            self.acquisitionDate = value
        value = find_attr_value_('disenfranchisementDate', node)
        if value is not None and 'disenfranchisementDate' not in already_processed:
            already_processed.add('disenfranchisementDate')
            self.disenfranchisementDate = value
        value = find_attr_value_('region', node)
        if value is not None and 'region' not in already_processed:
            already_processed.add('region')
            self.region = value
        value = find_attr_value_('countryIso2Code', node)
        if value is not None and 'countryIso2Code' not in already_processed:
            already_processed.add('countryIso2Code')
            self.countryIso2Code = value
        value = find_attr_value_('countryDescription', node)
        if value is not None and 'countryDescription' not in already_processed:
            already_processed.add('countryDescription')
            self.countryDescription = value
        super(CitizenshipType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(CitizenshipType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class CitizenshipType


class BirthdateType(SanctionableType):
    """The birthdate is a type that describes all that the system knows
    about the birthdate associated to a sanctioned entity."""
    subclass = None
    superclass = SanctionableType
    def __init__(self, logicalId=None, remark=None, additionalInformation=None, regulationLanguage=None, regulationSummary=None, circa=None, calendarType=None, city=None, zipCode=None, birthdate=None, dayOfMonth=None, monthOfYear=None, year=None, yearRangeFrom=None, yearRangeTo=None, region=None, place=None, countryIso2Code=None, countryDescription=None):
        self.original_tagname_ = None
        super(BirthdateType, self).__init__(logicalId, remark, additionalInformation, regulationLanguage, regulationSummary, )
        self.circa = _cast(bool, circa)
        self.calendarType = _cast(None, calendarType)
        self.city = _cast(None, city)
        self.zipCode = _cast(None, zipCode)
        self.birthdate = _cast(None, birthdate)
        self.dayOfMonth = _cast(int, dayOfMonth)
        self.monthOfYear = _cast(int, monthOfYear)
        self.year = _cast(int, year)
        self.yearRangeFrom = _cast(int, yearRangeFrom)
        self.yearRangeTo = _cast(int, yearRangeTo)
        self.region = _cast(None, region)
        self.place = _cast(None, place)
        self.countryIso2Code = _cast(None, countryIso2Code)
        self.countryDescription = _cast(None, countryDescription)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, BirthdateType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if BirthdateType.subclass:
            return BirthdateType.subclass(*args_, **kwargs_)
        else:
            return BirthdateType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_circa(self): return self.circa
    def set_circa(self, circa): self.circa = circa
    def get_calendarType(self): return self.calendarType
    def set_calendarType(self, calendarType): self.calendarType = calendarType
    def get_city(self): return self.city
    def set_city(self, city): self.city = city
    def get_zipCode(self): return self.zipCode
    def set_zipCode(self, zipCode): self.zipCode = zipCode
    def get_birthdate(self): return self.birthdate
    def set_birthdate(self, birthdate): self.birthdate = birthdate
    def get_dayOfMonth(self): return self.dayOfMonth
    def set_dayOfMonth(self, dayOfMonth): self.dayOfMonth = dayOfMonth
    def get_monthOfYear(self): return self.monthOfYear
    def set_monthOfYear(self, monthOfYear): self.monthOfYear = monthOfYear
    def get_year(self): return self.year
    def set_year(self, year): self.year = year
    def get_yearRangeFrom(self): return self.yearRangeFrom
    def set_yearRangeFrom(self, yearRangeFrom): self.yearRangeFrom = yearRangeFrom
    def get_yearRangeTo(self): return self.yearRangeTo
    def set_yearRangeTo(self, yearRangeTo): self.yearRangeTo = yearRangeTo
    def get_region(self): return self.region
    def set_region(self, region): self.region = region
    def get_place(self): return self.place
    def set_place(self, place): self.place = place
    def get_countryIso2Code(self): return self.countryIso2Code
    def set_countryIso2Code(self, countryIso2Code): self.countryIso2Code = countryIso2Code
    def get_countryDescription(self): return self.countryDescription
    def set_countryDescription(self, countryDescription): self.countryDescription = countryDescription
    def hasContent_(self):
        if (
            super(BirthdateType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='fsdexport:', name_='BirthdateType', namespacedef_='xmlns:fsdexport="http://eu.europa.ec/fpi/fsd/export"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('BirthdateType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='BirthdateType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='fsdexport:', name_='BirthdateType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='fsdexport:', name_='BirthdateType'):
        super(BirthdateType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='BirthdateType')
        if self.circa is not None and 'circa' not in already_processed:
            already_processed.add('circa')
            outfile.write(' circa=%s' % (quote_attrib(self.circa), ))
        if self.calendarType is not None and 'calendarType' not in already_processed:
            already_processed.add('calendarType')
            outfile.write(' calendarType=%s' % (quote_attrib(self.calendarType), ))
        if self.city is not None and 'city' not in already_processed:
            already_processed.add('city')
            outfile.write(' city=%s' % (quote_attrib(self.city), ))
        if self.zipCode is not None and 'zipCode' not in already_processed:
            already_processed.add('zipCode')
            outfile.write(' zipCode=%s' % (quote_attrib(self.zipCode), ))
        if self.birthdate is not None and 'birthdate' not in already_processed:
            already_processed.add('birthdate')
            outfile.write(' birthdate=%s' % (quote_attrib(self.birthdate), ))
        if self.dayOfMonth is not None and 'dayOfMonth' not in already_processed:
            already_processed.add('dayOfMonth')
            outfile.write(' dayOfMonth="%s"' % self.gds_format_integer(self.dayOfMonth, input_name='dayOfMonth'))
        if self.monthOfYear is not None and 'monthOfYear' not in already_processed:
            already_processed.add('monthOfYear')
            outfile.write(' monthOfYear="%s"' % self.gds_format_integer(self.monthOfYear, input_name='monthOfYear'))
        if self.year is not None and 'year' not in already_processed:
            already_processed.add('year')
            outfile.write(' year="%s"' % self.gds_format_integer(self.year, input_name='year'))
        if self.yearRangeFrom is not None and 'yearRangeFrom' not in already_processed:
            already_processed.add('yearRangeFrom')
            outfile.write(' yearRangeFrom="%s"' % self.gds_format_integer(self.yearRangeFrom, input_name='yearRangeFrom'))
        if self.yearRangeTo is not None and 'yearRangeTo' not in already_processed:
            already_processed.add('yearRangeTo')
            outfile.write(' yearRangeTo="%s"' % self.gds_format_integer(self.yearRangeTo, input_name='yearRangeTo'))
        if self.region is not None and 'region' not in already_processed:
            already_processed.add('region')
            outfile.write(' region=%s' % (quote_attrib(self.region), ))
        if self.place is not None and 'place' not in already_processed:
            already_processed.add('place')
            outfile.write(' place=%s' % (quote_attrib(self.place), ))
        if self.countryIso2Code is not None and 'countryIso2Code' not in already_processed:
            already_processed.add('countryIso2Code')
            outfile.write(' countryIso2Code=%s' % (quote_attrib(self.countryIso2Code), ))
        if self.countryDescription is not None and 'countryDescription' not in already_processed:
            already_processed.add('countryDescription')
            outfile.write(' countryDescription=%s' % (quote_attrib(self.countryDescription), ))
    def exportChildren(self, outfile, level, namespace_='fsdexport:', name_='BirthdateType', fromsubclass_=False, pretty_print=True):
        super(BirthdateType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('circa', node)
        if value is not None and 'circa' not in already_processed:
            already_processed.add('circa')
            self.circa = value
        value = find_attr_value_('calendarType', node)
        if value is not None and 'calendarType' not in already_processed:
            already_processed.add('calendarType')
            self.calendarType = value
        value = find_attr_value_('city', node)
        if value is not None and 'city' not in already_processed:
            already_processed.add('city')
            self.city = value
        value = find_attr_value_('zipCode', node)
        if value is not None and 'zipCode' not in already_processed:
            already_processed.add('zipCode')
            self.zipCode = value
        value = find_attr_value_('birthdate', node)
        if value is not None and 'birthdate' not in already_processed:
            already_processed.add('birthdate')
            self.birthdate = value
        value = find_attr_value_('dayOfMonth', node)
        if value is not None and 'dayOfMonth' not in already_processed:
            already_processed.add('dayOfMonth')
            try:
                self.dayOfMonth = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('monthOfYear', node)
        if value is not None and 'monthOfYear' not in already_processed:
            already_processed.add('monthOfYear')
            try:
                self.monthOfYear = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('year', node)
        if value is not None and 'year' not in already_processed:
            already_processed.add('year')
            try:
                self.year = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('yearRangeFrom', node)
        if value is not None and 'yearRangeFrom' not in already_processed:
            already_processed.add('yearRangeFrom')
            try:
                self.yearRangeFrom = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('yearRangeTo', node)
        if value is not None and 'yearRangeTo' not in already_processed:
            already_processed.add('yearRangeTo')
            try:
                self.yearRangeTo = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('region', node)
        if value is not None and 'region' not in already_processed:
            already_processed.add('region')
            self.region = value
        value = find_attr_value_('place', node)
        if value is not None and 'place' not in already_processed:
            already_processed.add('place')
            self.place = value
        value = find_attr_value_('countryIso2Code', node)
        if value is not None and 'countryIso2Code' not in already_processed:
            already_processed.add('countryIso2Code')
            self.countryIso2Code = value
        value = find_attr_value_('countryDescription', node)
        if value is not None and 'countryDescription' not in already_processed:
            already_processed.add('countryDescription')
            self.countryDescription = value
        super(BirthdateType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(BirthdateType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class BirthdateType


class AddressType(SanctionableType):
    """The address is a type that describes all that the system knows about
    the address associated to a sanctioned entity. The
    asAtListingTime flag means that this was the know address of the
    sanctioned entity what it was listed for the first time."""
    subclass = None
    superclass = SanctionableType
    def __init__(self, logicalId=None, remark=None, additionalInformation=None, regulationLanguage=None, regulationSummary=None, city=None, street=None, poBox=None, zipCode=None, region=None, place=None, asAtListingTime=None, countryIso2Code=None, countryDescription=None, contactInfo=None):
        self.original_tagname_ = None
        super(AddressType, self).__init__(logicalId, remark, additionalInformation, regulationLanguage, regulationSummary, )
        self.city = _cast(None, city)
        self.street = _cast(None, street)
        self.poBox = _cast(None, poBox)
        self.zipCode = _cast(None, zipCode)
        self.region = _cast(None, region)
        self.place = _cast(None, place)
        self.asAtListingTime = _cast(bool, asAtListingTime)
        self.countryIso2Code = _cast(None, countryIso2Code)
        self.countryDescription = _cast(None, countryDescription)
        if contactInfo is None:
            self.contactInfo = []
        else:
            self.contactInfo = contactInfo
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AddressType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AddressType.subclass:
            return AddressType.subclass(*args_, **kwargs_)
        else:
            return AddressType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_contactInfo(self): return self.contactInfo
    def set_contactInfo(self, contactInfo): self.contactInfo = contactInfo
    def add_contactInfo(self, value): self.contactInfo.append(value)
    def insert_contactInfo_at(self, index, value): self.contactInfo.insert(index, value)
    def replace_contactInfo_at(self, index, value): self.contactInfo[index] = value
    def get_city(self): return self.city
    def set_city(self, city): self.city = city
    def get_street(self): return self.street
    def set_street(self, street): self.street = street
    def get_poBox(self): return self.poBox
    def set_poBox(self, poBox): self.poBox = poBox
    def get_zipCode(self): return self.zipCode
    def set_zipCode(self, zipCode): self.zipCode = zipCode
    def get_region(self): return self.region
    def set_region(self, region): self.region = region
    def get_place(self): return self.place
    def set_place(self, place): self.place = place
    def get_asAtListingTime(self): return self.asAtListingTime
    def set_asAtListingTime(self, asAtListingTime): self.asAtListingTime = asAtListingTime
    def get_countryIso2Code(self): return self.countryIso2Code
    def set_countryIso2Code(self, countryIso2Code): self.countryIso2Code = countryIso2Code
    def get_countryDescription(self): return self.countryDescription
    def set_countryDescription(self, countryDescription): self.countryDescription = countryDescription
    def hasContent_(self):
        if (
            self.contactInfo or
            super(AddressType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='fsdexport:', name_='AddressType', namespacedef_='xmlns:fsdexport="http://eu.europa.ec/fpi/fsd/export"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('AddressType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AddressType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='fsdexport:', name_='AddressType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='fsdexport:', name_='AddressType'):
        super(AddressType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='AddressType')
        if self.city is not None and 'city' not in already_processed:
            already_processed.add('city')
            outfile.write(' city=%s' % (quote_attrib(self.city), ))
        if self.street is not None and 'street' not in already_processed:
            already_processed.add('street')
            outfile.write(' street=%s' % (quote_attrib(self.street), ))
        if self.poBox is not None and 'poBox' not in already_processed:
            already_processed.add('poBox')
            outfile.write(' poBox=%s' % (quote_attrib(self.poBox), ))
        if self.zipCode is not None and 'zipCode' not in already_processed:
            already_processed.add('zipCode')
            outfile.write(' zipCode=%s' % (quote_attrib(self.zipCode), ))
        if self.region is not None and 'region' not in already_processed:
            already_processed.add('region')
            outfile.write(' region=%s' % (quote_attrib(self.region), ))
        if self.place is not None and 'place' not in already_processed:
            already_processed.add('place')
            outfile.write(' place=%s' % (quote_attrib(self.place), ))
        if self.asAtListingTime is not None and 'asAtListingTime' not in already_processed:
            already_processed.add('asAtListingTime')
            outfile.write(' asAtListingTime=%s' % (quote_attrib(self.asAtListingTime), ))
        if self.countryIso2Code is not None and 'countryIso2Code' not in already_processed:
            already_processed.add('countryIso2Code')
            outfile.write(' countryIso2Code=%s' % (quote_attrib(self.countryIso2Code), ))
        if self.countryDescription is not None and 'countryDescription' not in already_processed:
            already_processed.add('countryDescription')
            outfile.write(' countryDescription=%s' % (quote_attrib(self.countryDescription), ))
    def exportChildren(self, outfile, level, namespace_='fsdexport:', name_='AddressType', fromsubclass_=False, pretty_print=True):
        super(AddressType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for contactInfo_ in self.contactInfo:
            contactInfo_.export(outfile, level, namespace_, name_='contactInfo', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('city', node)
        if value is not None and 'city' not in already_processed:
            already_processed.add('city')
            self.city = value
        value = find_attr_value_('street', node)
        if value is not None and 'street' not in already_processed:
            already_processed.add('street')
            self.street = value
        value = find_attr_value_('poBox', node)
        if value is not None and 'poBox' not in already_processed:
            already_processed.add('poBox')
            self.poBox = value
        value = find_attr_value_('zipCode', node)
        if value is not None and 'zipCode' not in already_processed:
            already_processed.add('zipCode')
            self.zipCode = value
        value = find_attr_value_('region', node)
        if value is not None and 'region' not in already_processed:
            already_processed.add('region')
            self.region = value
        value = find_attr_value_('place', node)
        if value is not None and 'place' not in already_processed:
            already_processed.add('place')
            self.place = value
        value = find_attr_value_('asAtListingTime', node)
        if value is not None and 'asAtListingTime' not in already_processed:
            already_processed.add('asAtListingTime')
            self.asAtListingTime = value
        value = find_attr_value_('countryIso2Code', node)
        if value is not None and 'countryIso2Code' not in already_processed:
            already_processed.add('countryIso2Code')
            self.countryIso2Code = value
        value = find_attr_value_('countryDescription', node)
        if value is not None and 'countryDescription' not in already_processed:
            already_processed.add('countryDescription')
            self.countryDescription = value
        super(AddressType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'contactInfo':
            obj_ = ContactInfoType.factory()
            obj_.build(child_)
            self.contactInfo.append(obj_)
            obj_.original_tagname_ = 'contactInfo'
        super(AddressType, self).buildChildren(child_, node, nodeName_, True)
# end class AddressType


class IdentificationType(SanctionableType):
    """The identification is a type that describes all that the system
    knows about the identification document associated to a
    sanctioned entity."""
    subclass = None
    superclass = SanctionableType
    def __init__(self, logicalId=None, remark=None, additionalInformation=None, regulationLanguage=None, regulationSummary=None, diplomatic=None, knownExpired=None, knownFalse=None, reportedLost=None, revokedByIssuer=None, issueDate=None, issuedBy=None, latinNumber=None, nameOnDocument=None, number=None, validFrom=None, validTo=None, region=None, identificationTypeCode=None, identificationTypeDescription=None, countryIso2Code=None, countryDescription=None):
        self.original_tagname_ = None
        super(IdentificationType, self).__init__(logicalId, remark, additionalInformation, regulationLanguage, regulationSummary, )
        self.diplomatic = _cast(bool, diplomatic)
        self.knownExpired = _cast(bool, knownExpired)
        self.knownFalse = _cast(bool, knownFalse)
        self.reportedLost = _cast(bool, reportedLost)
        self.revokedByIssuer = _cast(bool, revokedByIssuer)
        self.issueDate = _cast(None, issueDate)
        self.issuedBy = _cast(None, issuedBy)
        self.latinNumber = _cast(None, latinNumber)
        self.nameOnDocument = _cast(None, nameOnDocument)
        self.number = _cast(None, number)
        self.validFrom = _cast(None, validFrom)
        self.validTo = _cast(None, validTo)
        self.region = _cast(None, region)
        self.identificationTypeCode = _cast(None, identificationTypeCode)
        self.identificationTypeDescription = _cast(None, identificationTypeDescription)
        self.countryIso2Code = _cast(None, countryIso2Code)
        self.countryDescription = _cast(None, countryDescription)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, IdentificationType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if IdentificationType.subclass:
            return IdentificationType.subclass(*args_, **kwargs_)
        else:
            return IdentificationType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_diplomatic(self): return self.diplomatic
    def set_diplomatic(self, diplomatic): self.diplomatic = diplomatic
    def get_knownExpired(self): return self.knownExpired
    def set_knownExpired(self, knownExpired): self.knownExpired = knownExpired
    def get_knownFalse(self): return self.knownFalse
    def set_knownFalse(self, knownFalse): self.knownFalse = knownFalse
    def get_reportedLost(self): return self.reportedLost
    def set_reportedLost(self, reportedLost): self.reportedLost = reportedLost
    def get_revokedByIssuer(self): return self.revokedByIssuer
    def set_revokedByIssuer(self, revokedByIssuer): self.revokedByIssuer = revokedByIssuer
    def get_issueDate(self): return self.issueDate
    def set_issueDate(self, issueDate): self.issueDate = issueDate
    def get_issuedBy(self): return self.issuedBy
    def set_issuedBy(self, issuedBy): self.issuedBy = issuedBy
    def get_latinNumber(self): return self.latinNumber
    def set_latinNumber(self, latinNumber): self.latinNumber = latinNumber
    def get_nameOnDocument(self): return self.nameOnDocument
    def set_nameOnDocument(self, nameOnDocument): self.nameOnDocument = nameOnDocument
    def get_number(self): return self.number
    def set_number(self, number): self.number = number
    def get_validFrom(self): return self.validFrom
    def set_validFrom(self, validFrom): self.validFrom = validFrom
    def get_validTo(self): return self.validTo
    def set_validTo(self, validTo): self.validTo = validTo
    def get_region(self): return self.region
    def set_region(self, region): self.region = region
    def get_identificationTypeCode(self): return self.identificationTypeCode
    def set_identificationTypeCode(self, identificationTypeCode): self.identificationTypeCode = identificationTypeCode
    def get_identificationTypeDescription(self): return self.identificationTypeDescription
    def set_identificationTypeDescription(self, identificationTypeDescription): self.identificationTypeDescription = identificationTypeDescription
    def get_countryIso2Code(self): return self.countryIso2Code
    def set_countryIso2Code(self, countryIso2Code): self.countryIso2Code = countryIso2Code
    def get_countryDescription(self): return self.countryDescription
    def set_countryDescription(self, countryDescription): self.countryDescription = countryDescription
    def hasContent_(self):
        if (
            super(IdentificationType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='fsdexport:', name_='IdentificationType', namespacedef_='xmlns:fsdexport="http://eu.europa.ec/fpi/fsd/export"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('IdentificationType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='IdentificationType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='fsdexport:', name_='IdentificationType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='fsdexport:', name_='IdentificationType'):
        super(IdentificationType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='IdentificationType')
        if self.diplomatic is not None and 'diplomatic' not in already_processed:
            already_processed.add('diplomatic')
            outfile.write(' diplomatic=%s' % (quote_attrib(self.diplomatic), ))
        if self.knownExpired is not None and 'knownExpired' not in already_processed:
            already_processed.add('knownExpired')
            outfile.write(' knownExpired=%s' % (quote_attrib(self.knownExpired), ))
        if self.knownFalse is not None and 'knownFalse' not in already_processed:
            already_processed.add('knownFalse')
            outfile.write(' knownFalse=%s' % (quote_attrib(self.knownFalse), ))
        if self.reportedLost is not None and 'reportedLost' not in already_processed:
            already_processed.add('reportedLost')
            outfile.write(' reportedLost=%s' % (quote_attrib(self.reportedLost), ))
        if self.revokedByIssuer is not None and 'revokedByIssuer' not in already_processed:
            already_processed.add('revokedByIssuer')
            outfile.write(' revokedByIssuer=%s' % (quote_attrib(self.revokedByIssuer), ))
        if self.issueDate is not None and 'issueDate' not in already_processed:
            already_processed.add('issueDate')
            outfile.write(' issueDate=%s' % (quote_attrib(self.issueDate), ))
        if self.issuedBy is not None and 'issuedBy' not in already_processed:
            already_processed.add('issuedBy')
            outfile.write(' issuedBy=%s' % (quote_attrib(self.issuedBy), ))
        if self.latinNumber is not None and 'latinNumber' not in already_processed:
            already_processed.add('latinNumber')
            outfile.write(' latinNumber=%s' % (quote_attrib(self.latinNumber), ))
        if self.nameOnDocument is not None and 'nameOnDocument' not in already_processed:
            already_processed.add('nameOnDocument')
            outfile.write(' nameOnDocument=%s' % (quote_attrib(self.nameOnDocument), ))
        if self.number is not None and 'number' not in already_processed:
            already_processed.add('number')
            outfile.write(' number=%s' % (quote_attrib(self.number), ))
        if self.validFrom is not None and 'validFrom' not in already_processed:
            already_processed.add('validFrom')
            outfile.write(' validFrom=%s' % (quote_attrib(self.validFrom), ))
        if self.validTo is not None and 'validTo' not in already_processed:
            already_processed.add('validTo')
            outfile.write(' validTo=%s' % (quote_attrib(self.validTo), ))
        if self.region is not None and 'region' not in already_processed:
            already_processed.add('region')
            outfile.write(' region=%s' % (quote_attrib(self.region), ))
        if self.identificationTypeCode is not None and 'identificationTypeCode' not in already_processed:
            already_processed.add('identificationTypeCode')
            outfile.write(' identificationTypeCode=%s' % (quote_attrib(self.identificationTypeCode), ))
        if self.identificationTypeDescription is not None and 'identificationTypeDescription' not in already_processed:
            already_processed.add('identificationTypeDescription')
            outfile.write(' identificationTypeDescription=%s' % (quote_attrib(self.identificationTypeDescription), ))
        if self.countryIso2Code is not None and 'countryIso2Code' not in already_processed:
            already_processed.add('countryIso2Code')
            outfile.write(' countryIso2Code=%s' % (quote_attrib(self.countryIso2Code), ))
        if self.countryDescription is not None and 'countryDescription' not in already_processed:
            already_processed.add('countryDescription')
            outfile.write(' countryDescription=%s' % (quote_attrib(self.countryDescription), ))
    def exportChildren(self, outfile, level, namespace_='fsdexport:', name_='IdentificationType', fromsubclass_=False, pretty_print=True):
        super(IdentificationType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('diplomatic', node)
        if value is not None and 'diplomatic' not in already_processed:
            already_processed.add('diplomatic')
            self.diplomatic = value
        value = find_attr_value_('knownExpired', node)
        if value is not None and 'knownExpired' not in already_processed:
            already_processed.add('knownExpired')
            self.knownExpired = value
        value = find_attr_value_('knownFalse', node)
        if value is not None and 'knownFalse' not in already_processed:
            already_processed.add('knownFalse')
            self.knownFalse = value
        value = find_attr_value_('reportedLost', node)
        if value is not None and 'reportedLost' not in already_processed:
            already_processed.add('reportedLost')
            self.reportedLost = value
        value = find_attr_value_('revokedByIssuer', node)
        if value is not None and 'revokedByIssuer' not in already_processed:
            already_processed.add('revokedByIssuer')
            self.revokedByIssuer = value
        value = find_attr_value_('issueDate', node)
        if value is not None and 'issueDate' not in already_processed:
            already_processed.add('issueDate')
            self.issueDate = value
        value = find_attr_value_('issuedBy', node)
        if value is not None and 'issuedBy' not in already_processed:
            already_processed.add('issuedBy')
            self.issuedBy = value
        value = find_attr_value_('latinNumber', node)
        if value is not None and 'latinNumber' not in already_processed:
            already_processed.add('latinNumber')
            self.latinNumber = value
        value = find_attr_value_('nameOnDocument', node)
        if value is not None and 'nameOnDocument' not in already_processed:
            already_processed.add('nameOnDocument')
            self.nameOnDocument = value
        value = find_attr_value_('number', node)
        if value is not None and 'number' not in already_processed:
            already_processed.add('number')
            self.number = value
        value = find_attr_value_('validFrom', node)
        if value is not None and 'validFrom' not in already_processed:
            already_processed.add('validFrom')
            self.validFrom = value
        value = find_attr_value_('validTo', node)
        if value is not None and 'validTo' not in already_processed:
            already_processed.add('validTo')
            self.validTo = value
        value = find_attr_value_('region', node)
        if value is not None and 'region' not in already_processed:
            already_processed.add('region')
            self.region = value
        value = find_attr_value_('identificationTypeCode', node)
        if value is not None and 'identificationTypeCode' not in already_processed:
            already_processed.add('identificationTypeCode')
            self.identificationTypeCode = value
        value = find_attr_value_('identificationTypeDescription', node)
        if value is not None and 'identificationTypeDescription' not in already_processed:
            already_processed.add('identificationTypeDescription')
            self.identificationTypeDescription = value
        value = find_attr_value_('countryIso2Code', node)
        if value is not None and 'countryIso2Code' not in already_processed:
            already_processed.add('countryIso2Code')
            self.countryIso2Code = value
        value = find_attr_value_('countryDescription', node)
        if value is not None and 'countryDescription' not in already_processed:
            already_processed.add('countryDescription')
            self.countryDescription = value
        super(IdentificationType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(IdentificationType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class IdentificationType


class AdditionalInfoType(GeneratedsSuper):
    """The additional info are a placeholder that will be used in case some
    information has to be added into the XML but we don't want to
    update the XSD to avoid to break the compatibility for the
    consumers."""
    subclass = None
    superclass = None
    def __init__(self, key=None, value=None):
        self.original_tagname_ = None
        self.key = _cast(None, key)
        self.value = _cast(None, value)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AdditionalInfoType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AdditionalInfoType.subclass:
            return AdditionalInfoType.subclass(*args_, **kwargs_)
        else:
            return AdditionalInfoType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_key(self): return self.key
    def set_key(self, key): self.key = key
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='fsdexport:', name_='AdditionalInfoType', namespacedef_='xmlns:fsdexport="http://eu.europa.ec/fpi/fsd/export"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('AdditionalInfoType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AdditionalInfoType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='fsdexport:', name_='AdditionalInfoType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='fsdexport:', name_='AdditionalInfoType'):
        if self.key is not None and 'key' not in already_processed:
            already_processed.add('key')
            outfile.write(' key=%s' % (quote_attrib(self.key), ))
        if self.value is not None and 'value' not in already_processed:
            already_processed.add('value')
            outfile.write(' value=%s' % (quote_attrib(self.value), ))
    def exportChildren(self, outfile, level, namespace_='fsdexport:', name_='AdditionalInfoType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('key', node)
        if value is not None and 'key' not in already_processed:
            already_processed.add('key')
            self.key = value
        value = find_attr_value_('value', node)
        if value is not None and 'value' not in already_processed:
            already_processed.add('value')
            self.value = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class AdditionalInfoType


class ContactInfoType(GeneratedsSuper):
    """The contact info is a type that can be used to provide any
    supplementary contact information as, for example, email, phone
    number, fax, website etc... The key contains the kind of contact
    infomation. More than one contact info with the same key can be
    present for the same instance of AddressType."""
    subclass = None
    superclass = None
    def __init__(self, key=None, value=None):
        self.original_tagname_ = None
        self.key = _cast(None, key)
        self.value = _cast(None, value)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ContactInfoType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ContactInfoType.subclass:
            return ContactInfoType.subclass(*args_, **kwargs_)
        else:
            return ContactInfoType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_key(self): return self.key
    def set_key(self, key): self.key = key
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='fsdexport:', name_='ContactInfoType', namespacedef_='xmlns:fsdexport="http://eu.europa.ec/fpi/fsd/export"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ContactInfoType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ContactInfoType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='fsdexport:', name_='ContactInfoType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='fsdexport:', name_='ContactInfoType'):
        if self.key is not None and 'key' not in already_processed:
            already_processed.add('key')
            outfile.write(' key=%s' % (quote_attrib(self.key), ))
        if self.value is not None and 'value' not in already_processed:
            already_processed.add('value')
            outfile.write(' value=%s' % (quote_attrib(self.value), ))
    def exportChildren(self, outfile, level, namespace_='fsdexport:', name_='ContactInfoType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('key', node)
        if value is not None and 'key' not in already_processed:
            already_processed.add('key')
            self.key = value
        value = find_attr_value_('value', node)
        if value is not None and 'value' not in already_processed:
            already_processed.add('value')
            self.value = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ContactInfoType


GDSClassesMapping = {
    'export': ExportType,
}


USAGE_TEXT = """
Usage: python <Parser>.py [ -s ] <in_xml_file>
"""


def usage():
    print(USAGE_TEXT)
    sys.exit(1)


def get_root_tag(node):
    tag = Tag_pattern_.match(node.tag).groups()[-1]
    rootClass = GDSClassesMapping.get(tag)
    if rootClass is None:
        rootClass = globals().get(tag)
    return tag, rootClass


def parse(inFileName, silence=False):
    parser = None
    doc = parsexml_(inFileName, parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'ExportType'
        rootClass = ExportType
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    if not silence:
        sys.stdout.write('<?xml version="1.0" ?>\n')
        rootObj.export(
            sys.stdout, 0, name_=rootTag,
            namespacedef_='xmlns:fsdexport="http://eu.europa.ec/fpi/fsd/export"',
            pretty_print=True)
    return rootObj


def parseEtree(inFileName, silence=False):
    parser = None
    doc = parsexml_(inFileName, parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'ExportType'
        rootClass = ExportType
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    mapping = {}
    rootElement = rootObj.to_etree(None, name_=rootTag, mapping_=mapping)
    reverse_mapping = rootObj.gds_reverse_node_mapping(mapping)
    if not silence:
        content = etree_.tostring(
            rootElement, pretty_print=True,
            xml_declaration=True, encoding="utf-8")
        sys.stdout.write(content)
        sys.stdout.write('\n')
    return rootObj, rootElement, mapping, reverse_mapping


def parseString(inString, silence=False):
    '''Parse a string, create the object tree, and export it.

    Arguments:
    - inString -- A string.  This XML fragment should not start
      with an XML declaration containing an encoding.
    - silence -- A boolean.  If False, export the object.
    Returns -- The root object in the tree.
    '''
    parser = None
    rootNode= parsexmlstring_(inString, parser)
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'ExportType'
        rootClass = ExportType
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    if not silence:
        sys.stdout.write('<?xml version="1.0" ?>\n')
        rootObj.export(
            sys.stdout, 0, name_=rootTag,
            namespacedef_='xmlns:fsdexport="http://eu.europa.ec/fpi/fsd/export"')
    return rootObj


def parseLiteral(inFileName, silence=False):
    parser = None
    doc = parsexml_(inFileName, parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'ExportType'
        rootClass = ExportType
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    if not silence:
        sys.stdout.write('#from eu_global import *\n\n')
        sys.stdout.write('import eu_global as model_\n\n')
        sys.stdout.write('rootObj = model_.rootClass(\n')
        rootObj.exportLiteral(sys.stdout, 0, name_=rootTag)
        sys.stdout.write(')\n')
    return rootObj


def main():
    args = sys.argv[1:]
    if len(args) == 1:
        parse(args[0])
    else:
        usage()


if __name__ == '__main__':
    #import pdb; pdb.set_trace()
    main()


__all__ = [
    "AdditionalInfoType",
    "AddressType",
    "BirthdateType",
    "CitizenshipType",
    "ContactInfoType",
    "ExportType",
    "IdentificationType",
    "NameAliasType",
    "OperableType",
    "RegulationSummaryType",
    "RegulationType",
    "SanctionEntityType",
    "SanctionableType",
    "SubjectTypeType"
]
