#!/usr/bin/env python
# -*- coding: utf-8 -*-

#
# Generated Fri Jun  8 13:08:16 2018 by generateDS.py version 2.29.14.
# Python 3.6.4 (default, Mar  1 2018, 18:36:42)  [GCC 4.2.1 Compatible Apple LLVM 9.0.0 (clang-900.0.39.2)]
#
# Command line options:
#   ('-o', 'un_global.py')
#   ('-s', 'un_global_subs.py')
#
# Command line arguments:
#   sc-sanctions.xsd
#
# Command line:
#   ../generateDS.py -o "un_global.py" -s "un_global_subs.py" sc-sanctions.xsd
#
# Current working directory (os.getcwd()):
#   un_global
#

import sys
import re as re_
import base64
import datetime as datetime_
import warnings as warnings_
try:
    from lxml import etree as etree_
except ImportError:
    from xml.etree import ElementTree as etree_


Validate_simpletypes_ = True
if sys.version_info.major == 2:
    BaseStrType_ = basestring
else:
    BaseStrType_ = str


def parsexml_(infile, parser=None, **kwargs):
    if parser is None:
        # Use the lxml ElementTree compatible parser so that, e.g.,
        #   we ignore comments.
        try:
            parser = etree_.ETCompatXMLParser()
        except AttributeError:
            # fallback to xml.etree
            parser = etree_.XMLParser()
    doc = etree_.parse(infile, parser=parser, **kwargs)
    return doc

def parsexmlstring_(instring, parser=None, **kwargs):
    if parser is None:
        # Use the lxml ElementTree compatible parser so that, e.g.,
        #   we ignore comments.
        try:
            parser = etree_.ETCompatXMLParser()
        except AttributeError:
            # fallback to xml.etree
            parser = etree_.XMLParser()
    element = etree_.fromstring(instring, parser=parser, **kwargs)
    return element

#
# Namespace prefix definition table (and other attributes, too)
#
# The module generatedsnamespaces, if it is importable, must contain
# a dictionary named GeneratedsNamespaceDefs.  This Python dictionary
# should map element type names (strings) to XML schema namespace prefix
# definitions.  The export method for any class for which there is
# a namespace prefix definition, will export that definition in the
# XML representation of that element.  See the export method of
# any generated element type class for a example of the use of this
# table.
# A sample table is:
#
#     # File: generatedsnamespaces.py
#
#     GenerateDSNamespaceDefs = {
#         "ElementtypeA": "http://www.xxx.com/namespaceA",
#         "ElementtypeB": "http://www.xxx.com/namespaceB",
#     }
#

try:
    from generatedsnamespaces import GenerateDSNamespaceDefs as GenerateDSNamespaceDefs_
except ImportError:
    GenerateDSNamespaceDefs_ = {}

#
# The root super-class for element type classes
#
# Calls to the methods in these classes are generated by generateDS.py.
# You can replace these methods by re-implementing the following class
#   in a module named generatedssuper.py.

try:
    from generatedssuper import GeneratedsSuper
except ImportError as exp:
    
    class GeneratedsSuper(object):
        tzoff_pattern = re_.compile(r'(\+|-)((0\d|1[0-3]):[0-5]\d|14:00)$')
        class _FixedOffsetTZ(datetime_.tzinfo):
            def __init__(self, offset, name):
                self.__offset = datetime_.timedelta(minutes=offset)
                self.__name = name
            def utcoffset(self, dt):
                return self.__offset
            def tzname(self, dt):
                return self.__name
            def dst(self, dt):
                return None
        def gds_format_string(self, input_data, input_name=''):
            return input_data
        def gds_validate_string(self, input_data, node=None, input_name=''):
            if not input_data:
                return ''
            else:
                return input_data
        def gds_format_base64(self, input_data, input_name=''):
            return base64.b64encode(input_data)
        def gds_validate_base64(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_integer(self, input_data, input_name=''):
            return '%d' % input_data
        def gds_validate_integer(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_integer_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_integer_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    int(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of integers')
            return values
        def gds_format_float(self, input_data, input_name=''):
            return ('%.15f' % input_data).rstrip('0')
        def gds_validate_float(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_float_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_float_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of floats')
            return values
        def gds_format_double(self, input_data, input_name=''):
            return '%e' % input_data
        def gds_validate_double(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_double_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_double_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of doubles')
            return values
        def gds_format_boolean(self, input_data, input_name=''):
            return ('%s' % input_data).lower()
        def gds_validate_boolean(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_boolean_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_boolean_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                if value not in ('true', '1', 'false', '0', ):
                    raise_parse_error(
                        node,
                        'Requires sequence of booleans '
                        '("true", "1", "false", "0")')
            return values
        def gds_validate_datetime(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_datetime(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d.%s' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        @classmethod
        def gds_parse_datetime(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            time_parts = input_data.split('.')
            if len(time_parts) > 1:
                micro_seconds = int(float('0.' + time_parts[1]) * 1000000)
                input_data = '%s.%s' % (time_parts[0], micro_seconds, )
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt
        def gds_validate_date(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_date(self, input_data, input_name=''):
            _svalue = '%04d-%02d-%02d' % (
                input_data.year,
                input_data.month,
                input_data.day,
            )
            try:
                if input_data.tzinfo is not None:
                    tzoff = input_data.tzinfo.utcoffset(input_data)
                    if tzoff is not None:
                        total_seconds = tzoff.seconds + (86400 * tzoff.days)
                        if total_seconds == 0:
                            _svalue += 'Z'
                        else:
                            if total_seconds < 0:
                                _svalue += '-'
                                total_seconds *= -1
                            else:
                                _svalue += '+'
                            hours = total_seconds // 3600
                            minutes = (total_seconds - (hours * 3600)) // 60
                            _svalue += '{0:02d}:{1:02d}'.format(
                                hours, minutes)
            except AttributeError:
                pass
            return _svalue
        @classmethod
        def gds_parse_date(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            dt = datetime_.datetime.strptime(input_data, '%Y-%m-%d')
            dt = dt.replace(tzinfo=tz)
            return dt.date()
        def gds_validate_time(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_time(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%02d:%02d:%02d' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%02d:%02d:%02d.%s' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        def gds_validate_simple_patterns(self, patterns, target):
            # pat is a list of lists of strings/patterns.  We should:
            # - AND the outer elements
            # - OR the inner elements
            found1 = True
            for patterns1 in patterns:
                found2 = False
                for patterns2 in patterns1:
                    if re_.search(patterns2, target) is not None:
                        found2 = True
                        break
                if not found2:
                    found1 = False
                    break
            return found1
        @classmethod
        def gds_parse_time(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            if len(input_data.split('.')) > 1:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt.time()
        def gds_str_lower(self, instring):
            return instring.lower()
        def get_path_(self, node):
            path_list = []
            self.get_path_list_(node, path_list)
            path_list.reverse()
            path = '/'.join(path_list)
            return path
        Tag_strip_pattern_ = re_.compile(r'\{.*\}')
        def get_path_list_(self, node, path_list):
            if node is None:
                return
            tag = GeneratedsSuper.Tag_strip_pattern_.sub('', node.tag)
            if tag:
                path_list.append(tag)
            self.get_path_list_(node.getparent(), path_list)
        def get_class_obj_(self, node, default_class=None):
            class_obj1 = default_class
            if 'xsi' in node.nsmap:
                classname = node.get('{%s}type' % node.nsmap['xsi'])
                if classname is not None:
                    names = classname.split(':')
                    if len(names) == 2:
                        classname = names[1]
                    class_obj2 = globals().get(classname)
                    if class_obj2 is not None:
                        class_obj1 = class_obj2
            return class_obj1
        def gds_build_any(self, node, type_name=None):
            return None
        @classmethod
        def gds_reverse_node_mapping(cls, mapping):
            return dict(((v, k) for k, v in mapping.iteritems()))
        @staticmethod
        def gds_encode(instring):
            if sys.version_info.major == 2:
                return instring.encode(ExternalEncoding)
            else:
                return instring
        @staticmethod
        def convert_unicode(instring):
            if isinstance(instring, str):
                result = quote_xml(instring)
            elif sys.version_info.major == 2 and isinstance(instring, unicode):
                result = quote_xml(instring).encode('utf8')
            else:
                result = GeneratedsSuper.gds_encode(str(instring))
            return result
        def __eq__(self, other):
            if type(self) != type(other):
                return False
            return self.__dict__ == other.__dict__
        def __ne__(self, other):
            return not self.__eq__(other)
    
    def getSubclassFromModule_(module, class_):
        '''Get the subclass of a class from a specific module.'''
        name = class_.__name__ + 'Sub'
        if hasattr(module, name):
            return getattr(module, name)
        else:
            return None


#
# If you have installed IPython you can uncomment and use the following.
# IPython is available from http://ipython.scipy.org/.
#

## from IPython.Shell import IPShellEmbed
## args = ''
## ipshell = IPShellEmbed(args,
##     banner = 'Dropping into IPython',
##     exit_msg = 'Leaving Interpreter, back to program.')

# Then use the following line where and when you want to drop into the
# IPython shell:
#    ipshell('<some message> -- Entering ipshell.\nHit Ctrl-D to exit')

#
# Globals
#

ExternalEncoding = 'utf-8'
Tag_pattern_ = re_.compile(r'({.*})?(.*)')
String_cleanup_pat_ = re_.compile(r"[\n\r\s]+")
Namespace_extract_pat_ = re_.compile(r'{(.*)}(.*)')
CDATA_pattern_ = re_.compile(r"<!\[CDATA\[.*?\]\]>", re_.DOTALL)

# Change this to redirect the generated superclass module to use a
# specific subclass module.
CurrentSubclassModule_ = None

#
# Support/utility functions.
#


def showIndent(outfile, level, pretty_print=True):
    if pretty_print:
        for idx in range(level):
            outfile.write('    ')


def quote_xml(inStr):
    "Escape markup chars, but do not modify CDATA sections."
    if not inStr:
        return ''
    s1 = (isinstance(inStr, BaseStrType_) and inStr or '%s' % inStr)
    s2 = ''
    pos = 0
    matchobjects = CDATA_pattern_.finditer(s1)
    for mo in matchobjects:
        s3 = s1[pos:mo.start()]
        s2 += quote_xml_aux(s3)
        s2 += s1[mo.start():mo.end()]
        pos = mo.end()
    s3 = s1[pos:]
    s2 += quote_xml_aux(s3)
    return s2


def quote_xml_aux(inStr):
    s1 = inStr.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    return s1


def quote_attrib(inStr):
    s1 = (isinstance(inStr, BaseStrType_) and inStr or '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    if '"' in s1:
        if "'" in s1:
            s1 = '"%s"' % s1.replace('"', "&quot;")
        else:
            s1 = "'%s'" % s1
    else:
        s1 = '"%s"' % s1
    return s1


def quote_python(inStr):
    s1 = inStr
    if s1.find("'") == -1:
        if s1.find('\n') == -1:
            return "'%s'" % s1
        else:
            return "'''%s'''" % s1
    else:
        if s1.find('"') != -1:
            s1 = s1.replace('"', '\\"')
        if s1.find('\n') == -1:
            return '"%s"' % s1
        else:
            return '"""%s"""' % s1


def get_all_text_(node):
    if node.text is not None:
        text = node.text
    else:
        text = ''
    for child in node:
        if child.tail is not None:
            text += child.tail
    return text


def find_attr_value_(attr_name, node):
    attrs = node.attrib
    attr_parts = attr_name.split(':')
    value = None
    if len(attr_parts) == 1:
        value = attrs.get(attr_name)
    elif len(attr_parts) == 2:
        prefix, name = attr_parts
        namespace = node.nsmap.get(prefix)
        if namespace is not None:
            value = attrs.get('{%s}%s' % (namespace, name, ))
    return value


class GDSParseError(Exception):
    pass


def raise_parse_error(node, msg):
    msg = '%s (element %s/line %d)' % (msg, node.tag, node.sourceline, )
    raise GDSParseError(msg)


class MixedContainer:
    # Constants for category:
    CategoryNone = 0
    CategoryText = 1
    CategorySimple = 2
    CategoryComplex = 3
    # Constants for content_type:
    TypeNone = 0
    TypeText = 1
    TypeString = 2
    TypeInteger = 3
    TypeFloat = 4
    TypeDecimal = 5
    TypeDouble = 6
    TypeBoolean = 7
    TypeBase64 = 8
    def __init__(self, category, content_type, name, value):
        self.category = category
        self.content_type = content_type
        self.name = name
        self.value = value
    def getCategory(self):
        return self.category
    def getContenttype(self, content_type):
        return self.content_type
    def getValue(self):
        return self.value
    def getName(self):
        return self.name
    def export(self, outfile, level, name, namespace,
               pretty_print=True):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                outfile.write(self.value)
        elif self.category == MixedContainer.CategorySimple:
            self.exportSimple(outfile, level, name)
        else:    # category == MixedContainer.CategoryComplex
            self.value.export(
                outfile, level, namespace, name,
                pretty_print=pretty_print)
    def exportSimple(self, outfile, level, name):
        if self.content_type == MixedContainer.TypeString:
            outfile.write('<%s>%s</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeInteger or \
                self.content_type == MixedContainer.TypeBoolean:
            outfile.write('<%s>%d</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeFloat or \
                self.content_type == MixedContainer.TypeDecimal:
            outfile.write('<%s>%f</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeDouble:
            outfile.write('<%s>%g</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeBase64:
            outfile.write('<%s>%s</%s>' % (
                self.name,
                base64.b64encode(self.value),
                self.name))
    def to_etree(self, element):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                if len(element) > 0:
                    if element[-1].tail is None:
                        element[-1].tail = self.value
                    else:
                        element[-1].tail += self.value
                else:
                    if element.text is None:
                        element.text = self.value
                    else:
                        element.text += self.value
        elif self.category == MixedContainer.CategorySimple:
            subelement = etree_.SubElement(
                element, '%s' % self.name)
            subelement.text = self.to_etree_simple()
        else:    # category == MixedContainer.CategoryComplex
            self.value.to_etree(element)
    def to_etree_simple(self):
        if self.content_type == MixedContainer.TypeString:
            text = self.value
        elif (self.content_type == MixedContainer.TypeInteger or
                self.content_type == MixedContainer.TypeBoolean):
            text = '%d' % self.value
        elif (self.content_type == MixedContainer.TypeFloat or
                self.content_type == MixedContainer.TypeDecimal):
            text = '%f' % self.value
        elif self.content_type == MixedContainer.TypeDouble:
            text = '%g' % self.value
        elif self.content_type == MixedContainer.TypeBase64:
            text = '%s' % base64.b64encode(self.value)
        return text
    def exportLiteral(self, outfile, level, name):
        if self.category == MixedContainer.CategoryText:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type,
                    self.name, self.value))
        elif self.category == MixedContainer.CategorySimple:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type,
                    self.name, self.value))
        else:    # category == MixedContainer.CategoryComplex
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s",\n' % (
                    self.category, self.content_type, self.name,))
            self.value.exportLiteral(outfile, level + 1)
            showIndent(outfile, level)
            outfile.write(')\n')


class MemberSpec_(object):
    def __init__(self, name='', data_type='', container=0,
            optional=0, child_attrs=None, choice=None):
        self.name = name
        self.data_type = data_type
        self.container = container
        self.child_attrs = child_attrs
        self.choice = choice
        self.optional = optional
    def set_name(self, name): self.name = name
    def get_name(self): return self.name
    def set_data_type(self, data_type): self.data_type = data_type
    def get_data_type_chain(self): return self.data_type
    def get_data_type(self):
        if isinstance(self.data_type, list):
            if len(self.data_type) > 0:
                return self.data_type[-1]
            else:
                return 'xs:string'
        else:
            return self.data_type
    def set_container(self, container): self.container = container
    def get_container(self): return self.container
    def set_child_attrs(self, child_attrs): self.child_attrs = child_attrs
    def get_child_attrs(self): return self.child_attrs
    def set_choice(self, choice): self.choice = choice
    def get_choice(self): return self.choice
    def set_optional(self, optional): self.optional = optional
    def get_optional(self): return self.optional


def _cast(typ, value):
    if typ is None or value is None:
        return value
    return typ(value)

#
# Data representation classes.
#


class CONSOLIDATED_LIST(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, dateGenerated=None, INDIVIDUALS=None, ENTITIES=None):
        self.original_tagname_ = None
        if isinstance(dateGenerated, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(dateGenerated, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = dateGenerated
        self.dateGenerated = initvalue_
        self.INDIVIDUALS = INDIVIDUALS
        self.ENTITIES = ENTITIES
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CONSOLIDATED_LIST)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CONSOLIDATED_LIST.subclass:
            return CONSOLIDATED_LIST.subclass(*args_, **kwargs_)
        else:
            return CONSOLIDATED_LIST(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_INDIVIDUALS(self): return self.INDIVIDUALS
    def set_INDIVIDUALS(self, INDIVIDUALS): self.INDIVIDUALS = INDIVIDUALS
    def get_ENTITIES(self): return self.ENTITIES
    def set_ENTITIES(self, ENTITIES): self.ENTITIES = ENTITIES
    def get_dateGenerated(self): return self.dateGenerated
    def set_dateGenerated(self, dateGenerated): self.dateGenerated = dateGenerated
    def hasContent_(self):
        if (
            self.INDIVIDUALS is not None or
            self.ENTITIES is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CONSOLIDATED_LIST', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CONSOLIDATED_LIST')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CONSOLIDATED_LIST')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CONSOLIDATED_LIST', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CONSOLIDATED_LIST'):
        if self.dateGenerated is not None and 'dateGenerated' not in already_processed:
            already_processed.add('dateGenerated')
            outfile.write(' dateGenerated="%s"' % self.gds_format_datetime(self.dateGenerated, input_name='dateGenerated'))
    def exportChildren(self, outfile, level, namespace_='', name_='CONSOLIDATED_LIST', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.INDIVIDUALS is not None:
            self.INDIVIDUALS.export(outfile, level, namespace_, name_='INDIVIDUALS', pretty_print=pretty_print)
        if self.ENTITIES is not None:
            self.ENTITIES.export(outfile, level, namespace_, name_='ENTITIES', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('dateGenerated', node)
        if value is not None and 'dateGenerated' not in already_processed:
            already_processed.add('dateGenerated')
            try:
                self.dateGenerated = self.gds_parse_datetime(value)
            except ValueError as exp:
                raise ValueError('Bad date-time attribute (dateGenerated): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'INDIVIDUALS':
            obj_ = INDIVIDUALS.factory()
            obj_.build(child_)
            self.INDIVIDUALS = obj_
            obj_.original_tagname_ = 'INDIVIDUALS'
        elif nodeName_ == 'ENTITIES':
            obj_ = ENTITIES.factory()
            obj_.build(child_)
            self.ENTITIES = obj_
            obj_.original_tagname_ = 'ENTITIES'
# end class CONSOLIDATED_LIST


class INDIVIDUALS(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, INDIVIDUAL=None):
        self.original_tagname_ = None
        if INDIVIDUAL is None:
            self.INDIVIDUAL = []
        else:
            self.INDIVIDUAL = INDIVIDUAL
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, INDIVIDUALS)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if INDIVIDUALS.subclass:
            return INDIVIDUALS.subclass(*args_, **kwargs_)
        else:
            return INDIVIDUALS(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_INDIVIDUAL(self): return self.INDIVIDUAL
    def set_INDIVIDUAL(self, INDIVIDUAL): self.INDIVIDUAL = INDIVIDUAL
    def add_INDIVIDUAL(self, value): self.INDIVIDUAL.append(value)
    def insert_INDIVIDUAL_at(self, index, value): self.INDIVIDUAL.insert(index, value)
    def replace_INDIVIDUAL_at(self, index, value): self.INDIVIDUAL[index] = value
    def hasContent_(self):
        if (
            self.INDIVIDUAL
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='INDIVIDUALS', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('INDIVIDUALS')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='INDIVIDUALS')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='INDIVIDUALS', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='INDIVIDUALS'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='INDIVIDUALS', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for INDIVIDUAL_ in self.INDIVIDUAL:
            INDIVIDUAL_.export(outfile, level, namespace_, name_='INDIVIDUAL', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'INDIVIDUAL':
            obj_ = INDIVIDUAL.factory()
            obj_.build(child_)
            self.INDIVIDUAL.append(obj_)
            obj_.original_tagname_ = 'INDIVIDUAL'
# end class INDIVIDUALS


class INDIVIDUAL(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, DATAID=None, VERSIONNUM=None, FIRST_NAME=None, SECOND_NAME=None, THIRD_NAME=None, FOURTH_NAME=None, UN_LIST_TYPE=None, REFERENCE_NUMBER=None, LISTED_ON=None, GENDER=None, SUBMITTED_BY=None, NAME_ORIGINAL_SCRIPT=None, COMMENTS1=None, NATIONALITY2=None, TITLE=None, DESIGNATION=None, NATIONALITY=None, LIST_TYPE=None, LAST_DAY_UPDATED=None, INDIVIDUAL_ALIAS=None, INDIVIDUAL_ADDRESS=None, INDIVIDUAL_DATE_OF_BIRTH=None, INDIVIDUAL_PLACE_OF_BIRTH=None, INDIVIDUAL_DOCUMENT=None, SORT_KEY=None, SORT_KEY_LAST_MOD=None, DELISTED_ON=None):
        self.original_tagname_ = None
        self.DATAID = DATAID
        self.VERSIONNUM = VERSIONNUM
        self.FIRST_NAME = FIRST_NAME
        self.SECOND_NAME = SECOND_NAME
        self.THIRD_NAME = THIRD_NAME
        self.FOURTH_NAME = FOURTH_NAME
        self.UN_LIST_TYPE = UN_LIST_TYPE
        self.REFERENCE_NUMBER = REFERENCE_NUMBER
        if isinstance(LISTED_ON, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(LISTED_ON, '%Y-%m-%d').date()
        else:
            initvalue_ = LISTED_ON
        self.LISTED_ON = initvalue_
        self.GENDER = GENDER
        self.SUBMITTED_BY = SUBMITTED_BY
        self.NAME_ORIGINAL_SCRIPT = NAME_ORIGINAL_SCRIPT
        self.COMMENTS1 = COMMENTS1
        self.NATIONALITY2 = NATIONALITY2
        self.TITLE = TITLE
        self.DESIGNATION = DESIGNATION
        self.NATIONALITY = NATIONALITY
        self.LIST_TYPE = LIST_TYPE
        self.LAST_DAY_UPDATED = LAST_DAY_UPDATED
        if INDIVIDUAL_ALIAS is None:
            self.INDIVIDUAL_ALIAS = []
        else:
            self.INDIVIDUAL_ALIAS = INDIVIDUAL_ALIAS
        if INDIVIDUAL_ADDRESS is None:
            self.INDIVIDUAL_ADDRESS = []
        else:
            self.INDIVIDUAL_ADDRESS = INDIVIDUAL_ADDRESS
        if INDIVIDUAL_DATE_OF_BIRTH is None:
            self.INDIVIDUAL_DATE_OF_BIRTH = []
        else:
            self.INDIVIDUAL_DATE_OF_BIRTH = INDIVIDUAL_DATE_OF_BIRTH
        if INDIVIDUAL_PLACE_OF_BIRTH is None:
            self.INDIVIDUAL_PLACE_OF_BIRTH = []
        else:
            self.INDIVIDUAL_PLACE_OF_BIRTH = INDIVIDUAL_PLACE_OF_BIRTH
        if INDIVIDUAL_DOCUMENT is None:
            self.INDIVIDUAL_DOCUMENT = []
        else:
            self.INDIVIDUAL_DOCUMENT = INDIVIDUAL_DOCUMENT
        self.SORT_KEY = SORT_KEY
        self.SORT_KEY_LAST_MOD = SORT_KEY_LAST_MOD
        if isinstance(DELISTED_ON, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(DELISTED_ON, '%Y-%m-%d').date()
        else:
            initvalue_ = DELISTED_ON
        self.DELISTED_ON = initvalue_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, INDIVIDUAL)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if INDIVIDUAL.subclass:
            return INDIVIDUAL.subclass(*args_, **kwargs_)
        else:
            return INDIVIDUAL(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_DATAID(self): return self.DATAID
    def set_DATAID(self, DATAID): self.DATAID = DATAID
    def get_VERSIONNUM(self): return self.VERSIONNUM
    def set_VERSIONNUM(self, VERSIONNUM): self.VERSIONNUM = VERSIONNUM
    def get_FIRST_NAME(self): return self.FIRST_NAME
    def set_FIRST_NAME(self, FIRST_NAME): self.FIRST_NAME = FIRST_NAME
    def get_SECOND_NAME(self): return self.SECOND_NAME
    def set_SECOND_NAME(self, SECOND_NAME): self.SECOND_NAME = SECOND_NAME
    def get_THIRD_NAME(self): return self.THIRD_NAME
    def set_THIRD_NAME(self, THIRD_NAME): self.THIRD_NAME = THIRD_NAME
    def get_FOURTH_NAME(self): return self.FOURTH_NAME
    def set_FOURTH_NAME(self, FOURTH_NAME): self.FOURTH_NAME = FOURTH_NAME
    def get_UN_LIST_TYPE(self): return self.UN_LIST_TYPE
    def set_UN_LIST_TYPE(self, UN_LIST_TYPE): self.UN_LIST_TYPE = UN_LIST_TYPE
    def get_REFERENCE_NUMBER(self): return self.REFERENCE_NUMBER
    def set_REFERENCE_NUMBER(self, REFERENCE_NUMBER): self.REFERENCE_NUMBER = REFERENCE_NUMBER
    def get_LISTED_ON(self): return self.LISTED_ON
    def set_LISTED_ON(self, LISTED_ON): self.LISTED_ON = LISTED_ON
    def get_GENDER(self): return self.GENDER
    def set_GENDER(self, GENDER): self.GENDER = GENDER
    def get_SUBMITTED_BY(self): return self.SUBMITTED_BY
    def set_SUBMITTED_BY(self, SUBMITTED_BY): self.SUBMITTED_BY = SUBMITTED_BY
    def get_NAME_ORIGINAL_SCRIPT(self): return self.NAME_ORIGINAL_SCRIPT
    def set_NAME_ORIGINAL_SCRIPT(self, NAME_ORIGINAL_SCRIPT): self.NAME_ORIGINAL_SCRIPT = NAME_ORIGINAL_SCRIPT
    def get_COMMENTS1(self): return self.COMMENTS1
    def set_COMMENTS1(self, COMMENTS1): self.COMMENTS1 = COMMENTS1
    def get_NATIONALITY2(self): return self.NATIONALITY2
    def set_NATIONALITY2(self, NATIONALITY2): self.NATIONALITY2 = NATIONALITY2
    def get_TITLE(self): return self.TITLE
    def set_TITLE(self, TITLE): self.TITLE = TITLE
    def get_DESIGNATION(self): return self.DESIGNATION
    def set_DESIGNATION(self, DESIGNATION): self.DESIGNATION = DESIGNATION
    def get_NATIONALITY(self): return self.NATIONALITY
    def set_NATIONALITY(self, NATIONALITY): self.NATIONALITY = NATIONALITY
    def get_LIST_TYPE(self): return self.LIST_TYPE
    def set_LIST_TYPE(self, LIST_TYPE): self.LIST_TYPE = LIST_TYPE
    def get_LAST_DAY_UPDATED(self): return self.LAST_DAY_UPDATED
    def set_LAST_DAY_UPDATED(self, LAST_DAY_UPDATED): self.LAST_DAY_UPDATED = LAST_DAY_UPDATED
    def get_INDIVIDUAL_ALIAS(self): return self.INDIVIDUAL_ALIAS
    def set_INDIVIDUAL_ALIAS(self, INDIVIDUAL_ALIAS): self.INDIVIDUAL_ALIAS = INDIVIDUAL_ALIAS
    def add_INDIVIDUAL_ALIAS(self, value): self.INDIVIDUAL_ALIAS.append(value)
    def insert_INDIVIDUAL_ALIAS_at(self, index, value): self.INDIVIDUAL_ALIAS.insert(index, value)
    def replace_INDIVIDUAL_ALIAS_at(self, index, value): self.INDIVIDUAL_ALIAS[index] = value
    def get_INDIVIDUAL_ADDRESS(self): return self.INDIVIDUAL_ADDRESS
    def set_INDIVIDUAL_ADDRESS(self, INDIVIDUAL_ADDRESS): self.INDIVIDUAL_ADDRESS = INDIVIDUAL_ADDRESS
    def add_INDIVIDUAL_ADDRESS(self, value): self.INDIVIDUAL_ADDRESS.append(value)
    def insert_INDIVIDUAL_ADDRESS_at(self, index, value): self.INDIVIDUAL_ADDRESS.insert(index, value)
    def replace_INDIVIDUAL_ADDRESS_at(self, index, value): self.INDIVIDUAL_ADDRESS[index] = value
    def get_INDIVIDUAL_DATE_OF_BIRTH(self): return self.INDIVIDUAL_DATE_OF_BIRTH
    def set_INDIVIDUAL_DATE_OF_BIRTH(self, INDIVIDUAL_DATE_OF_BIRTH): self.INDIVIDUAL_DATE_OF_BIRTH = INDIVIDUAL_DATE_OF_BIRTH
    def add_INDIVIDUAL_DATE_OF_BIRTH(self, value): self.INDIVIDUAL_DATE_OF_BIRTH.append(value)
    def insert_INDIVIDUAL_DATE_OF_BIRTH_at(self, index, value): self.INDIVIDUAL_DATE_OF_BIRTH.insert(index, value)
    def replace_INDIVIDUAL_DATE_OF_BIRTH_at(self, index, value): self.INDIVIDUAL_DATE_OF_BIRTH[index] = value
    def get_INDIVIDUAL_PLACE_OF_BIRTH(self): return self.INDIVIDUAL_PLACE_OF_BIRTH
    def set_INDIVIDUAL_PLACE_OF_BIRTH(self, INDIVIDUAL_PLACE_OF_BIRTH): self.INDIVIDUAL_PLACE_OF_BIRTH = INDIVIDUAL_PLACE_OF_BIRTH
    def add_INDIVIDUAL_PLACE_OF_BIRTH(self, value): self.INDIVIDUAL_PLACE_OF_BIRTH.append(value)
    def insert_INDIVIDUAL_PLACE_OF_BIRTH_at(self, index, value): self.INDIVIDUAL_PLACE_OF_BIRTH.insert(index, value)
    def replace_INDIVIDUAL_PLACE_OF_BIRTH_at(self, index, value): self.INDIVIDUAL_PLACE_OF_BIRTH[index] = value
    def get_INDIVIDUAL_DOCUMENT(self): return self.INDIVIDUAL_DOCUMENT
    def set_INDIVIDUAL_DOCUMENT(self, INDIVIDUAL_DOCUMENT): self.INDIVIDUAL_DOCUMENT = INDIVIDUAL_DOCUMENT
    def add_INDIVIDUAL_DOCUMENT(self, value): self.INDIVIDUAL_DOCUMENT.append(value)
    def insert_INDIVIDUAL_DOCUMENT_at(self, index, value): self.INDIVIDUAL_DOCUMENT.insert(index, value)
    def replace_INDIVIDUAL_DOCUMENT_at(self, index, value): self.INDIVIDUAL_DOCUMENT[index] = value
    def get_SORT_KEY(self): return self.SORT_KEY
    def set_SORT_KEY(self, SORT_KEY): self.SORT_KEY = SORT_KEY
    def get_SORT_KEY_LAST_MOD(self): return self.SORT_KEY_LAST_MOD
    def set_SORT_KEY_LAST_MOD(self, SORT_KEY_LAST_MOD): self.SORT_KEY_LAST_MOD = SORT_KEY_LAST_MOD
    def get_DELISTED_ON(self): return self.DELISTED_ON
    def set_DELISTED_ON(self, DELISTED_ON): self.DELISTED_ON = DELISTED_ON
    def hasContent_(self):
        if (
            self.DATAID is not None or
            self.VERSIONNUM is not None or
            self.FIRST_NAME is not None or
            self.SECOND_NAME is not None or
            self.THIRD_NAME is not None or
            self.FOURTH_NAME is not None or
            self.UN_LIST_TYPE is not None or
            self.REFERENCE_NUMBER is not None or
            self.LISTED_ON is not None or
            self.GENDER is not None or
            self.SUBMITTED_BY is not None or
            self.NAME_ORIGINAL_SCRIPT is not None or
            self.COMMENTS1 is not None or
            self.NATIONALITY2 is not None or
            self.TITLE is not None or
            self.DESIGNATION is not None or
            self.NATIONALITY is not None or
            self.LIST_TYPE is not None or
            self.LAST_DAY_UPDATED is not None or
            self.INDIVIDUAL_ALIAS or
            self.INDIVIDUAL_ADDRESS or
            self.INDIVIDUAL_DATE_OF_BIRTH or
            self.INDIVIDUAL_PLACE_OF_BIRTH or
            self.INDIVIDUAL_DOCUMENT or
            self.SORT_KEY is not None or
            self.SORT_KEY_LAST_MOD is not None or
            self.DELISTED_ON is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='INDIVIDUAL', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('INDIVIDUAL')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='INDIVIDUAL')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='INDIVIDUAL', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='INDIVIDUAL'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='INDIVIDUAL', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.DATAID is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<DATAID>%s</DATAID>%s' % (self.gds_format_integer(self.DATAID, input_name='DATAID'), eol_))
        if self.VERSIONNUM is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<VERSIONNUM>%s</VERSIONNUM>%s' % (self.gds_format_integer(self.VERSIONNUM, input_name='VERSIONNUM'), eol_))
        if self.FIRST_NAME is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<FIRST_NAME>%s</FIRST_NAME>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.FIRST_NAME), input_name='FIRST_NAME')), eol_))
        if self.SECOND_NAME is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<SECOND_NAME>%s</SECOND_NAME>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.SECOND_NAME), input_name='SECOND_NAME')), eol_))
        if self.THIRD_NAME is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<THIRD_NAME>%s</THIRD_NAME>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.THIRD_NAME), input_name='THIRD_NAME')), eol_))
        if self.FOURTH_NAME is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<FOURTH_NAME>%s</FOURTH_NAME>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.FOURTH_NAME), input_name='FOURTH_NAME')), eol_))
        if self.UN_LIST_TYPE is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<UN_LIST_TYPE>%s</UN_LIST_TYPE>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.UN_LIST_TYPE), input_name='UN_LIST_TYPE')), eol_))
        if self.REFERENCE_NUMBER is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<REFERENCE_NUMBER>%s</REFERENCE_NUMBER>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.REFERENCE_NUMBER), input_name='REFERENCE_NUMBER')), eol_))
        if self.LISTED_ON is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<LISTED_ON>%s</LISTED_ON>%s' % (self.gds_format_date(self.LISTED_ON, input_name='LISTED_ON'), eol_))
        if self.GENDER is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<GENDER>%s</GENDER>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.GENDER), input_name='GENDER')), eol_))
        if self.SUBMITTED_BY is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<SUBMITTED_BY>%s</SUBMITTED_BY>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.SUBMITTED_BY), input_name='SUBMITTED_BY')), eol_))
        if self.NAME_ORIGINAL_SCRIPT is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<NAME_ORIGINAL_SCRIPT>%s</NAME_ORIGINAL_SCRIPT>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.NAME_ORIGINAL_SCRIPT), input_name='NAME_ORIGINAL_SCRIPT')), eol_))
        if self.COMMENTS1 is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<COMMENTS1>%s</COMMENTS1>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.COMMENTS1), input_name='COMMENTS1')), eol_))
        if self.NATIONALITY2 is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<NATIONALITY2>%s</NATIONALITY2>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.NATIONALITY2), input_name='NATIONALITY2')), eol_))
        if self.TITLE is not None:
            self.TITLE.export(outfile, level, namespace_, name_='TITLE', pretty_print=pretty_print)
        if self.DESIGNATION is not None:
            self.DESIGNATION.export(outfile, level, namespace_, name_='DESIGNATION', pretty_print=pretty_print)
        if self.NATIONALITY is not None:
            self.NATIONALITY.export(outfile, level, namespace_, name_='NATIONALITY', pretty_print=pretty_print)
        if self.LIST_TYPE is not None:
            self.LIST_TYPE.export(outfile, level, namespace_, name_='LIST_TYPE', pretty_print=pretty_print)
        if self.LAST_DAY_UPDATED is not None:
            self.LAST_DAY_UPDATED.export(outfile, level, namespace_, name_='LAST_DAY_UPDATED', pretty_print=pretty_print)
        for INDIVIDUAL_ALIAS_ in self.INDIVIDUAL_ALIAS:
            INDIVIDUAL_ALIAS_.export(outfile, level, namespace_, name_='INDIVIDUAL_ALIAS', pretty_print=pretty_print)
        for INDIVIDUAL_ADDRESS_ in self.INDIVIDUAL_ADDRESS:
            INDIVIDUAL_ADDRESS_.export(outfile, level, namespace_, name_='INDIVIDUAL_ADDRESS', pretty_print=pretty_print)
        for INDIVIDUAL_DATE_OF_BIRTH_ in self.INDIVIDUAL_DATE_OF_BIRTH:
            INDIVIDUAL_DATE_OF_BIRTH_.export(outfile, level, namespace_, name_='INDIVIDUAL_DATE_OF_BIRTH', pretty_print=pretty_print)
        for INDIVIDUAL_PLACE_OF_BIRTH_ in self.INDIVIDUAL_PLACE_OF_BIRTH:
            INDIVIDUAL_PLACE_OF_BIRTH_.export(outfile, level, namespace_, name_='INDIVIDUAL_PLACE_OF_BIRTH', pretty_print=pretty_print)
        for INDIVIDUAL_DOCUMENT_ in self.INDIVIDUAL_DOCUMENT:
            INDIVIDUAL_DOCUMENT_.export(outfile, level, namespace_, name_='INDIVIDUAL_DOCUMENT', pretty_print=pretty_print)
        if self.SORT_KEY is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<SORT_KEY>%s</SORT_KEY>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.SORT_KEY), input_name='SORT_KEY')), eol_))
        if self.SORT_KEY_LAST_MOD is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<SORT_KEY_LAST_MOD>%s</SORT_KEY_LAST_MOD>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.SORT_KEY_LAST_MOD), input_name='SORT_KEY_LAST_MOD')), eol_))
        if self.DELISTED_ON is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<DELISTED_ON>%s</DELISTED_ON>%s' % (self.gds_format_date(self.DELISTED_ON, input_name='DELISTED_ON'), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'DATAID':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'DATAID')
            self.DATAID = ival_
        elif nodeName_ == 'VERSIONNUM':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'VERSIONNUM')
            self.VERSIONNUM = ival_
        elif nodeName_ == 'FIRST_NAME':
            FIRST_NAME_ = child_.text
            FIRST_NAME_ = self.gds_validate_string(FIRST_NAME_, node, 'FIRST_NAME')
            self.FIRST_NAME = FIRST_NAME_
        elif nodeName_ == 'SECOND_NAME':
            SECOND_NAME_ = child_.text
            SECOND_NAME_ = self.gds_validate_string(SECOND_NAME_, node, 'SECOND_NAME')
            self.SECOND_NAME = SECOND_NAME_
        elif nodeName_ == 'THIRD_NAME':
            THIRD_NAME_ = child_.text
            THIRD_NAME_ = self.gds_validate_string(THIRD_NAME_, node, 'THIRD_NAME')
            self.THIRD_NAME = THIRD_NAME_
        elif nodeName_ == 'FOURTH_NAME':
            FOURTH_NAME_ = child_.text
            FOURTH_NAME_ = self.gds_validate_string(FOURTH_NAME_, node, 'FOURTH_NAME')
            self.FOURTH_NAME = FOURTH_NAME_
        elif nodeName_ == 'UN_LIST_TYPE':
            UN_LIST_TYPE_ = child_.text
            UN_LIST_TYPE_ = self.gds_validate_string(UN_LIST_TYPE_, node, 'UN_LIST_TYPE')
            self.UN_LIST_TYPE = UN_LIST_TYPE_
        elif nodeName_ == 'REFERENCE_NUMBER':
            REFERENCE_NUMBER_ = child_.text
            REFERENCE_NUMBER_ = self.gds_validate_string(REFERENCE_NUMBER_, node, 'REFERENCE_NUMBER')
            self.REFERENCE_NUMBER = REFERENCE_NUMBER_
        elif nodeName_ == 'LISTED_ON':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.LISTED_ON = dval_
        elif nodeName_ == 'GENDER':
            GENDER_ = child_.text
            GENDER_ = self.gds_validate_string(GENDER_, node, 'GENDER')
            self.GENDER = GENDER_
        elif nodeName_ == 'SUBMITTED_BY':
            SUBMITTED_BY_ = child_.text
            SUBMITTED_BY_ = self.gds_validate_string(SUBMITTED_BY_, node, 'SUBMITTED_BY')
            self.SUBMITTED_BY = SUBMITTED_BY_
        elif nodeName_ == 'NAME_ORIGINAL_SCRIPT':
            NAME_ORIGINAL_SCRIPT_ = child_.text
            NAME_ORIGINAL_SCRIPT_ = self.gds_validate_string(NAME_ORIGINAL_SCRIPT_, node, 'NAME_ORIGINAL_SCRIPT')
            self.NAME_ORIGINAL_SCRIPT = NAME_ORIGINAL_SCRIPT_
        elif nodeName_ == 'COMMENTS1':
            COMMENTS1_ = child_.text
            COMMENTS1_ = self.gds_validate_string(COMMENTS1_, node, 'COMMENTS1')
            self.COMMENTS1 = COMMENTS1_
        elif nodeName_ == 'NATIONALITY2':
            NATIONALITY2_ = child_.text
            NATIONALITY2_ = self.gds_validate_string(NATIONALITY2_, node, 'NATIONALITY2')
            self.NATIONALITY2 = NATIONALITY2_
        elif nodeName_ == 'TITLE':
            obj_ = TITLE.factory()
            obj_.build(child_)
            self.TITLE = obj_
            obj_.original_tagname_ = 'TITLE'
        elif nodeName_ == 'DESIGNATION':
            obj_ = DESIGNATION.factory()
            obj_.build(child_)
            self.DESIGNATION = obj_
            obj_.original_tagname_ = 'DESIGNATION'
        elif nodeName_ == 'NATIONALITY':
            obj_ = NATIONALITY.factory()
            obj_.build(child_)
            self.NATIONALITY = obj_
            obj_.original_tagname_ = 'NATIONALITY'
        elif nodeName_ == 'LIST_TYPE':
            obj_ = LIST_TYPE.factory()
            obj_.build(child_)
            self.LIST_TYPE = obj_
            obj_.original_tagname_ = 'LIST_TYPE'
        elif nodeName_ == 'LAST_DAY_UPDATED':
            obj_ = LAST_DAY_UPDATED.factory()
            obj_.build(child_)
            self.LAST_DAY_UPDATED = obj_
            obj_.original_tagname_ = 'LAST_DAY_UPDATED'
        elif nodeName_ == 'INDIVIDUAL_ALIAS':
            obj_ = INDIVIDUAL_ALIAS.factory()
            obj_.build(child_)
            self.INDIVIDUAL_ALIAS.append(obj_)
            obj_.original_tagname_ = 'INDIVIDUAL_ALIAS'
        elif nodeName_ == 'INDIVIDUAL_ADDRESS':
            obj_ = INDIVIDUAL_ADDRESS.factory()
            obj_.build(child_)
            self.INDIVIDUAL_ADDRESS.append(obj_)
            obj_.original_tagname_ = 'INDIVIDUAL_ADDRESS'
        elif nodeName_ == 'INDIVIDUAL_DATE_OF_BIRTH':
            obj_ = INDIVIDUAL_DATE_OF_BIRTH.factory()
            obj_.build(child_)
            self.INDIVIDUAL_DATE_OF_BIRTH.append(obj_)
            obj_.original_tagname_ = 'INDIVIDUAL_DATE_OF_BIRTH'
        elif nodeName_ == 'INDIVIDUAL_PLACE_OF_BIRTH':
            obj_ = INDIVIDUAL_PLACE_OF_BIRTH.factory()
            obj_.build(child_)
            self.INDIVIDUAL_PLACE_OF_BIRTH.append(obj_)
            obj_.original_tagname_ = 'INDIVIDUAL_PLACE_OF_BIRTH'
        elif nodeName_ == 'INDIVIDUAL_DOCUMENT':
            obj_ = INDIVIDUAL_DOCUMENT.factory()
            obj_.build(child_)
            self.INDIVIDUAL_DOCUMENT.append(obj_)
            obj_.original_tagname_ = 'INDIVIDUAL_DOCUMENT'
        elif nodeName_ == 'SORT_KEY':
            SORT_KEY_ = child_.text
            SORT_KEY_ = self.gds_validate_string(SORT_KEY_, node, 'SORT_KEY')
            self.SORT_KEY = SORT_KEY_
        elif nodeName_ == 'SORT_KEY_LAST_MOD':
            SORT_KEY_LAST_MOD_ = child_.text
            SORT_KEY_LAST_MOD_ = self.gds_validate_string(SORT_KEY_LAST_MOD_, node, 'SORT_KEY_LAST_MOD')
            self.SORT_KEY_LAST_MOD = SORT_KEY_LAST_MOD_
        elif nodeName_ == 'DELISTED_ON':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.DELISTED_ON = dval_
# end class INDIVIDUAL


class TITLE(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, VALUE=None):
        self.original_tagname_ = None
        if VALUE is None:
            self.VALUE = []
        else:
            self.VALUE = VALUE
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TITLE)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TITLE.subclass:
            return TITLE.subclass(*args_, **kwargs_)
        else:
            return TITLE(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_VALUE(self): return self.VALUE
    def set_VALUE(self, VALUE): self.VALUE = VALUE
    def add_VALUE(self, value): self.VALUE.append(value)
    def insert_VALUE_at(self, index, value): self.VALUE.insert(index, value)
    def replace_VALUE_at(self, index, value): self.VALUE[index] = value
    def hasContent_(self):
        if (
            self.VALUE
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='TITLE', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TITLE')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TITLE')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='TITLE', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TITLE'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='TITLE', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for VALUE_ in self.VALUE:
            showIndent(outfile, level, pretty_print)
            outfile.write('<VALUE>%s</VALUE>%s' % (self.gds_encode(self.gds_format_string(quote_xml(VALUE_), input_name='VALUE')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'VALUE':
            VALUE_ = child_.text
            VALUE_ = self.gds_validate_string(VALUE_, node, 'VALUE')
            self.VALUE.append(VALUE_)
# end class TITLE


class DESIGNATION(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, VALUE=None):
        self.original_tagname_ = None
        if VALUE is None:
            self.VALUE = []
        else:
            self.VALUE = VALUE
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DESIGNATION)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DESIGNATION.subclass:
            return DESIGNATION.subclass(*args_, **kwargs_)
        else:
            return DESIGNATION(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_VALUE(self): return self.VALUE
    def set_VALUE(self, VALUE): self.VALUE = VALUE
    def add_VALUE(self, value): self.VALUE.append(value)
    def insert_VALUE_at(self, index, value): self.VALUE.insert(index, value)
    def replace_VALUE_at(self, index, value): self.VALUE[index] = value
    def hasContent_(self):
        if (
            self.VALUE
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='DESIGNATION', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DESIGNATION')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DESIGNATION')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='DESIGNATION', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DESIGNATION'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='DESIGNATION', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for VALUE_ in self.VALUE:
            showIndent(outfile, level, pretty_print)
            outfile.write('<VALUE>%s</VALUE>%s' % (self.gds_encode(self.gds_format_string(quote_xml(VALUE_), input_name='VALUE')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'VALUE':
            VALUE_ = child_.text
            VALUE_ = self.gds_validate_string(VALUE_, node, 'VALUE')
            self.VALUE.append(VALUE_)
# end class DESIGNATION


class NATIONALITY(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, VALUE=None):
        self.original_tagname_ = None
        if VALUE is None:
            self.VALUE = []
        else:
            self.VALUE = VALUE
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, NATIONALITY)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if NATIONALITY.subclass:
            return NATIONALITY.subclass(*args_, **kwargs_)
        else:
            return NATIONALITY(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_VALUE(self): return self.VALUE
    def set_VALUE(self, VALUE): self.VALUE = VALUE
    def add_VALUE(self, value): self.VALUE.append(value)
    def insert_VALUE_at(self, index, value): self.VALUE.insert(index, value)
    def replace_VALUE_at(self, index, value): self.VALUE[index] = value
    def hasContent_(self):
        if (
            self.VALUE
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='NATIONALITY', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('NATIONALITY')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='NATIONALITY')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='NATIONALITY', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='NATIONALITY'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='NATIONALITY', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for VALUE_ in self.VALUE:
            showIndent(outfile, level, pretty_print)
            outfile.write('<VALUE>%s</VALUE>%s' % (self.gds_encode(self.gds_format_string(quote_xml(VALUE_), input_name='VALUE')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'VALUE':
            VALUE_ = child_.text
            VALUE_ = self.gds_validate_string(VALUE_, node, 'VALUE')
            self.VALUE.append(VALUE_)
# end class NATIONALITY


class INDIVIDUAL_ALIAS(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, QUALITY=None, ALIAS_NAME=None, DATE_OF_BIRTH=None, CITY_OF_BIRTH=None, COUNTRY_OF_BIRTH=None, NOTE=None):
        self.original_tagname_ = None
        self.QUALITY = QUALITY
        self.ALIAS_NAME = ALIAS_NAME
        self.DATE_OF_BIRTH = DATE_OF_BIRTH
        self.CITY_OF_BIRTH = CITY_OF_BIRTH
        self.COUNTRY_OF_BIRTH = COUNTRY_OF_BIRTH
        self.NOTE = NOTE
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, INDIVIDUAL_ALIAS)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if INDIVIDUAL_ALIAS.subclass:
            return INDIVIDUAL_ALIAS.subclass(*args_, **kwargs_)
        else:
            return INDIVIDUAL_ALIAS(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_QUALITY(self): return self.QUALITY
    def set_QUALITY(self, QUALITY): self.QUALITY = QUALITY
    def get_ALIAS_NAME(self): return self.ALIAS_NAME
    def set_ALIAS_NAME(self, ALIAS_NAME): self.ALIAS_NAME = ALIAS_NAME
    def get_DATE_OF_BIRTH(self): return self.DATE_OF_BIRTH
    def set_DATE_OF_BIRTH(self, DATE_OF_BIRTH): self.DATE_OF_BIRTH = DATE_OF_BIRTH
    def get_CITY_OF_BIRTH(self): return self.CITY_OF_BIRTH
    def set_CITY_OF_BIRTH(self, CITY_OF_BIRTH): self.CITY_OF_BIRTH = CITY_OF_BIRTH
    def get_COUNTRY_OF_BIRTH(self): return self.COUNTRY_OF_BIRTH
    def set_COUNTRY_OF_BIRTH(self, COUNTRY_OF_BIRTH): self.COUNTRY_OF_BIRTH = COUNTRY_OF_BIRTH
    def get_NOTE(self): return self.NOTE
    def set_NOTE(self, NOTE): self.NOTE = NOTE
    def hasContent_(self):
        if (
            self.QUALITY is not None or
            self.ALIAS_NAME is not None or
            self.DATE_OF_BIRTH is not None or
            self.CITY_OF_BIRTH is not None or
            self.COUNTRY_OF_BIRTH is not None or
            self.NOTE is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='INDIVIDUAL_ALIAS', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('INDIVIDUAL_ALIAS')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='INDIVIDUAL_ALIAS')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='INDIVIDUAL_ALIAS', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='INDIVIDUAL_ALIAS'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='INDIVIDUAL_ALIAS', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.QUALITY is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<QUALITY>%s</QUALITY>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.QUALITY), input_name='QUALITY')), eol_))
        if self.ALIAS_NAME is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ALIAS_NAME>%s</ALIAS_NAME>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.ALIAS_NAME), input_name='ALIAS_NAME')), eol_))
        if self.DATE_OF_BIRTH is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<DATE_OF_BIRTH>%s</DATE_OF_BIRTH>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.DATE_OF_BIRTH), input_name='DATE_OF_BIRTH')), eol_))
        if self.CITY_OF_BIRTH is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<CITY_OF_BIRTH>%s</CITY_OF_BIRTH>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.CITY_OF_BIRTH), input_name='CITY_OF_BIRTH')), eol_))
        if self.COUNTRY_OF_BIRTH is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<COUNTRY_OF_BIRTH>%s</COUNTRY_OF_BIRTH>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.COUNTRY_OF_BIRTH), input_name='COUNTRY_OF_BIRTH')), eol_))
        if self.NOTE is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<NOTE>%s</NOTE>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.NOTE), input_name='NOTE')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'QUALITY':
            QUALITY_ = child_.text
            QUALITY_ = self.gds_validate_string(QUALITY_, node, 'QUALITY')
            self.QUALITY = QUALITY_
        elif nodeName_ == 'ALIAS_NAME':
            ALIAS_NAME_ = child_.text
            ALIAS_NAME_ = self.gds_validate_string(ALIAS_NAME_, node, 'ALIAS_NAME')
            self.ALIAS_NAME = ALIAS_NAME_
        elif nodeName_ == 'DATE_OF_BIRTH':
            DATE_OF_BIRTH_ = child_.text
            DATE_OF_BIRTH_ = self.gds_validate_string(DATE_OF_BIRTH_, node, 'DATE_OF_BIRTH')
            self.DATE_OF_BIRTH = DATE_OF_BIRTH_
        elif nodeName_ == 'CITY_OF_BIRTH':
            CITY_OF_BIRTH_ = child_.text
            CITY_OF_BIRTH_ = self.gds_validate_string(CITY_OF_BIRTH_, node, 'CITY_OF_BIRTH')
            self.CITY_OF_BIRTH = CITY_OF_BIRTH_
        elif nodeName_ == 'COUNTRY_OF_BIRTH':
            COUNTRY_OF_BIRTH_ = child_.text
            COUNTRY_OF_BIRTH_ = self.gds_validate_string(COUNTRY_OF_BIRTH_, node, 'COUNTRY_OF_BIRTH')
            self.COUNTRY_OF_BIRTH = COUNTRY_OF_BIRTH_
        elif nodeName_ == 'NOTE':
            NOTE_ = child_.text
            NOTE_ = self.gds_validate_string(NOTE_, node, 'NOTE')
            self.NOTE = NOTE_
# end class INDIVIDUAL_ALIAS


class INDIVIDUAL_ADDRESS(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, STREET=None, CITY=None, STATE_PROVINCE=None, ZIP_CODE=None, COUNTRY=None, NOTE=None):
        self.original_tagname_ = None
        self.STREET = STREET
        self.CITY = CITY
        self.STATE_PROVINCE = STATE_PROVINCE
        self.ZIP_CODE = ZIP_CODE
        self.COUNTRY = COUNTRY
        self.NOTE = NOTE
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, INDIVIDUAL_ADDRESS)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if INDIVIDUAL_ADDRESS.subclass:
            return INDIVIDUAL_ADDRESS.subclass(*args_, **kwargs_)
        else:
            return INDIVIDUAL_ADDRESS(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_STREET(self): return self.STREET
    def set_STREET(self, STREET): self.STREET = STREET
    def get_CITY(self): return self.CITY
    def set_CITY(self, CITY): self.CITY = CITY
    def get_STATE_PROVINCE(self): return self.STATE_PROVINCE
    def set_STATE_PROVINCE(self, STATE_PROVINCE): self.STATE_PROVINCE = STATE_PROVINCE
    def get_ZIP_CODE(self): return self.ZIP_CODE
    def set_ZIP_CODE(self, ZIP_CODE): self.ZIP_CODE = ZIP_CODE
    def get_COUNTRY(self): return self.COUNTRY
    def set_COUNTRY(self, COUNTRY): self.COUNTRY = COUNTRY
    def get_NOTE(self): return self.NOTE
    def set_NOTE(self, NOTE): self.NOTE = NOTE
    def hasContent_(self):
        if (
            self.STREET is not None or
            self.CITY is not None or
            self.STATE_PROVINCE is not None or
            self.ZIP_CODE is not None or
            self.COUNTRY is not None or
            self.NOTE is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='INDIVIDUAL_ADDRESS', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('INDIVIDUAL_ADDRESS')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='INDIVIDUAL_ADDRESS')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='INDIVIDUAL_ADDRESS', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='INDIVIDUAL_ADDRESS'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='INDIVIDUAL_ADDRESS', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.STREET is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<STREET>%s</STREET>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.STREET), input_name='STREET')), eol_))
        if self.CITY is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<CITY>%s</CITY>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.CITY), input_name='CITY')), eol_))
        if self.STATE_PROVINCE is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<STATE_PROVINCE>%s</STATE_PROVINCE>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.STATE_PROVINCE), input_name='STATE_PROVINCE')), eol_))
        if self.ZIP_CODE is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ZIP_CODE>%s</ZIP_CODE>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.ZIP_CODE), input_name='ZIP_CODE')), eol_))
        if self.COUNTRY is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<COUNTRY>%s</COUNTRY>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.COUNTRY), input_name='COUNTRY')), eol_))
        if self.NOTE is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<NOTE>%s</NOTE>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.NOTE), input_name='NOTE')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'STREET':
            STREET_ = child_.text
            STREET_ = self.gds_validate_string(STREET_, node, 'STREET')
            self.STREET = STREET_
        elif nodeName_ == 'CITY':
            CITY_ = child_.text
            CITY_ = self.gds_validate_string(CITY_, node, 'CITY')
            self.CITY = CITY_
        elif nodeName_ == 'STATE_PROVINCE':
            STATE_PROVINCE_ = child_.text
            STATE_PROVINCE_ = self.gds_validate_string(STATE_PROVINCE_, node, 'STATE_PROVINCE')
            self.STATE_PROVINCE = STATE_PROVINCE_
        elif nodeName_ == 'ZIP_CODE':
            ZIP_CODE_ = child_.text
            ZIP_CODE_ = self.gds_validate_string(ZIP_CODE_, node, 'ZIP_CODE')
            self.ZIP_CODE = ZIP_CODE_
        elif nodeName_ == 'COUNTRY':
            COUNTRY_ = child_.text
            COUNTRY_ = self.gds_validate_string(COUNTRY_, node, 'COUNTRY')
            self.COUNTRY = COUNTRY_
        elif nodeName_ == 'NOTE':
            NOTE_ = child_.text
            NOTE_ = self.gds_validate_string(NOTE_, node, 'NOTE')
            self.NOTE = NOTE_
# end class INDIVIDUAL_ADDRESS


class INDIVIDUAL_DATE_OF_BIRTH(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, TYPE_OF_DATE=None, NOTE=None, DATE=None, YEAR=None, FROM_YEAR=None, TO_YEAR=None):
        self.original_tagname_ = None
        self.TYPE_OF_DATE = TYPE_OF_DATE
        self.NOTE = NOTE
        if isinstance(DATE, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(DATE, '%Y-%m-%d').date()
        else:
            initvalue_ = DATE
        self.DATE = initvalue_
        self.YEAR = YEAR
        self.validate_YEAR(self.YEAR)
        self.FROM_YEAR = FROM_YEAR
        self.validate_FROM_YEAR(self.FROM_YEAR)
        self.TO_YEAR = TO_YEAR
        self.validate_TO_YEAR(self.TO_YEAR)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, INDIVIDUAL_DATE_OF_BIRTH)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if INDIVIDUAL_DATE_OF_BIRTH.subclass:
            return INDIVIDUAL_DATE_OF_BIRTH.subclass(*args_, **kwargs_)
        else:
            return INDIVIDUAL_DATE_OF_BIRTH(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_TYPE_OF_DATE(self): return self.TYPE_OF_DATE
    def set_TYPE_OF_DATE(self, TYPE_OF_DATE): self.TYPE_OF_DATE = TYPE_OF_DATE
    def get_NOTE(self): return self.NOTE
    def set_NOTE(self, NOTE): self.NOTE = NOTE
    def get_DATE(self): return self.DATE
    def set_DATE(self, DATE): self.DATE = DATE
    def get_YEAR(self): return self.YEAR
    def set_YEAR(self, YEAR): self.YEAR = YEAR
    def get_FROM_YEAR(self): return self.FROM_YEAR
    def set_FROM_YEAR(self, FROM_YEAR): self.FROM_YEAR = FROM_YEAR
    def get_TO_YEAR(self): return self.TO_YEAR
    def set_TO_YEAR(self, TO_YEAR): self.TO_YEAR = TO_YEAR
    def validate_YEAR(self, value):
        # Validate type YEAR, a restriction on xs:integer.
        pass
    def validate_FROM_YEAR(self, value):
        # Validate type FROM_YEAR, a restriction on xs:integer.
        pass
    def validate_TO_YEAR(self, value):
        # Validate type TO_YEAR, a restriction on xs:integer.
        pass
    def hasContent_(self):
        if (
            self.TYPE_OF_DATE is not None or
            self.NOTE is not None or
            self.DATE is not None or
            self.YEAR is not None or
            self.FROM_YEAR is not None or
            self.TO_YEAR is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='INDIVIDUAL_DATE_OF_BIRTH', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('INDIVIDUAL_DATE_OF_BIRTH')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='INDIVIDUAL_DATE_OF_BIRTH')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='INDIVIDUAL_DATE_OF_BIRTH', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='INDIVIDUAL_DATE_OF_BIRTH'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='INDIVIDUAL_DATE_OF_BIRTH', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.TYPE_OF_DATE is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<TYPE_OF_DATE>%s</TYPE_OF_DATE>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.TYPE_OF_DATE), input_name='TYPE_OF_DATE')), eol_))
        if self.NOTE is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<NOTE>%s</NOTE>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.NOTE), input_name='NOTE')), eol_))
        if self.DATE is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<DATE>%s</DATE>%s' % (self.gds_format_date(self.DATE, input_name='DATE'), eol_))
        if self.YEAR is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<YEAR>%s</YEAR>%s' % (self.gds_format_integer(self.YEAR, input_name='YEAR'), eol_))
        if self.FROM_YEAR is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<FROM_YEAR>%s</FROM_YEAR>%s' % (self.gds_format_integer(self.FROM_YEAR, input_name='FROM_YEAR'), eol_))
        if self.TO_YEAR is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<TO_YEAR>%s</TO_YEAR>%s' % (self.gds_format_integer(self.TO_YEAR, input_name='TO_YEAR'), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'TYPE_OF_DATE':
            TYPE_OF_DATE_ = child_.text
            TYPE_OF_DATE_ = self.gds_validate_string(TYPE_OF_DATE_, node, 'TYPE_OF_DATE')
            self.TYPE_OF_DATE = TYPE_OF_DATE_
        elif nodeName_ == 'NOTE':
            NOTE_ = child_.text
            NOTE_ = self.gds_validate_string(NOTE_, node, 'NOTE')
            self.NOTE = NOTE_
        elif nodeName_ == 'DATE':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.DATE = dval_
        elif nodeName_ == 'YEAR':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'YEAR')
            self.YEAR = ival_
            # validate type YEAR
            self.validate_YEAR(self.YEAR)
        elif nodeName_ == 'FROM_YEAR':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'FROM_YEAR')
            self.FROM_YEAR = ival_
            # validate type FROM_YEAR
            self.validate_FROM_YEAR(self.FROM_YEAR)
        elif nodeName_ == 'TO_YEAR':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'TO_YEAR')
            self.TO_YEAR = ival_
            # validate type TO_YEAR
            self.validate_TO_YEAR(self.TO_YEAR)
# end class INDIVIDUAL_DATE_OF_BIRTH


class YEAR(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, YEAR)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if YEAR.subclass:
            return YEAR.subclass(*args_, **kwargs_)
        else:
            return YEAR(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='YEAR', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('YEAR')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='YEAR')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='YEAR', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='YEAR'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='YEAR', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class YEAR


class FROM_YEAR(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FROM_YEAR)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FROM_YEAR.subclass:
            return FROM_YEAR.subclass(*args_, **kwargs_)
        else:
            return FROM_YEAR(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='FROM_YEAR', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('FROM_YEAR')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FROM_YEAR')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='FROM_YEAR', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='FROM_YEAR'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='FROM_YEAR', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class FROM_YEAR


class TO_YEAR(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TO_YEAR)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TO_YEAR.subclass:
            return TO_YEAR.subclass(*args_, **kwargs_)
        else:
            return TO_YEAR(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='TO_YEAR', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TO_YEAR')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TO_YEAR')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='TO_YEAR', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TO_YEAR'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='TO_YEAR', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class TO_YEAR


class INDIVIDUAL_PLACE_OF_BIRTH(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, CITY=None, STATE_PROVINCE=None, COUNTRY=None, NOTE=None):
        self.original_tagname_ = None
        self.CITY = CITY
        self.STATE_PROVINCE = STATE_PROVINCE
        self.COUNTRY = COUNTRY
        self.NOTE = NOTE
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, INDIVIDUAL_PLACE_OF_BIRTH)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if INDIVIDUAL_PLACE_OF_BIRTH.subclass:
            return INDIVIDUAL_PLACE_OF_BIRTH.subclass(*args_, **kwargs_)
        else:
            return INDIVIDUAL_PLACE_OF_BIRTH(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_CITY(self): return self.CITY
    def set_CITY(self, CITY): self.CITY = CITY
    def get_STATE_PROVINCE(self): return self.STATE_PROVINCE
    def set_STATE_PROVINCE(self, STATE_PROVINCE): self.STATE_PROVINCE = STATE_PROVINCE
    def get_COUNTRY(self): return self.COUNTRY
    def set_COUNTRY(self, COUNTRY): self.COUNTRY = COUNTRY
    def get_NOTE(self): return self.NOTE
    def set_NOTE(self, NOTE): self.NOTE = NOTE
    def hasContent_(self):
        if (
            self.CITY is not None or
            self.STATE_PROVINCE is not None or
            self.COUNTRY is not None or
            self.NOTE is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='INDIVIDUAL_PLACE_OF_BIRTH', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('INDIVIDUAL_PLACE_OF_BIRTH')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='INDIVIDUAL_PLACE_OF_BIRTH')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='INDIVIDUAL_PLACE_OF_BIRTH', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='INDIVIDUAL_PLACE_OF_BIRTH'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='INDIVIDUAL_PLACE_OF_BIRTH', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.CITY is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<CITY>%s</CITY>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.CITY), input_name='CITY')), eol_))
        if self.STATE_PROVINCE is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<STATE_PROVINCE>%s</STATE_PROVINCE>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.STATE_PROVINCE), input_name='STATE_PROVINCE')), eol_))
        if self.COUNTRY is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<COUNTRY>%s</COUNTRY>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.COUNTRY), input_name='COUNTRY')), eol_))
        if self.NOTE is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<NOTE>%s</NOTE>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.NOTE), input_name='NOTE')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'CITY':
            CITY_ = child_.text
            CITY_ = self.gds_validate_string(CITY_, node, 'CITY')
            self.CITY = CITY_
        elif nodeName_ == 'STATE_PROVINCE':
            STATE_PROVINCE_ = child_.text
            STATE_PROVINCE_ = self.gds_validate_string(STATE_PROVINCE_, node, 'STATE_PROVINCE')
            self.STATE_PROVINCE = STATE_PROVINCE_
        elif nodeName_ == 'COUNTRY':
            COUNTRY_ = child_.text
            COUNTRY_ = self.gds_validate_string(COUNTRY_, node, 'COUNTRY')
            self.COUNTRY = COUNTRY_
        elif nodeName_ == 'NOTE':
            NOTE_ = child_.text
            NOTE_ = self.gds_validate_string(NOTE_, node, 'NOTE')
            self.NOTE = NOTE_
# end class INDIVIDUAL_PLACE_OF_BIRTH


class INDIVIDUAL_DOCUMENT(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, TYPE_OF_DOCUMENT=None, TYPE_OF_DOCUMENT2=None, NUMBER=None, ISSUING_COUNTRY=None, DATE_OF_ISSUE=None, CITY_OF_ISSUE=None, COUNTRY_OF_ISSUE=None, NOTE=None):
        self.original_tagname_ = None
        self.TYPE_OF_DOCUMENT = TYPE_OF_DOCUMENT
        self.TYPE_OF_DOCUMENT2 = TYPE_OF_DOCUMENT2
        self.NUMBER = NUMBER
        self.ISSUING_COUNTRY = ISSUING_COUNTRY
        self.DATE_OF_ISSUE = DATE_OF_ISSUE
        self.CITY_OF_ISSUE = CITY_OF_ISSUE
        self.COUNTRY_OF_ISSUE = COUNTRY_OF_ISSUE
        self.NOTE = NOTE
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, INDIVIDUAL_DOCUMENT)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if INDIVIDUAL_DOCUMENT.subclass:
            return INDIVIDUAL_DOCUMENT.subclass(*args_, **kwargs_)
        else:
            return INDIVIDUAL_DOCUMENT(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_TYPE_OF_DOCUMENT(self): return self.TYPE_OF_DOCUMENT
    def set_TYPE_OF_DOCUMENT(self, TYPE_OF_DOCUMENT): self.TYPE_OF_DOCUMENT = TYPE_OF_DOCUMENT
    def get_TYPE_OF_DOCUMENT2(self): return self.TYPE_OF_DOCUMENT2
    def set_TYPE_OF_DOCUMENT2(self, TYPE_OF_DOCUMENT2): self.TYPE_OF_DOCUMENT2 = TYPE_OF_DOCUMENT2
    def get_NUMBER(self): return self.NUMBER
    def set_NUMBER(self, NUMBER): self.NUMBER = NUMBER
    def get_ISSUING_COUNTRY(self): return self.ISSUING_COUNTRY
    def set_ISSUING_COUNTRY(self, ISSUING_COUNTRY): self.ISSUING_COUNTRY = ISSUING_COUNTRY
    def get_DATE_OF_ISSUE(self): return self.DATE_OF_ISSUE
    def set_DATE_OF_ISSUE(self, DATE_OF_ISSUE): self.DATE_OF_ISSUE = DATE_OF_ISSUE
    def get_CITY_OF_ISSUE(self): return self.CITY_OF_ISSUE
    def set_CITY_OF_ISSUE(self, CITY_OF_ISSUE): self.CITY_OF_ISSUE = CITY_OF_ISSUE
    def get_COUNTRY_OF_ISSUE(self): return self.COUNTRY_OF_ISSUE
    def set_COUNTRY_OF_ISSUE(self, COUNTRY_OF_ISSUE): self.COUNTRY_OF_ISSUE = COUNTRY_OF_ISSUE
    def get_NOTE(self): return self.NOTE
    def set_NOTE(self, NOTE): self.NOTE = NOTE
    def hasContent_(self):
        if (
            self.TYPE_OF_DOCUMENT is not None or
            self.TYPE_OF_DOCUMENT2 is not None or
            self.NUMBER is not None or
            self.ISSUING_COUNTRY is not None or
            self.DATE_OF_ISSUE is not None or
            self.CITY_OF_ISSUE is not None or
            self.COUNTRY_OF_ISSUE is not None or
            self.NOTE is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='INDIVIDUAL_DOCUMENT', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('INDIVIDUAL_DOCUMENT')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='INDIVIDUAL_DOCUMENT')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='INDIVIDUAL_DOCUMENT', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='INDIVIDUAL_DOCUMENT'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='INDIVIDUAL_DOCUMENT', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.TYPE_OF_DOCUMENT is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<TYPE_OF_DOCUMENT>%s</TYPE_OF_DOCUMENT>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.TYPE_OF_DOCUMENT), input_name='TYPE_OF_DOCUMENT')), eol_))
        if self.TYPE_OF_DOCUMENT2 is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<TYPE_OF_DOCUMENT2>%s</TYPE_OF_DOCUMENT2>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.TYPE_OF_DOCUMENT2), input_name='TYPE_OF_DOCUMENT2')), eol_))
        if self.NUMBER is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<NUMBER>%s</NUMBER>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.NUMBER), input_name='NUMBER')), eol_))
        if self.ISSUING_COUNTRY is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ISSUING_COUNTRY>%s</ISSUING_COUNTRY>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.ISSUING_COUNTRY), input_name='ISSUING_COUNTRY')), eol_))
        if self.DATE_OF_ISSUE is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<DATE_OF_ISSUE>%s</DATE_OF_ISSUE>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.DATE_OF_ISSUE), input_name='DATE_OF_ISSUE')), eol_))
        if self.CITY_OF_ISSUE is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<CITY_OF_ISSUE>%s</CITY_OF_ISSUE>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.CITY_OF_ISSUE), input_name='CITY_OF_ISSUE')), eol_))
        if self.COUNTRY_OF_ISSUE is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<COUNTRY_OF_ISSUE>%s</COUNTRY_OF_ISSUE>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.COUNTRY_OF_ISSUE), input_name='COUNTRY_OF_ISSUE')), eol_))
        if self.NOTE is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<NOTE>%s</NOTE>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.NOTE), input_name='NOTE')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'TYPE_OF_DOCUMENT':
            TYPE_OF_DOCUMENT_ = child_.text
            TYPE_OF_DOCUMENT_ = self.gds_validate_string(TYPE_OF_DOCUMENT_, node, 'TYPE_OF_DOCUMENT')
            self.TYPE_OF_DOCUMENT = TYPE_OF_DOCUMENT_
        elif nodeName_ == 'TYPE_OF_DOCUMENT2':
            TYPE_OF_DOCUMENT2_ = child_.text
            TYPE_OF_DOCUMENT2_ = self.gds_validate_string(TYPE_OF_DOCUMENT2_, node, 'TYPE_OF_DOCUMENT2')
            self.TYPE_OF_DOCUMENT2 = TYPE_OF_DOCUMENT2_
        elif nodeName_ == 'NUMBER':
            NUMBER_ = child_.text
            NUMBER_ = self.gds_validate_string(NUMBER_, node, 'NUMBER')
            self.NUMBER = NUMBER_
        elif nodeName_ == 'ISSUING_COUNTRY':
            ISSUING_COUNTRY_ = child_.text
            ISSUING_COUNTRY_ = self.gds_validate_string(ISSUING_COUNTRY_, node, 'ISSUING_COUNTRY')
            self.ISSUING_COUNTRY = ISSUING_COUNTRY_
        elif nodeName_ == 'DATE_OF_ISSUE':
            DATE_OF_ISSUE_ = child_.text
            DATE_OF_ISSUE_ = self.gds_validate_string(DATE_OF_ISSUE_, node, 'DATE_OF_ISSUE')
            self.DATE_OF_ISSUE = DATE_OF_ISSUE_
        elif nodeName_ == 'CITY_OF_ISSUE':
            CITY_OF_ISSUE_ = child_.text
            CITY_OF_ISSUE_ = self.gds_validate_string(CITY_OF_ISSUE_, node, 'CITY_OF_ISSUE')
            self.CITY_OF_ISSUE = CITY_OF_ISSUE_
        elif nodeName_ == 'COUNTRY_OF_ISSUE':
            COUNTRY_OF_ISSUE_ = child_.text
            COUNTRY_OF_ISSUE_ = self.gds_validate_string(COUNTRY_OF_ISSUE_, node, 'COUNTRY_OF_ISSUE')
            self.COUNTRY_OF_ISSUE = COUNTRY_OF_ISSUE_
        elif nodeName_ == 'NOTE':
            NOTE_ = child_.text
            NOTE_ = self.gds_validate_string(NOTE_, node, 'NOTE')
            self.NOTE = NOTE_
# end class INDIVIDUAL_DOCUMENT


class ENTITIES(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ENTITY=None, valueOf_=None):
        self.original_tagname_ = None
        if ENTITY is None:
            self.ENTITY = []
        else:
            self.ENTITY = ENTITY
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ENTITIES)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ENTITIES.subclass:
            return ENTITIES.subclass(*args_, **kwargs_)
        else:
            return ENTITIES(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ENTITY(self): return self.ENTITY
    def set_ENTITY(self, ENTITY): self.ENTITY = ENTITY
    def add_ENTITY(self, value): self.ENTITY.append(value)
    def insert_ENTITY_at(self, index, value): self.ENTITY.insert(index, value)
    def replace_ENTITY_at(self, index, value): self.ENTITY[index] = value
    def hasContent_(self):
        if (
            self.ENTITY
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ENTITIES', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ENTITIES')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ENTITIES')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ENTITIES', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ENTITIES'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ENTITIES', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for ENTITY_ in self.ENTITY:
            ENTITY_.export(outfile, level, namespace_, name_='ENTITY', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ENTITY':
            obj_ = ENTITY.factory()
            obj_.build(child_)
            self.ENTITY.append(obj_)
            obj_.original_tagname_ = 'ENTITY'
# end class ENTITIES


class ENTITY(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, DATAID=None, VERSIONNUM=None, FIRST_NAME=None, UN_LIST_TYPE=None, REFERENCE_NUMBER=None, LISTED_ON=None, SUBMITTED_ON=None, NAME_ORIGINAL_SCRIPT=None, COMMENTS1=None, LIST_TYPE=None, LAST_DAY_UPDATED=None, ENTITY_ALIAS=None, ENTITY_ADDRESS=None, SORT_KEY=None, SORT_KEY_LAST_MOD=None, DELISTED_ON=None, valueOf_=None):
        self.original_tagname_ = None
        self.DATAID = DATAID
        self.VERSIONNUM = VERSIONNUM
        self.FIRST_NAME = FIRST_NAME
        self.UN_LIST_TYPE = UN_LIST_TYPE
        self.REFERENCE_NUMBER = REFERENCE_NUMBER
        if isinstance(LISTED_ON, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(LISTED_ON, '%Y-%m-%d').date()
        else:
            initvalue_ = LISTED_ON
        self.LISTED_ON = initvalue_
        if isinstance(SUBMITTED_ON, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(SUBMITTED_ON, '%Y-%m-%d').date()
        else:
            initvalue_ = SUBMITTED_ON
        self.SUBMITTED_ON = initvalue_
        self.NAME_ORIGINAL_SCRIPT = NAME_ORIGINAL_SCRIPT
        self.COMMENTS1 = COMMENTS1
        self.LIST_TYPE = LIST_TYPE
        self.LAST_DAY_UPDATED = LAST_DAY_UPDATED
        if ENTITY_ALIAS is None:
            self.ENTITY_ALIAS = []
        else:
            self.ENTITY_ALIAS = ENTITY_ALIAS
        if ENTITY_ADDRESS is None:
            self.ENTITY_ADDRESS = []
        else:
            self.ENTITY_ADDRESS = ENTITY_ADDRESS
        self.SORT_KEY = SORT_KEY
        self.SORT_KEY_LAST_MOD = SORT_KEY_LAST_MOD
        if isinstance(DELISTED_ON, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(DELISTED_ON, '%Y-%m-%d').date()
        else:
            initvalue_ = DELISTED_ON
        self.DELISTED_ON = initvalue_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ENTITY)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ENTITY.subclass:
            return ENTITY.subclass(*args_, **kwargs_)
        else:
            return ENTITY(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_DATAID(self): return self.DATAID
    def set_DATAID(self, DATAID): self.DATAID = DATAID
    def get_VERSIONNUM(self): return self.VERSIONNUM
    def set_VERSIONNUM(self, VERSIONNUM): self.VERSIONNUM = VERSIONNUM
    def get_FIRST_NAME(self): return self.FIRST_NAME
    def set_FIRST_NAME(self, FIRST_NAME): self.FIRST_NAME = FIRST_NAME
    def get_UN_LIST_TYPE(self): return self.UN_LIST_TYPE
    def set_UN_LIST_TYPE(self, UN_LIST_TYPE): self.UN_LIST_TYPE = UN_LIST_TYPE
    def get_REFERENCE_NUMBER(self): return self.REFERENCE_NUMBER
    def set_REFERENCE_NUMBER(self, REFERENCE_NUMBER): self.REFERENCE_NUMBER = REFERENCE_NUMBER
    def get_LISTED_ON(self): return self.LISTED_ON
    def set_LISTED_ON(self, LISTED_ON): self.LISTED_ON = LISTED_ON
    def get_SUBMITTED_ON(self): return self.SUBMITTED_ON
    def set_SUBMITTED_ON(self, SUBMITTED_ON): self.SUBMITTED_ON = SUBMITTED_ON
    def get_NAME_ORIGINAL_SCRIPT(self): return self.NAME_ORIGINAL_SCRIPT
    def set_NAME_ORIGINAL_SCRIPT(self, NAME_ORIGINAL_SCRIPT): self.NAME_ORIGINAL_SCRIPT = NAME_ORIGINAL_SCRIPT
    def get_COMMENTS1(self): return self.COMMENTS1
    def set_COMMENTS1(self, COMMENTS1): self.COMMENTS1 = COMMENTS1
    def get_LIST_TYPE(self): return self.LIST_TYPE
    def set_LIST_TYPE(self, LIST_TYPE): self.LIST_TYPE = LIST_TYPE
    def get_LAST_DAY_UPDATED(self): return self.LAST_DAY_UPDATED
    def set_LAST_DAY_UPDATED(self, LAST_DAY_UPDATED): self.LAST_DAY_UPDATED = LAST_DAY_UPDATED
    def get_ENTITY_ALIAS(self): return self.ENTITY_ALIAS
    def set_ENTITY_ALIAS(self, ENTITY_ALIAS): self.ENTITY_ALIAS = ENTITY_ALIAS
    def add_ENTITY_ALIAS(self, value): self.ENTITY_ALIAS.append(value)
    def insert_ENTITY_ALIAS_at(self, index, value): self.ENTITY_ALIAS.insert(index, value)
    def replace_ENTITY_ALIAS_at(self, index, value): self.ENTITY_ALIAS[index] = value
    def get_ENTITY_ADDRESS(self): return self.ENTITY_ADDRESS
    def set_ENTITY_ADDRESS(self, ENTITY_ADDRESS): self.ENTITY_ADDRESS = ENTITY_ADDRESS
    def add_ENTITY_ADDRESS(self, value): self.ENTITY_ADDRESS.append(value)
    def insert_ENTITY_ADDRESS_at(self, index, value): self.ENTITY_ADDRESS.insert(index, value)
    def replace_ENTITY_ADDRESS_at(self, index, value): self.ENTITY_ADDRESS[index] = value
    def get_SORT_KEY(self): return self.SORT_KEY
    def set_SORT_KEY(self, SORT_KEY): self.SORT_KEY = SORT_KEY
    def get_SORT_KEY_LAST_MOD(self): return self.SORT_KEY_LAST_MOD
    def set_SORT_KEY_LAST_MOD(self, SORT_KEY_LAST_MOD): self.SORT_KEY_LAST_MOD = SORT_KEY_LAST_MOD
    def get_DELISTED_ON(self): return self.DELISTED_ON
    def set_DELISTED_ON(self, DELISTED_ON): self.DELISTED_ON = DELISTED_ON
    def hasContent_(self):
        if (
            self.DATAID is not None or
            self.VERSIONNUM is not None or
            self.FIRST_NAME is not None or
            self.UN_LIST_TYPE is not None or
            self.REFERENCE_NUMBER is not None or
            self.LISTED_ON is not None or
            self.SUBMITTED_ON is not None or
            self.NAME_ORIGINAL_SCRIPT is not None or
            self.COMMENTS1 is not None or
            self.LIST_TYPE is not None or
            self.LAST_DAY_UPDATED is not None or
            self.ENTITY_ALIAS or
            self.ENTITY_ADDRESS or
            self.SORT_KEY is not None or
            self.SORT_KEY_LAST_MOD is not None or
            self.DELISTED_ON is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ENTITY', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ENTITY')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ENTITY')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ENTITY', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ENTITY'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ENTITY', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.DATAID is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<DATAID>%s</DATAID>%s' % (self.gds_format_integer(self.DATAID, input_name='DATAID'), eol_))
        if self.VERSIONNUM is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<VERSIONNUM>%s</VERSIONNUM>%s' % (self.gds_format_integer(self.VERSIONNUM, input_name='VERSIONNUM'), eol_))
        if self.FIRST_NAME is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<FIRST_NAME>%s</FIRST_NAME>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.FIRST_NAME), input_name='FIRST_NAME')), eol_))
        if self.UN_LIST_TYPE is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<UN_LIST_TYPE>%s</UN_LIST_TYPE>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.UN_LIST_TYPE), input_name='UN_LIST_TYPE')), eol_))
        if self.REFERENCE_NUMBER is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<REFERENCE_NUMBER>%s</REFERENCE_NUMBER>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.REFERENCE_NUMBER), input_name='REFERENCE_NUMBER')), eol_))
        if self.LISTED_ON is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<LISTED_ON>%s</LISTED_ON>%s' % (self.gds_format_date(self.LISTED_ON, input_name='LISTED_ON'), eol_))
        if self.SUBMITTED_ON is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<SUBMITTED_ON>%s</SUBMITTED_ON>%s' % (self.gds_format_date(self.SUBMITTED_ON, input_name='SUBMITTED_ON'), eol_))
        if self.NAME_ORIGINAL_SCRIPT is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<NAME_ORIGINAL_SCRIPT>%s</NAME_ORIGINAL_SCRIPT>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.NAME_ORIGINAL_SCRIPT), input_name='NAME_ORIGINAL_SCRIPT')), eol_))
        if self.COMMENTS1 is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<COMMENTS1>%s</COMMENTS1>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.COMMENTS1), input_name='COMMENTS1')), eol_))
        if self.LIST_TYPE is not None:
            self.LIST_TYPE.export(outfile, level, namespace_, name_='LIST_TYPE', pretty_print=pretty_print)
        if self.LAST_DAY_UPDATED is not None:
            self.LAST_DAY_UPDATED.export(outfile, level, namespace_, name_='LAST_DAY_UPDATED', pretty_print=pretty_print)
        for ENTITY_ALIAS_ in self.ENTITY_ALIAS:
            ENTITY_ALIAS_.export(outfile, level, namespace_, name_='ENTITY_ALIAS', pretty_print=pretty_print)
        for ENTITY_ADDRESS_ in self.ENTITY_ADDRESS:
            ENTITY_ADDRESS_.export(outfile, level, namespace_, name_='ENTITY_ADDRESS', pretty_print=pretty_print)
        if self.SORT_KEY is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<SORT_KEY>%s</SORT_KEY>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.SORT_KEY), input_name='SORT_KEY')), eol_))
        if self.SORT_KEY_LAST_MOD is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<SORT_KEY_LAST_MOD>%s</SORT_KEY_LAST_MOD>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.SORT_KEY_LAST_MOD), input_name='SORT_KEY_LAST_MOD')), eol_))
        if self.DELISTED_ON is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<DELISTED_ON>%s</DELISTED_ON>%s' % (self.gds_format_date(self.DELISTED_ON, input_name='DELISTED_ON'), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'DATAID':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'DATAID')
            self.DATAID = ival_
        elif nodeName_ == 'VERSIONNUM':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'VERSIONNUM')
            self.VERSIONNUM = ival_
        elif nodeName_ == 'FIRST_NAME':
            FIRST_NAME_ = child_.text
            FIRST_NAME_ = self.gds_validate_string(FIRST_NAME_, node, 'FIRST_NAME')
            self.FIRST_NAME = FIRST_NAME_
        elif nodeName_ == 'UN_LIST_TYPE':
            UN_LIST_TYPE_ = child_.text
            UN_LIST_TYPE_ = self.gds_validate_string(UN_LIST_TYPE_, node, 'UN_LIST_TYPE')
            self.UN_LIST_TYPE = UN_LIST_TYPE_
        elif nodeName_ == 'REFERENCE_NUMBER':
            REFERENCE_NUMBER_ = child_.text
            REFERENCE_NUMBER_ = self.gds_validate_string(REFERENCE_NUMBER_, node, 'REFERENCE_NUMBER')
            self.REFERENCE_NUMBER = REFERENCE_NUMBER_
        elif nodeName_ == 'LISTED_ON':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.LISTED_ON = dval_
        elif nodeName_ == 'SUBMITTED_ON':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.SUBMITTED_ON = dval_
        elif nodeName_ == 'NAME_ORIGINAL_SCRIPT':
            NAME_ORIGINAL_SCRIPT_ = child_.text
            NAME_ORIGINAL_SCRIPT_ = self.gds_validate_string(NAME_ORIGINAL_SCRIPT_, node, 'NAME_ORIGINAL_SCRIPT')
            self.NAME_ORIGINAL_SCRIPT = NAME_ORIGINAL_SCRIPT_
        elif nodeName_ == 'COMMENTS1':
            COMMENTS1_ = child_.text
            COMMENTS1_ = self.gds_validate_string(COMMENTS1_, node, 'COMMENTS1')
            self.COMMENTS1 = COMMENTS1_
        elif nodeName_ == 'LIST_TYPE':
            obj_ = LIST_TYPE.factory()
            obj_.build(child_)
            self.LIST_TYPE = obj_
            obj_.original_tagname_ = 'LIST_TYPE'
        elif nodeName_ == 'LAST_DAY_UPDATED':
            obj_ = LAST_DAY_UPDATED.factory()
            obj_.build(child_)
            self.LAST_DAY_UPDATED = obj_
            obj_.original_tagname_ = 'LAST_DAY_UPDATED'
        elif nodeName_ == 'ENTITY_ALIAS':
            obj_ = ENTITY_ALIAS.factory()
            obj_.build(child_)
            self.ENTITY_ALIAS.append(obj_)
            obj_.original_tagname_ = 'ENTITY_ALIAS'
        elif nodeName_ == 'ENTITY_ADDRESS':
            obj_ = ENTITY_ADDRESS.factory()
            obj_.build(child_)
            self.ENTITY_ADDRESS.append(obj_)
            obj_.original_tagname_ = 'ENTITY_ADDRESS'
        elif nodeName_ == 'SORT_KEY':
            SORT_KEY_ = child_.text
            SORT_KEY_ = self.gds_validate_string(SORT_KEY_, node, 'SORT_KEY')
            self.SORT_KEY = SORT_KEY_
        elif nodeName_ == 'SORT_KEY_LAST_MOD':
            SORT_KEY_LAST_MOD_ = child_.text
            SORT_KEY_LAST_MOD_ = self.gds_validate_string(SORT_KEY_LAST_MOD_, node, 'SORT_KEY_LAST_MOD')
            self.SORT_KEY_LAST_MOD = SORT_KEY_LAST_MOD_
        elif nodeName_ == 'DELISTED_ON':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.DELISTED_ON = dval_
# end class ENTITY


class ENTITY_ALIAS(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, QUALITY=None, ALIAS_NAME=None):
        self.original_tagname_ = None
        self.QUALITY = QUALITY
        self.ALIAS_NAME = ALIAS_NAME
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ENTITY_ALIAS)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ENTITY_ALIAS.subclass:
            return ENTITY_ALIAS.subclass(*args_, **kwargs_)
        else:
            return ENTITY_ALIAS(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_QUALITY(self): return self.QUALITY
    def set_QUALITY(self, QUALITY): self.QUALITY = QUALITY
    def get_ALIAS_NAME(self): return self.ALIAS_NAME
    def set_ALIAS_NAME(self, ALIAS_NAME): self.ALIAS_NAME = ALIAS_NAME
    def hasContent_(self):
        if (
            self.QUALITY is not None or
            self.ALIAS_NAME is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ENTITY_ALIAS', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ENTITY_ALIAS')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ENTITY_ALIAS')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ENTITY_ALIAS', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ENTITY_ALIAS'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ENTITY_ALIAS', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.QUALITY is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<QUALITY>%s</QUALITY>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.QUALITY), input_name='QUALITY')), eol_))
        if self.ALIAS_NAME is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ALIAS_NAME>%s</ALIAS_NAME>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.ALIAS_NAME), input_name='ALIAS_NAME')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'QUALITY':
            QUALITY_ = child_.text
            QUALITY_ = self.gds_validate_string(QUALITY_, node, 'QUALITY')
            self.QUALITY = QUALITY_
        elif nodeName_ == 'ALIAS_NAME':
            ALIAS_NAME_ = child_.text
            ALIAS_NAME_ = self.gds_validate_string(ALIAS_NAME_, node, 'ALIAS_NAME')
            self.ALIAS_NAME = ALIAS_NAME_
# end class ENTITY_ALIAS


class ENTITY_ADDRESS(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, STREET=None, CITY=None, STATE_PROVINCE=None, ZIP_CODE=None, COUNTRY=None, NOTE=None):
        self.original_tagname_ = None
        self.STREET = STREET
        self.CITY = CITY
        self.STATE_PROVINCE = STATE_PROVINCE
        self.ZIP_CODE = ZIP_CODE
        self.COUNTRY = COUNTRY
        self.NOTE = NOTE
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ENTITY_ADDRESS)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ENTITY_ADDRESS.subclass:
            return ENTITY_ADDRESS.subclass(*args_, **kwargs_)
        else:
            return ENTITY_ADDRESS(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_STREET(self): return self.STREET
    def set_STREET(self, STREET): self.STREET = STREET
    def get_CITY(self): return self.CITY
    def set_CITY(self, CITY): self.CITY = CITY
    def get_STATE_PROVINCE(self): return self.STATE_PROVINCE
    def set_STATE_PROVINCE(self, STATE_PROVINCE): self.STATE_PROVINCE = STATE_PROVINCE
    def get_ZIP_CODE(self): return self.ZIP_CODE
    def set_ZIP_CODE(self, ZIP_CODE): self.ZIP_CODE = ZIP_CODE
    def get_COUNTRY(self): return self.COUNTRY
    def set_COUNTRY(self, COUNTRY): self.COUNTRY = COUNTRY
    def get_NOTE(self): return self.NOTE
    def set_NOTE(self, NOTE): self.NOTE = NOTE
    def hasContent_(self):
        if (
            self.STREET is not None or
            self.CITY is not None or
            self.STATE_PROVINCE is not None or
            self.ZIP_CODE is not None or
            self.COUNTRY is not None or
            self.NOTE is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ENTITY_ADDRESS', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ENTITY_ADDRESS')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ENTITY_ADDRESS')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ENTITY_ADDRESS', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ENTITY_ADDRESS'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ENTITY_ADDRESS', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.STREET is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<STREET>%s</STREET>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.STREET), input_name='STREET')), eol_))
        if self.CITY is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<CITY>%s</CITY>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.CITY), input_name='CITY')), eol_))
        if self.STATE_PROVINCE is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<STATE_PROVINCE>%s</STATE_PROVINCE>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.STATE_PROVINCE), input_name='STATE_PROVINCE')), eol_))
        if self.ZIP_CODE is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ZIP_CODE>%s</ZIP_CODE>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.ZIP_CODE), input_name='ZIP_CODE')), eol_))
        if self.COUNTRY is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<COUNTRY>%s</COUNTRY>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.COUNTRY), input_name='COUNTRY')), eol_))
        if self.NOTE is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<NOTE>%s</NOTE>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.NOTE), input_name='NOTE')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'STREET':
            STREET_ = child_.text
            STREET_ = self.gds_validate_string(STREET_, node, 'STREET')
            self.STREET = STREET_
        elif nodeName_ == 'CITY':
            CITY_ = child_.text
            CITY_ = self.gds_validate_string(CITY_, node, 'CITY')
            self.CITY = CITY_
        elif nodeName_ == 'STATE_PROVINCE':
            STATE_PROVINCE_ = child_.text
            STATE_PROVINCE_ = self.gds_validate_string(STATE_PROVINCE_, node, 'STATE_PROVINCE')
            self.STATE_PROVINCE = STATE_PROVINCE_
        elif nodeName_ == 'ZIP_CODE':
            ZIP_CODE_ = child_.text
            ZIP_CODE_ = self.gds_validate_string(ZIP_CODE_, node, 'ZIP_CODE')
            self.ZIP_CODE = ZIP_CODE_
        elif nodeName_ == 'COUNTRY':
            COUNTRY_ = child_.text
            COUNTRY_ = self.gds_validate_string(COUNTRY_, node, 'COUNTRY')
            self.COUNTRY = COUNTRY_
        elif nodeName_ == 'NOTE':
            NOTE_ = child_.text
            NOTE_ = self.gds_validate_string(NOTE_, node, 'NOTE')
            self.NOTE = NOTE_
# end class ENTITY_ADDRESS


class LIST_TYPE(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, VALUE=None):
        self.original_tagname_ = None
        self.VALUE = VALUE
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, LIST_TYPE)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LIST_TYPE.subclass:
            return LIST_TYPE.subclass(*args_, **kwargs_)
        else:
            return LIST_TYPE(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_VALUE(self): return self.VALUE
    def set_VALUE(self, VALUE): self.VALUE = VALUE
    def hasContent_(self):
        if (
            self.VALUE is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='LIST_TYPE', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('LIST_TYPE')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LIST_TYPE')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='LIST_TYPE', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='LIST_TYPE'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='LIST_TYPE', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.VALUE is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<VALUE>%s</VALUE>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.VALUE), input_name='VALUE')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'VALUE':
            VALUE_ = child_.text
            VALUE_ = self.gds_validate_string(VALUE_, node, 'VALUE')
            self.VALUE = VALUE_
# end class LIST_TYPE


class LAST_DAY_UPDATED(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, VALUE=None):
        self.original_tagname_ = None
        if VALUE is None:
            self.VALUE = []
        else:
            self.VALUE = VALUE
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, LAST_DAY_UPDATED)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LAST_DAY_UPDATED.subclass:
            return LAST_DAY_UPDATED.subclass(*args_, **kwargs_)
        else:
            return LAST_DAY_UPDATED(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_VALUE(self): return self.VALUE
    def set_VALUE(self, VALUE): self.VALUE = VALUE
    def add_VALUE(self, value): self.VALUE.append(value)
    def insert_VALUE_at(self, index, value): self.VALUE.insert(index, value)
    def replace_VALUE_at(self, index, value): self.VALUE[index] = value
    def hasContent_(self):
        if (
            self.VALUE
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='LAST_DAY_UPDATED', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('LAST_DAY_UPDATED')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LAST_DAY_UPDATED')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='LAST_DAY_UPDATED', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='LAST_DAY_UPDATED'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='LAST_DAY_UPDATED', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for VALUE_ in self.VALUE:
            showIndent(outfile, level, pretty_print)
            outfile.write('<VALUE>%s</VALUE>%s' % (self.gds_encode(self.gds_format_string(quote_xml(VALUE_), input_name='VALUE')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'VALUE':
            VALUE_ = child_.text
            VALUE_ = self.gds_validate_string(VALUE_, node, 'VALUE')
            self.VALUE.append(VALUE_)
# end class LAST_DAY_UPDATED


GDSClassesMapping = {
}


USAGE_TEXT = """
Usage: python <Parser>.py [ -s ] <in_xml_file>
"""


def usage():
    print(USAGE_TEXT)
    sys.exit(1)


def get_root_tag(node):
    tag = Tag_pattern_.match(node.tag).groups()[-1]
    rootClass = GDSClassesMapping.get(tag)
    if rootClass is None:
        rootClass = globals().get(tag)
    return tag, rootClass


def parse(inFileName, silence=False):
    parser = None
    doc = parsexml_(inFileName, parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'CONSOLIDATED_LIST'
        rootClass = CONSOLIDATED_LIST
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    if not silence:
        sys.stdout.write('<?xml version="1.0" ?>\n')
        rootObj.export(
            sys.stdout, 0, name_=rootTag,
            namespacedef_='',
            pretty_print=True)
    return rootObj


def parseEtree(inFileName, silence=False):
    parser = None
    doc = parsexml_(inFileName, parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'CONSOLIDATED_LIST'
        rootClass = CONSOLIDATED_LIST
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    mapping = {}
    rootElement = rootObj.to_etree(None, name_=rootTag, mapping_=mapping)
    reverse_mapping = rootObj.gds_reverse_node_mapping(mapping)
    if not silence:
        content = etree_.tostring(
            rootElement, pretty_print=True,
            xml_declaration=True, encoding="utf-8")
        sys.stdout.write(content)
        sys.stdout.write('\n')
    return rootObj, rootElement, mapping, reverse_mapping


def parseString(inString, silence=False):
    '''Parse a string, create the object tree, and export it.

    Arguments:
    - inString -- A string.  This XML fragment should not start
      with an XML declaration containing an encoding.
    - silence -- A boolean.  If False, export the object.
    Returns -- The root object in the tree.
    '''
    parser = None
    rootNode= parsexmlstring_(inString, parser)
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'CONSOLIDATED_LIST'
        rootClass = CONSOLIDATED_LIST
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    if not silence:
        sys.stdout.write('<?xml version="1.0" ?>\n')
        rootObj.export(
            sys.stdout, 0, name_=rootTag,
            namespacedef_='')
    return rootObj


def parseLiteral(inFileName, silence=False):
    parser = None
    doc = parsexml_(inFileName, parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'CONSOLIDATED_LIST'
        rootClass = CONSOLIDATED_LIST
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    if not silence:
        sys.stdout.write('#from un_global import *\n\n')
        sys.stdout.write('import un_global as model_\n\n')
        sys.stdout.write('rootObj = model_.rootClass(\n')
        rootObj.exportLiteral(sys.stdout, 0, name_=rootTag)
        sys.stdout.write(')\n')
    return rootObj


def main():
    args = sys.argv[1:]
    if len(args) == 1:
        parse(args[0])
    else:
        usage()


if __name__ == '__main__':
    #import pdb; pdb.set_trace()
    main()


__all__ = [
    "CONSOLIDATED_LIST",
    "DESIGNATION",
    "ENTITIES",
    "ENTITY",
    "ENTITY_ADDRESS",
    "ENTITY_ALIAS",
    "FROM_YEAR",
    "INDIVIDUAL",
    "INDIVIDUALS",
    "INDIVIDUAL_ADDRESS",
    "INDIVIDUAL_ALIAS",
    "INDIVIDUAL_DATE_OF_BIRTH",
    "INDIVIDUAL_DOCUMENT",
    "INDIVIDUAL_PLACE_OF_BIRTH",
    "LAST_DAY_UPDATED",
    "LIST_TYPE",
    "NATIONALITY",
    "TITLE",
    "TO_YEAR",
    "YEAR"
]
