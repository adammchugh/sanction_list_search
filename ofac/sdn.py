#!/usr/bin/env python
# -*- coding: utf-8 -*-

#
# Generated Sun May 27 20:05:59 2018 by generateDS.py version 2.29.14.
# Python 3.6.5 (default, Apr  1 2018, 05:46:30)  [GCC 7.3.0]
#
# Command line options:
#   ('-o', 'sdn.py')
#   ('-s', 'sdnsubs.py')
#
# Command line arguments:
#   sdn_advanced.xsd
#
# Command line:
#   generateDS.py -o "sdn.py" -s "sdnsubs.py" sdn_advanced.xsd
#
# Current working directory (os.getcwd()):
#   consolidated_ofac_list
#

import sys
import re as re_
import base64
import datetime as datetime_
import warnings as warnings_
try:
    from lxml import etree as etree_
except ImportError:
    from xml.etree import ElementTree as etree_


Validate_simpletypes_ = True
if sys.version_info.major == 2:
    BaseStrType_ = basestring
else:
    BaseStrType_ = str


def parsexml_(infile, parser=None, **kwargs):
    if parser is None:
        # Use the lxml ElementTree compatible parser so that, e.g.,
        #   we ignore comments.
        try:
            parser = etree_.ETCompatXMLParser()
        except AttributeError:
            # fallback to xml.etree
            parser = etree_.XMLParser()
    doc = etree_.parse(infile, parser=parser, **kwargs)
    return doc

def parsexmlstring_(instring, parser=None, **kwargs):
    if parser is None:
        # Use the lxml ElementTree compatible parser so that, e.g.,
        #   we ignore comments.
        try:
            parser = etree_.ETCompatXMLParser()
        except AttributeError:
            # fallback to xml.etree
            parser = etree_.XMLParser()
    element = etree_.fromstring(instring, parser=parser, **kwargs)
    return element

#
# Namespace prefix definition table (and other attributes, too)
#
# The module generatedsnamespaces, if it is importable, must contain
# a dictionary named GeneratedsNamespaceDefs.  This Python dictionary
# should map element type names (strings) to XML schema namespace prefix
# definitions.  The export method for any class for which there is
# a namespace prefix definition, will export that definition in the
# XML representation of that element.  See the export method of
# any generated element type class for a example of the use of this
# table.
# A sample table is:
#
#     # File: generatedsnamespaces.py
#
#     GenerateDSNamespaceDefs = {
#         "ElementtypeA": "http://www.xxx.com/namespaceA",
#         "ElementtypeB": "http://www.xxx.com/namespaceB",
#     }
#

try:
    from generatedsnamespaces import GenerateDSNamespaceDefs as GenerateDSNamespaceDefs_
except ImportError:
    GenerateDSNamespaceDefs_ = {}

#
# The root super-class for element type classes
#
# Calls to the methods in these classes are generated by generateDS.py.
# You can replace these methods by re-implementing the following class
#   in a module named generatedssuper.py.

try:
    from generatedssuper import GeneratedsSuper
except ImportError as exp:
    
    class GeneratedsSuper(object):
        tzoff_pattern = re_.compile(r'(\+|-)((0\d|1[0-3]):[0-5]\d|14:00)$')
        class _FixedOffsetTZ(datetime_.tzinfo):
            def __init__(self, offset, name):
                self.__offset = datetime_.timedelta(minutes=offset)
                self.__name = name
            def utcoffset(self, dt):
                return self.__offset
            def tzname(self, dt):
                return self.__name
            def dst(self, dt):
                return None
        def gds_format_string(self, input_data, input_name=''):
            return input_data
        def gds_validate_string(self, input_data, node=None, input_name=''):
            if not input_data:
                return ''
            else:
                return input_data
        def gds_format_base64(self, input_data, input_name=''):
            return base64.b64encode(input_data)
        def gds_validate_base64(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_integer(self, input_data, input_name=''):
            return '%d' % input_data
        def gds_validate_integer(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_integer_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_integer_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    int(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of integers')
            return values
        def gds_format_float(self, input_data, input_name=''):
            return ('%.15f' % input_data).rstrip('0')
        def gds_validate_float(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_float_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_float_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of floats')
            return values
        def gds_format_double(self, input_data, input_name=''):
            return '%e' % input_data
        def gds_validate_double(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_double_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_double_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of doubles')
            return values
        def gds_format_boolean(self, input_data, input_name=''):
            return ('%s' % input_data).lower()
        def gds_validate_boolean(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_boolean_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_boolean_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                if value not in ('true', '1', 'false', '0', ):
                    raise_parse_error(
                        node,
                        'Requires sequence of booleans '
                        '("true", "1", "false", "0")')
            return values
        def gds_validate_datetime(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_datetime(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d.%s' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        @classmethod
        def gds_parse_datetime(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            time_parts = input_data.split('.')
            if len(time_parts) > 1:
                micro_seconds = int(float('0.' + time_parts[1]) * 1000000)
                input_data = '%s.%s' % (time_parts[0], micro_seconds, )
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt
        def gds_validate_date(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_date(self, input_data, input_name=''):
            _svalue = '%04d-%02d-%02d' % (
                input_data.year,
                input_data.month,
                input_data.day,
            )
            try:
                if input_data.tzinfo is not None:
                    tzoff = input_data.tzinfo.utcoffset(input_data)
                    if tzoff is not None:
                        total_seconds = tzoff.seconds + (86400 * tzoff.days)
                        if total_seconds == 0:
                            _svalue += 'Z'
                        else:
                            if total_seconds < 0:
                                _svalue += '-'
                                total_seconds *= -1
                            else:
                                _svalue += '+'
                            hours = total_seconds // 3600
                            minutes = (total_seconds - (hours * 3600)) // 60
                            _svalue += '{0:02d}:{1:02d}'.format(
                                hours, minutes)
            except AttributeError:
                pass
            return _svalue
        @classmethod
        def gds_parse_date(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            dt = datetime_.datetime.strptime(input_data, '%Y-%m-%d')
            dt = dt.replace(tzinfo=tz)
            return dt.date()
        def gds_validate_time(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_time(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%02d:%02d:%02d' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%02d:%02d:%02d.%s' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        def gds_validate_simple_patterns(self, patterns, target):
            # pat is a list of lists of strings/patterns.  We should:
            # - AND the outer elements
            # - OR the inner elements
            found1 = True
            for patterns1 in patterns:
                found2 = False
                for patterns2 in patterns1:
                    if re_.search(patterns2, target) is not None:
                        found2 = True
                        break
                if not found2:
                    found1 = False
                    break
            return found1
        @classmethod
        def gds_parse_time(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            if len(input_data.split('.')) > 1:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt.time()
        def gds_str_lower(self, instring):
            return instring.lower()
        def get_path_(self, node):
            path_list = []
            self.get_path_list_(node, path_list)
            path_list.reverse()
            path = '/'.join(path_list)
            return path
        Tag_strip_pattern_ = re_.compile(r'\{.*\}')
        def get_path_list_(self, node, path_list):
            if node is None:
                return
            tag = GeneratedsSuper.Tag_strip_pattern_.sub('', node.tag)
            if tag:
                path_list.append(tag)
            self.get_path_list_(node.getparent(), path_list)
        def get_class_obj_(self, node, default_class=None):
            class_obj1 = default_class
            if 'xsi' in node.nsmap:
                classname = node.get('{%s}type' % node.nsmap['xsi'])
                if classname is not None:
                    names = classname.split(':')
                    if len(names) == 2:
                        classname = names[1]
                    class_obj2 = globals().get(classname)
                    if class_obj2 is not None:
                        class_obj1 = class_obj2
            return class_obj1
        def gds_build_any(self, node, type_name=None):
            return None
        @classmethod
        def gds_reverse_node_mapping(cls, mapping):
            return dict(((v, k) for k, v in mapping.iteritems()))
        @staticmethod
        def gds_encode(instring):
            if sys.version_info.major == 2:
                return instring.encode(ExternalEncoding)
            else:
                return instring
        @staticmethod
        def convert_unicode(instring):
            if isinstance(instring, str):
                result = quote_xml(instring)
            elif sys.version_info.major == 2 and isinstance(instring, unicode):
                result = quote_xml(instring).encode('utf8')
            else:
                result = GeneratedsSuper.gds_encode(str(instring))
            return result
        def __eq__(self, other):
            if type(self) != type(other):
                return False
            return self.__dict__ == other.__dict__
        def __ne__(self, other):
            return not self.__eq__(other)
    
    def getSubclassFromModule_(module, class_):
        '''Get the subclass of a class from a specific module.'''
        name = class_.__name__ + 'Sub'
        if hasattr(module, name):
            return getattr(module, name)
        else:
            return None


#
# If you have installed IPython you can uncomment and use the following.
# IPython is available from http://ipython.scipy.org/.
#

## from IPython.Shell import IPShellEmbed
## args = ''
## ipshell = IPShellEmbed(args,
##     banner = 'Dropping into IPython',
##     exit_msg = 'Leaving Interpreter, back to program.')

# Then use the following line where and when you want to drop into the
# IPython shell:
#    ipshell('<some message> -- Entering ipshell.\nHit Ctrl-D to exit')

#
# Globals
#

ExternalEncoding = 'utf-8'
Tag_pattern_ = re_.compile(r'({.*})?(.*)')
String_cleanup_pat_ = re_.compile(r"[\n\r\s]+")
Namespace_extract_pat_ = re_.compile(r'{(.*)}(.*)')
CDATA_pattern_ = re_.compile(r"<!\[CDATA\[.*?\]\]>", re_.DOTALL)

# Change this to redirect the generated superclass module to use a
# specific subclass module.
CurrentSubclassModule_ = None

#
# Support/utility functions.
#


def showIndent(outfile, level, pretty_print=True):
    if pretty_print:
        for idx in range(level):
            outfile.write('    ')


def quote_xml(inStr):
    "Escape markup chars, but do not modify CDATA sections."
    if not inStr:
        return ''
    s1 = (isinstance(inStr, BaseStrType_) and inStr or '%s' % inStr)
    s2 = ''
    pos = 0
    matchobjects = CDATA_pattern_.finditer(s1)
    for mo in matchobjects:
        s3 = s1[pos:mo.start()]
        s2 += quote_xml_aux(s3)
        s2 += s1[mo.start():mo.end()]
        pos = mo.end()
    s3 = s1[pos:]
    s2 += quote_xml_aux(s3)
    return s2


def quote_xml_aux(inStr):
    s1 = inStr.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    return s1


def quote_attrib(inStr):
    s1 = (isinstance(inStr, BaseStrType_) and inStr or '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    if '"' in s1:
        if "'" in s1:
            s1 = '"%s"' % s1.replace('"', "&quot;")
        else:
            s1 = "'%s'" % s1
    else:
        s1 = '"%s"' % s1
    return s1


def quote_python(inStr):
    s1 = inStr
    if s1.find("'") == -1:
        if s1.find('\n') == -1:
            return "'%s'" % s1
        else:
            return "'''%s'''" % s1
    else:
        if s1.find('"') != -1:
            s1 = s1.replace('"', '\\"')
        if s1.find('\n') == -1:
            return '"%s"' % s1
        else:
            return '"""%s"""' % s1


def get_all_text_(node):
    if node.text is not None:
        text = node.text
    else:
        text = ''
    for child in node:
        if child.tail is not None:
            text += child.tail
    return text


def find_attr_value_(attr_name, node):
    attrs = node.attrib
    attr_parts = attr_name.split(':')
    value = None
    if len(attr_parts) == 1:
        value = attrs.get(attr_name)
    elif len(attr_parts) == 2:
        prefix, name = attr_parts
        namespace = node.nsmap.get(prefix)
        if namespace is not None:
            value = attrs.get('{%s}%s' % (namespace, name, ))
    return value


class GDSParseError(Exception):
    pass


def raise_parse_error(node, msg):
    msg = '%s (element %s/line %d)' % (msg, node.tag, node.sourceline, )
    raise GDSParseError(msg)


class MixedContainer:
    # Constants for category:
    CategoryNone = 0
    CategoryText = 1
    CategorySimple = 2
    CategoryComplex = 3
    # Constants for content_type:
    TypeNone = 0
    TypeText = 1
    TypeString = 2
    TypeInteger = 3
    TypeFloat = 4
    TypeDecimal = 5
    TypeDouble = 6
    TypeBoolean = 7
    TypeBase64 = 8
    def __init__(self, category, content_type, name, value):
        self.category = category
        self.content_type = content_type
        self.name = name
        self.value = value
    def getCategory(self):
        return self.category
    def getContenttype(self, content_type):
        return self.content_type
    def getValue(self):
        return self.value
    def getName(self):
        return self.name
    def export(self, outfile, level, name, namespace,
               pretty_print=True):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                outfile.write(self.value)
        elif self.category == MixedContainer.CategorySimple:
            self.exportSimple(outfile, level, name)
        else:    # category == MixedContainer.CategoryComplex
            self.value.export(
                outfile, level, namespace, name,
                pretty_print=pretty_print)
    def exportSimple(self, outfile, level, name):
        if self.content_type == MixedContainer.TypeString:
            outfile.write('<%s>%s</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeInteger or \
                self.content_type == MixedContainer.TypeBoolean:
            outfile.write('<%s>%d</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeFloat or \
                self.content_type == MixedContainer.TypeDecimal:
            outfile.write('<%s>%f</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeDouble:
            outfile.write('<%s>%g</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeBase64:
            outfile.write('<%s>%s</%s>' % (
                self.name,
                base64.b64encode(self.value),
                self.name))
    def to_etree(self, element):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                if len(element) > 0:
                    if element[-1].tail is None:
                        element[-1].tail = self.value
                    else:
                        element[-1].tail += self.value
                else:
                    if element.text is None:
                        element.text = self.value
                    else:
                        element.text += self.value
        elif self.category == MixedContainer.CategorySimple:
            subelement = etree_.SubElement(
                element, '%s' % self.name)
            subelement.text = self.to_etree_simple()
        else:    # category == MixedContainer.CategoryComplex
            self.value.to_etree(element)
    def to_etree_simple(self):
        if self.content_type == MixedContainer.TypeString:
            text = self.value
        elif (self.content_type == MixedContainer.TypeInteger or
                self.content_type == MixedContainer.TypeBoolean):
            text = '%d' % self.value
        elif (self.content_type == MixedContainer.TypeFloat or
                self.content_type == MixedContainer.TypeDecimal):
            text = '%f' % self.value
        elif self.content_type == MixedContainer.TypeDouble:
            text = '%g' % self.value
        elif self.content_type == MixedContainer.TypeBase64:
            text = '%s' % base64.b64encode(self.value)
        return text
    def exportLiteral(self, outfile, level, name):
        if self.category == MixedContainer.CategoryText:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type,
                    self.name, self.value))
        elif self.category == MixedContainer.CategorySimple:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type,
                    self.name, self.value))
        else:    # category == MixedContainer.CategoryComplex
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s",\n' % (
                    self.category, self.content_type, self.name,))
            self.value.exportLiteral(outfile, level + 1)
            showIndent(outfile, level)
            outfile.write(')\n')


class MemberSpec_(object):
    def __init__(self, name='', data_type='', container=0,
            optional=0, child_attrs=None, choice=None):
        self.name = name
        self.data_type = data_type
        self.container = container
        self.child_attrs = child_attrs
        self.choice = choice
        self.optional = optional
    def set_name(self, name): self.name = name
    def get_name(self): return self.name
    def set_data_type(self, data_type): self.data_type = data_type
    def get_data_type_chain(self): return self.data_type
    def get_data_type(self):
        if isinstance(self.data_type, list):
            if len(self.data_type) > 0:
                return self.data_type[-1]
            else:
                return 'xs:string'
        else:
            return self.data_type
    def set_container(self, container): self.container = container
    def get_container(self): return self.container
    def set_child_attrs(self, child_attrs): self.child_attrs = child_attrs
    def get_child_attrs(self): return self.child_attrs
    def set_choice(self, choice): self.choice = choice
    def get_choice(self): return self.choice
    def set_optional(self, optional): self.optional = optional
    def get_optional(self): return self.optional


def _cast(typ, value):
    if typ is None or value is None:
        return value
    return typ(value)

#
# Data representation classes.
#


class Sanctions(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Version=None, DeltaBaseVersion=None, DateOfIssue=None, ReferenceValueSets=None, Locations=None, IDRegDocuments=None, DistinctParties=None, ProfileRelationships=None, SanctionsEntries=None, SanctionsEntryLinks=None):
        self.original_tagname_ = None
        self.Version = _cast(int, Version)
        self.DeltaBaseVersion = _cast(int, DeltaBaseVersion)
        self.DateOfIssue = DateOfIssue
        self.ReferenceValueSets = ReferenceValueSets
        self.Locations = Locations
        self.IDRegDocuments = IDRegDocuments
        self.DistinctParties = DistinctParties
        self.ProfileRelationships = ProfileRelationships
        self.SanctionsEntries = SanctionsEntries
        self.SanctionsEntryLinks = SanctionsEntryLinks
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Sanctions)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Sanctions.subclass:
            return Sanctions.subclass(*args_, **kwargs_)
        else:
            return Sanctions(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_DateOfIssue(self): return self.DateOfIssue
    def set_DateOfIssue(self, DateOfIssue): self.DateOfIssue = DateOfIssue
    def get_ReferenceValueSets(self): return self.ReferenceValueSets
    def set_ReferenceValueSets(self, ReferenceValueSets): self.ReferenceValueSets = ReferenceValueSets
    def get_Locations(self): return self.Locations
    def set_Locations(self, Locations): self.Locations = Locations
    def get_IDRegDocuments(self): return self.IDRegDocuments
    def set_IDRegDocuments(self, IDRegDocuments): self.IDRegDocuments = IDRegDocuments
    def get_DistinctParties(self): return self.DistinctParties
    def set_DistinctParties(self, DistinctParties): self.DistinctParties = DistinctParties
    def get_ProfileRelationships(self): return self.ProfileRelationships
    def set_ProfileRelationships(self, ProfileRelationships): self.ProfileRelationships = ProfileRelationships
    def get_SanctionsEntries(self): return self.SanctionsEntries
    def set_SanctionsEntries(self, SanctionsEntries): self.SanctionsEntries = SanctionsEntries
    def get_SanctionsEntryLinks(self): return self.SanctionsEntryLinks
    def set_SanctionsEntryLinks(self, SanctionsEntryLinks): self.SanctionsEntryLinks = SanctionsEntryLinks
    def get_Version(self): return self.Version
    def set_Version(self, Version): self.Version = Version
    def get_DeltaBaseVersion(self): return self.DeltaBaseVersion
    def set_DeltaBaseVersion(self, DeltaBaseVersion): self.DeltaBaseVersion = DeltaBaseVersion
    def hasContent_(self):
        if (
            self.DateOfIssue is not None or
            self.ReferenceValueSets is not None or
            self.Locations is not None or
            self.IDRegDocuments is not None or
            self.DistinctParties is not None or
            self.ProfileRelationships is not None or
            self.SanctionsEntries is not None or
            self.SanctionsEntryLinks is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='un:', name_='Sanctions', namespacedef_='xmlns:un="http://www.un.org/sanctions/1.0"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Sanctions')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Sanctions')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='un:', name_='Sanctions', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='un:', name_='Sanctions'):
        if self.Version is not None and 'Version' not in already_processed:
            already_processed.add('Version')
            outfile.write(' Version="%s"' % self.gds_format_integer(self.Version, input_name='Version'))
        if self.DeltaBaseVersion is not None and 'DeltaBaseVersion' not in already_processed:
            already_processed.add('DeltaBaseVersion')
            outfile.write(' DeltaBaseVersion="%s"' % self.gds_format_integer(self.DeltaBaseVersion, input_name='DeltaBaseVersion'))
    def exportChildren(self, outfile, level, namespace_='un:', name_='Sanctions', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.DateOfIssue is not None:
            self.DateOfIssue.export(outfile, level, namespace_, name_='DateOfIssue', pretty_print=pretty_print)
        if self.ReferenceValueSets is not None:
            self.ReferenceValueSets.export(outfile, level, namespace_, name_='ReferenceValueSets', pretty_print=pretty_print)
        if self.Locations is not None:
            self.Locations.export(outfile, level, namespace_, name_='Locations', pretty_print=pretty_print)
        if self.IDRegDocuments is not None:
            self.IDRegDocuments.export(outfile, level, namespace_, name_='IDRegDocuments', pretty_print=pretty_print)
        if self.DistinctParties is not None:
            self.DistinctParties.export(outfile, level, namespace_, name_='DistinctParties', pretty_print=pretty_print)
        if self.ProfileRelationships is not None:
            self.ProfileRelationships.export(outfile, level, namespace_, name_='ProfileRelationships', pretty_print=pretty_print)
        if self.SanctionsEntries is not None:
            self.SanctionsEntries.export(outfile, level, namespace_, name_='SanctionsEntries', pretty_print=pretty_print)
        if self.SanctionsEntryLinks is not None:
            self.SanctionsEntryLinks.export(outfile, level, namespace_, name_='SanctionsEntryLinks', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Version', node)
        if value is not None and 'Version' not in already_processed:
            already_processed.add('Version')
            try:
                self.Version = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.Version < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = find_attr_value_('DeltaBaseVersion', node)
        if value is not None and 'DeltaBaseVersion' not in already_processed:
            already_processed.add('DeltaBaseVersion')
            try:
                self.DeltaBaseVersion = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.DeltaBaseVersion < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'DateOfIssue':
            obj_ = DateSchemaType.factory()
            obj_.build(child_)
            self.DateOfIssue = obj_
            obj_.original_tagname_ = 'DateOfIssue'
        elif nodeName_ == 'ReferenceValueSets':
            obj_ = ReferenceValueSetsSchemaType.factory()
            obj_.build(child_)
            self.ReferenceValueSets = obj_
            obj_.original_tagname_ = 'ReferenceValueSets'
        elif nodeName_ == 'Locations':
            obj_ = LocationsType.factory()
            obj_.build(child_)
            self.Locations = obj_
            obj_.original_tagname_ = 'Locations'
        elif nodeName_ == 'IDRegDocuments':
            obj_ = IDRegDocumentsType.factory()
            obj_.build(child_)
            self.IDRegDocuments = obj_
            obj_.original_tagname_ = 'IDRegDocuments'
        elif nodeName_ == 'DistinctParties':
            obj_ = DistinctPartiesType.factory()
            obj_.build(child_)
            self.DistinctParties = obj_
            obj_.original_tagname_ = 'DistinctParties'
        elif nodeName_ == 'ProfileRelationships':
            obj_ = ProfileRelationshipsType.factory()
            obj_.build(child_)
            self.ProfileRelationships = obj_
            obj_.original_tagname_ = 'ProfileRelationships'
        elif nodeName_ == 'SanctionsEntries':
            obj_ = SanctionsEntriesType.factory()
            obj_.build(child_)
            self.SanctionsEntries = obj_
            obj_.original_tagname_ = 'SanctionsEntries'
        elif nodeName_ == 'SanctionsEntryLinks':
            obj_ = SanctionsEntryLinksType.factory()
            obj_.build(child_)
            self.SanctionsEntryLinks = obj_
            obj_.original_tagname_ = 'SanctionsEntryLinks'
# end class Sanctions


class Comment(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, DeltaAction=None, valueOf_=None):
        self.original_tagname_ = None
        self.DeltaAction = _cast(None, DeltaAction)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Comment)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Comment.subclass:
            return Comment.subclass(*args_, **kwargs_)
        else:
            return Comment(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_DeltaAction(self): return self.DeltaAction
    def set_DeltaAction(self, DeltaAction): self.DeltaAction = DeltaAction
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_DeltaActionSchemaType(self, value):
        # Validate type DeltaActionSchemaType, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['add', 'amend', 'delete', 'revise']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on DeltaActionSchemaType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='un:', name_='Comment', namespacedef_='xmlns:un="http://www.un.org/sanctions/1.0"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Comment')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Comment')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='un:', name_='Comment', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='un:', name_='Comment'):
        if self.DeltaAction is not None and 'DeltaAction' not in already_processed:
            already_processed.add('DeltaAction')
            outfile.write(' DeltaAction=%s' % (quote_attrib(self.DeltaAction), ))
    def exportChildren(self, outfile, level, namespace_='un:', name_='Comment', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('DeltaAction', node)
        if value is not None and 'DeltaAction' not in already_processed:
            already_processed.add('DeltaAction')
            self.DeltaAction = value
            self.validate_DeltaActionSchemaType(self.DeltaAction)    # validate type DeltaActionSchemaType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class Comment


class FeatureVersionReference(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, FeatureVersionID=None, DeltaAction=None):
        self.original_tagname_ = None
        self.FeatureVersionID = _cast(int, FeatureVersionID)
        self.DeltaAction = _cast(None, DeltaAction)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FeatureVersionReference)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FeatureVersionReference.subclass:
            return FeatureVersionReference.subclass(*args_, **kwargs_)
        else:
            return FeatureVersionReference(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_FeatureVersionID(self): return self.FeatureVersionID
    def set_FeatureVersionID(self, FeatureVersionID): self.FeatureVersionID = FeatureVersionID
    def get_DeltaAction(self): return self.DeltaAction
    def set_DeltaAction(self, DeltaAction): self.DeltaAction = DeltaAction
    def validate_DeltaActionSchemaType(self, value):
        # Validate type DeltaActionSchemaType, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['add', 'amend', 'delete', 'revise']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on DeltaActionSchemaType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='un:', name_='FeatureVersionReference', namespacedef_='xmlns:un="http://www.un.org/sanctions/1.0"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('FeatureVersionReference')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FeatureVersionReference')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='un:', name_='FeatureVersionReference', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='un:', name_='FeatureVersionReference'):
        if self.FeatureVersionID is not None and 'FeatureVersionID' not in already_processed:
            already_processed.add('FeatureVersionID')
            outfile.write(' FeatureVersionID="%s"' % self.gds_format_integer(self.FeatureVersionID, input_name='FeatureVersionID'))
        if self.DeltaAction is not None and 'DeltaAction' not in already_processed:
            already_processed.add('DeltaAction')
            outfile.write(' DeltaAction=%s' % (quote_attrib(self.DeltaAction), ))
    def exportChildren(self, outfile, level, namespace_='un:', name_='FeatureVersionReference', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('FeatureVersionID', node)
        if value is not None and 'FeatureVersionID' not in already_processed:
            already_processed.add('FeatureVersionID')
            try:
                self.FeatureVersionID = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.FeatureVersionID < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = find_attr_value_('DeltaAction', node)
        if value is not None and 'DeltaAction' not in already_processed:
            already_processed.add('DeltaAction')
            self.DeltaAction = value
            self.validate_DeltaActionSchemaType(self.DeltaAction)    # validate type DeltaActionSchemaType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class FeatureVersionReference


class IDRegDocumentReference(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, IDRegDocumentID=None, DeltaAction=None):
        self.original_tagname_ = None
        self.IDRegDocumentID = _cast(int, IDRegDocumentID)
        self.DeltaAction = _cast(None, DeltaAction)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, IDRegDocumentReference)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if IDRegDocumentReference.subclass:
            return IDRegDocumentReference.subclass(*args_, **kwargs_)
        else:
            return IDRegDocumentReference(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_IDRegDocumentID(self): return self.IDRegDocumentID
    def set_IDRegDocumentID(self, IDRegDocumentID): self.IDRegDocumentID = IDRegDocumentID
    def get_DeltaAction(self): return self.DeltaAction
    def set_DeltaAction(self, DeltaAction): self.DeltaAction = DeltaAction
    def validate_DeltaActionSchemaType(self, value):
        # Validate type DeltaActionSchemaType, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['add', 'amend', 'delete', 'revise']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on DeltaActionSchemaType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='un:', name_='IDRegDocumentReference', namespacedef_='xmlns:un="http://www.un.org/sanctions/1.0"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('IDRegDocumentReference')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='IDRegDocumentReference')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='un:', name_='IDRegDocumentReference', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='un:', name_='IDRegDocumentReference'):
        if self.IDRegDocumentID is not None and 'IDRegDocumentID' not in already_processed:
            already_processed.add('IDRegDocumentID')
            outfile.write(' IDRegDocumentID="%s"' % self.gds_format_integer(self.IDRegDocumentID, input_name='IDRegDocumentID'))
        if self.DeltaAction is not None and 'DeltaAction' not in already_processed:
            already_processed.add('DeltaAction')
            outfile.write(' DeltaAction=%s' % (quote_attrib(self.DeltaAction), ))
    def exportChildren(self, outfile, level, namespace_='un:', name_='IDRegDocumentReference', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('IDRegDocumentID', node)
        if value is not None and 'IDRegDocumentID' not in already_processed:
            already_processed.add('IDRegDocumentID')
            try:
                self.IDRegDocumentID = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.IDRegDocumentID < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = find_attr_value_('DeltaAction', node)
        if value is not None and 'DeltaAction' not in already_processed:
            already_processed.add('DeltaAction')
            self.DeltaAction = value
            self.validate_DeltaActionSchemaType(self.DeltaAction)    # validate type DeltaActionSchemaType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class IDRegDocumentReference


class ProfileRelationshipReference(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ProfileRelationshipID=None, DeltaAction=None):
        self.original_tagname_ = None
        self.ProfileRelationshipID = _cast(int, ProfileRelationshipID)
        self.DeltaAction = _cast(None, DeltaAction)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ProfileRelationshipReference)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ProfileRelationshipReference.subclass:
            return ProfileRelationshipReference.subclass(*args_, **kwargs_)
        else:
            return ProfileRelationshipReference(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ProfileRelationshipID(self): return self.ProfileRelationshipID
    def set_ProfileRelationshipID(self, ProfileRelationshipID): self.ProfileRelationshipID = ProfileRelationshipID
    def get_DeltaAction(self): return self.DeltaAction
    def set_DeltaAction(self, DeltaAction): self.DeltaAction = DeltaAction
    def validate_DeltaActionSchemaType(self, value):
        # Validate type DeltaActionSchemaType, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['add', 'amend', 'delete', 'revise']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on DeltaActionSchemaType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='un:', name_='ProfileRelationshipReference', namespacedef_='xmlns:un="http://www.un.org/sanctions/1.0"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ProfileRelationshipReference')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ProfileRelationshipReference')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='un:', name_='ProfileRelationshipReference', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='un:', name_='ProfileRelationshipReference'):
        if self.ProfileRelationshipID is not None and 'ProfileRelationshipID' not in already_processed:
            already_processed.add('ProfileRelationshipID')
            outfile.write(' ProfileRelationshipID="%s"' % self.gds_format_integer(self.ProfileRelationshipID, input_name='ProfileRelationshipID'))
        if self.DeltaAction is not None and 'DeltaAction' not in already_processed:
            already_processed.add('DeltaAction')
            outfile.write(' DeltaAction=%s' % (quote_attrib(self.DeltaAction), ))
    def exportChildren(self, outfile, level, namespace_='un:', name_='ProfileRelationshipReference', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ProfileRelationshipID', node)
        if value is not None and 'ProfileRelationshipID' not in already_processed:
            already_processed.add('ProfileRelationshipID')
            try:
                self.ProfileRelationshipID = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.ProfileRelationshipID < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = find_attr_value_('DeltaAction', node)
        if value is not None and 'DeltaAction' not in already_processed:
            already_processed.add('DeltaAction')
            self.DeltaAction = value
            self.validate_DeltaActionSchemaType(self.DeltaAction)    # validate type DeltaActionSchemaType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ProfileRelationshipReference


class DatePeriod(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, CalendarTypeID=None, YearFixed=None, MonthFixed=None, DayFixed=None, DeltaAction=None, Comment=None, Start=None, End=None, DurationMinimum=None, DurationMaximum=None):
        self.original_tagname_ = None
        self.CalendarTypeID = _cast(int, CalendarTypeID)
        self.YearFixed = _cast(bool, YearFixed)
        self.MonthFixed = _cast(bool, MonthFixed)
        self.DayFixed = _cast(bool, DayFixed)
        self.DeltaAction = _cast(None, DeltaAction)
        self.Comment = Comment
        self.Start = Start
        self.End = End
        self.DurationMinimum = DurationMinimum
        self.DurationMaximum = DurationMaximum
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DatePeriod)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DatePeriod.subclass:
            return DatePeriod.subclass(*args_, **kwargs_)
        else:
            return DatePeriod(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Comment(self): return self.Comment
    def set_Comment(self, Comment): self.Comment = Comment
    def get_Start(self): return self.Start
    def set_Start(self, Start): self.Start = Start
    def get_End(self): return self.End
    def set_End(self, End): self.End = End
    def get_DurationMinimum(self): return self.DurationMinimum
    def set_DurationMinimum(self, DurationMinimum): self.DurationMinimum = DurationMinimum
    def get_DurationMaximum(self): return self.DurationMaximum
    def set_DurationMaximum(self, DurationMaximum): self.DurationMaximum = DurationMaximum
    def get_CalendarTypeID(self): return self.CalendarTypeID
    def set_CalendarTypeID(self, CalendarTypeID): self.CalendarTypeID = CalendarTypeID
    def get_YearFixed(self): return self.YearFixed
    def set_YearFixed(self, YearFixed): self.YearFixed = YearFixed
    def get_MonthFixed(self): return self.MonthFixed
    def set_MonthFixed(self, MonthFixed): self.MonthFixed = MonthFixed
    def get_DayFixed(self): return self.DayFixed
    def set_DayFixed(self, DayFixed): self.DayFixed = DayFixed
    def get_DeltaAction(self): return self.DeltaAction
    def set_DeltaAction(self, DeltaAction): self.DeltaAction = DeltaAction
    def validate_DeltaActionSchemaType(self, value):
        # Validate type DeltaActionSchemaType, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['add', 'amend', 'delete', 'revise']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on DeltaActionSchemaType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.Comment is not None or
            self.Start is not None or
            self.End is not None or
            self.DurationMinimum is not None or
            self.DurationMaximum is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='un:', name_='DatePeriod', namespacedef_='xmlns:un="http://www.un.org/sanctions/1.0"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DatePeriod')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DatePeriod')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='un:', name_='DatePeriod', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='un:', name_='DatePeriod'):
        if self.CalendarTypeID is not None and 'CalendarTypeID' not in already_processed:
            already_processed.add('CalendarTypeID')
            outfile.write(' CalendarTypeID="%s"' % self.gds_format_integer(self.CalendarTypeID, input_name='CalendarTypeID'))
        if self.YearFixed is not None and 'YearFixed' not in already_processed:
            already_processed.add('YearFixed')
            outfile.write(' YearFixed="%s"' % self.gds_format_boolean(self.YearFixed, input_name='YearFixed'))
        if self.MonthFixed is not None and 'MonthFixed' not in already_processed:
            already_processed.add('MonthFixed')
            outfile.write(' MonthFixed="%s"' % self.gds_format_boolean(self.MonthFixed, input_name='MonthFixed'))
        if self.DayFixed is not None and 'DayFixed' not in already_processed:
            already_processed.add('DayFixed')
            outfile.write(' DayFixed="%s"' % self.gds_format_boolean(self.DayFixed, input_name='DayFixed'))
        if self.DeltaAction is not None and 'DeltaAction' not in already_processed:
            already_processed.add('DeltaAction')
            outfile.write(' DeltaAction=%s' % (quote_attrib(self.DeltaAction), ))
    def exportChildren(self, outfile, level, namespace_='un:', name_='DatePeriod', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Comment is not None:
            self.Comment.export(outfile, level, namespace_, name_='Comment', pretty_print=pretty_print)
        if self.Start is not None:
            self.Start.export(outfile, level, namespace_, name_='Start', pretty_print=pretty_print)
        if self.End is not None:
            self.End.export(outfile, level, namespace_, name_='End', pretty_print=pretty_print)
        if self.DurationMinimum is not None:
            self.DurationMinimum.export(outfile, level, namespace_, name_='DurationMinimum', pretty_print=pretty_print)
        if self.DurationMaximum is not None:
            self.DurationMaximum.export(outfile, level, namespace_, name_='DurationMaximum', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('CalendarTypeID', node)
        if value is not None and 'CalendarTypeID' not in already_processed:
            already_processed.add('CalendarTypeID')
            try:
                self.CalendarTypeID = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.CalendarTypeID < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = find_attr_value_('YearFixed', node)
        if value is not None and 'YearFixed' not in already_processed:
            already_processed.add('YearFixed')
            if value in ('true', '1'):
                self.YearFixed = True
            elif value in ('false', '0'):
                self.YearFixed = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('MonthFixed', node)
        if value is not None and 'MonthFixed' not in already_processed:
            already_processed.add('MonthFixed')
            if value in ('true', '1'):
                self.MonthFixed = True
            elif value in ('false', '0'):
                self.MonthFixed = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('DayFixed', node)
        if value is not None and 'DayFixed' not in already_processed:
            already_processed.add('DayFixed')
            if value in ('true', '1'):
                self.DayFixed = True
            elif value in ('false', '0'):
                self.DayFixed = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('DeltaAction', node)
        if value is not None and 'DeltaAction' not in already_processed:
            already_processed.add('DeltaAction')
            self.DeltaAction = value
            self.validate_DeltaActionSchemaType(self.DeltaAction)    # validate type DeltaActionSchemaType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Comment':
            obj_ = Comment.factory()
            obj_.build(child_)
            self.Comment = obj_
            obj_.original_tagname_ = 'Comment'
        elif nodeName_ == 'Start':
            obj_ = DateBoundarySchemaType.factory()
            obj_.build(child_)
            self.Start = obj_
            obj_.original_tagname_ = 'Start'
        elif nodeName_ == 'End':
            obj_ = DateBoundarySchemaType.factory()
            obj_.build(child_)
            self.End = obj_
            obj_.original_tagname_ = 'End'
        elif nodeName_ == 'DurationMinimum':
            obj_ = DurationSchemaType.factory()
            obj_.build(child_)
            self.DurationMinimum = obj_
            obj_.original_tagname_ = 'DurationMinimum'
        elif nodeName_ == 'DurationMaximum':
            obj_ = DurationSchemaType.factory()
            obj_.build(child_)
            self.DurationMaximum = obj_
            obj_.original_tagname_ = 'DurationMaximum'
# end class DatePeriod


class DirectURL(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, DeltaAction=None, valueOf_=None):
        self.original_tagname_ = None
        self.DeltaAction = _cast(None, DeltaAction)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DirectURL)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DirectURL.subclass:
            return DirectURL.subclass(*args_, **kwargs_)
        else:
            return DirectURL(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_DeltaAction(self): return self.DeltaAction
    def set_DeltaAction(self, DeltaAction): self.DeltaAction = DeltaAction
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_DeltaActionSchemaType(self, value):
        # Validate type DeltaActionSchemaType, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['add', 'amend', 'delete', 'revise']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on DeltaActionSchemaType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='un:', name_='DirectURL', namespacedef_='xmlns:un="http://www.un.org/sanctions/1.0"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DirectURL')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DirectURL')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='un:', name_='DirectURL', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='un:', name_='DirectURL'):
        if self.DeltaAction is not None and 'DeltaAction' not in already_processed:
            already_processed.add('DeltaAction')
            outfile.write(' DeltaAction=%s' % (quote_attrib(self.DeltaAction), ))
    def exportChildren(self, outfile, level, namespace_='un:', name_='DirectURL', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('DeltaAction', node)
        if value is not None and 'DeltaAction' not in already_processed:
            already_processed.add('DeltaAction')
            self.DeltaAction = value
            self.validate_DeltaActionSchemaType(self.DeltaAction)    # validate type DeltaActionSchemaType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class DirectURL


class Year(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, DeltaAction=None, valueOf_=None):
        self.original_tagname_ = None
        self.DeltaAction = _cast(None, DeltaAction)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Year)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Year.subclass:
            return Year.subclass(*args_, **kwargs_)
        else:
            return Year(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_DeltaAction(self): return self.DeltaAction
    def set_DeltaAction(self, DeltaAction): self.DeltaAction = DeltaAction
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_DeltaActionSchemaType(self, value):
        # Validate type DeltaActionSchemaType, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['add', 'amend', 'delete', 'revise']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on DeltaActionSchemaType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='un:', name_='Year', namespacedef_='xmlns:un="http://www.un.org/sanctions/1.0"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Year')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Year')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='un:', name_='Year', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='un:', name_='Year'):
        if self.DeltaAction is not None and 'DeltaAction' not in already_processed:
            already_processed.add('DeltaAction')
            outfile.write(' DeltaAction=%s' % (quote_attrib(self.DeltaAction), ))
    def exportChildren(self, outfile, level, namespace_='un:', name_='Year', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('DeltaAction', node)
        if value is not None and 'DeltaAction' not in already_processed:
            already_processed.add('DeltaAction')
            self.DeltaAction = value
            self.validate_DeltaActionSchemaType(self.DeltaAction)    # validate type DeltaActionSchemaType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class Year


class Month(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, DeltaAction=None, valueOf_=None):
        self.original_tagname_ = None
        self.DeltaAction = _cast(None, DeltaAction)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Month)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Month.subclass:
            return Month.subclass(*args_, **kwargs_)
        else:
            return Month(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_DeltaAction(self): return self.DeltaAction
    def set_DeltaAction(self, DeltaAction): self.DeltaAction = DeltaAction
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_DeltaActionSchemaType(self, value):
        # Validate type DeltaActionSchemaType, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['add', 'amend', 'delete', 'revise']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on DeltaActionSchemaType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='un:', name_='Month', namespacedef_='xmlns:un="http://www.un.org/sanctions/1.0"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Month')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Month')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='un:', name_='Month', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='un:', name_='Month'):
        if self.DeltaAction is not None and 'DeltaAction' not in already_processed:
            already_processed.add('DeltaAction')
            outfile.write(' DeltaAction=%s' % (quote_attrib(self.DeltaAction), ))
    def exportChildren(self, outfile, level, namespace_='un:', name_='Month', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('DeltaAction', node)
        if value is not None and 'DeltaAction' not in already_processed:
            already_processed.add('DeltaAction')
            self.DeltaAction = value
            self.validate_DeltaActionSchemaType(self.DeltaAction)    # validate type DeltaActionSchemaType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class Month


class Day(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, DeltaAction=None, valueOf_=None):
        self.original_tagname_ = None
        self.DeltaAction = _cast(None, DeltaAction)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Day)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Day.subclass:
            return Day.subclass(*args_, **kwargs_)
        else:
            return Day(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_DeltaAction(self): return self.DeltaAction
    def set_DeltaAction(self, DeltaAction): self.DeltaAction = DeltaAction
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_DeltaActionSchemaType(self, value):
        # Validate type DeltaActionSchemaType, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['add', 'amend', 'delete', 'revise']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on DeltaActionSchemaType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='un:', name_='Day', namespacedef_='xmlns:un="http://www.un.org/sanctions/1.0"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Day')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Day')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='un:', name_='Day', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='un:', name_='Day'):
        if self.DeltaAction is not None and 'DeltaAction' not in already_processed:
            already_processed.add('DeltaAction')
            outfile.write(' DeltaAction=%s' % (quote_attrib(self.DeltaAction), ))
    def exportChildren(self, outfile, level, namespace_='un:', name_='Day', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('DeltaAction', node)
        if value is not None and 'DeltaAction' not in already_processed:
            already_processed.add('DeltaAction')
            self.DeltaAction = value
            self.validate_DeltaActionSchemaType(self.DeltaAction)    # validate type DeltaActionSchemaType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class Day


class ReferenceValueSetsSchemaType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, AliasTypeValues=None, AreaCodeValues=None, AreaCodeTypeValues=None, CalendarTypeValues=None, CountryValues=None, CountryRelevanceValues=None, DecisionMakingBodyValues=None, DetailReferenceValues=None, DetailTypeValues=None, DocNameStatusValues=None, EntryEventTypeValues=None, EntryLinkTypeValues=None, ExRefTypeValues=None, FeatureTypeValues=None, FeatureTypeGroupValues=None, IDRegDocDateTypeValues=None, IDRegDocTypeValues=None, IdentityFeatureLinkTypeValues=None, LegalBasisValues=None, LegalBasisTypeValues=None, ListValues=None, LocPartTypeValues=None, LocPartValueStatusValues=None, LocPartValueTypeValues=None, NamePartTypeValues=None, OrganisationValues=None, PartySubTypeValues=None, PartyTypeValues=None, RelationQualityValues=None, RelationTypeValues=None, ReliabilityValues=None, SanctionsProgramValues=None, SanctionsTypeValues=None, ScriptValues=None, ScriptStatusValues=None, SubsidiaryBodyValues=None, SupInfoTypeValues=None, TargetTypeValues=None, ValidityValues=None):
        self.original_tagname_ = None
        self.AliasTypeValues = AliasTypeValues
        self.AreaCodeValues = AreaCodeValues
        self.AreaCodeTypeValues = AreaCodeTypeValues
        self.CalendarTypeValues = CalendarTypeValues
        self.CountryValues = CountryValues
        self.CountryRelevanceValues = CountryRelevanceValues
        self.DecisionMakingBodyValues = DecisionMakingBodyValues
        self.DetailReferenceValues = DetailReferenceValues
        self.DetailTypeValues = DetailTypeValues
        self.DocNameStatusValues = DocNameStatusValues
        self.EntryEventTypeValues = EntryEventTypeValues
        self.EntryLinkTypeValues = EntryLinkTypeValues
        self.ExRefTypeValues = ExRefTypeValues
        self.FeatureTypeValues = FeatureTypeValues
        self.FeatureTypeGroupValues = FeatureTypeGroupValues
        self.IDRegDocDateTypeValues = IDRegDocDateTypeValues
        self.IDRegDocTypeValues = IDRegDocTypeValues
        self.IdentityFeatureLinkTypeValues = IdentityFeatureLinkTypeValues
        self.LegalBasisValues = LegalBasisValues
        self.LegalBasisTypeValues = LegalBasisTypeValues
        self.ListValues = ListValues
        self.LocPartTypeValues = LocPartTypeValues
        self.LocPartValueStatusValues = LocPartValueStatusValues
        self.LocPartValueTypeValues = LocPartValueTypeValues
        self.NamePartTypeValues = NamePartTypeValues
        self.OrganisationValues = OrganisationValues
        self.PartySubTypeValues = PartySubTypeValues
        self.PartyTypeValues = PartyTypeValues
        self.RelationQualityValues = RelationQualityValues
        self.RelationTypeValues = RelationTypeValues
        self.ReliabilityValues = ReliabilityValues
        self.SanctionsProgramValues = SanctionsProgramValues
        self.SanctionsTypeValues = SanctionsTypeValues
        self.ScriptValues = ScriptValues
        self.ScriptStatusValues = ScriptStatusValues
        self.SubsidiaryBodyValues = SubsidiaryBodyValues
        self.SupInfoTypeValues = SupInfoTypeValues
        self.TargetTypeValues = TargetTypeValues
        self.ValidityValues = ValidityValues
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ReferenceValueSetsSchemaType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ReferenceValueSetsSchemaType.subclass:
            return ReferenceValueSetsSchemaType.subclass(*args_, **kwargs_)
        else:
            return ReferenceValueSetsSchemaType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_AliasTypeValues(self): return self.AliasTypeValues
    def set_AliasTypeValues(self, AliasTypeValues): self.AliasTypeValues = AliasTypeValues
    def get_AreaCodeValues(self): return self.AreaCodeValues
    def set_AreaCodeValues(self, AreaCodeValues): self.AreaCodeValues = AreaCodeValues
    def get_AreaCodeTypeValues(self): return self.AreaCodeTypeValues
    def set_AreaCodeTypeValues(self, AreaCodeTypeValues): self.AreaCodeTypeValues = AreaCodeTypeValues
    def get_CalendarTypeValues(self): return self.CalendarTypeValues
    def set_CalendarTypeValues(self, CalendarTypeValues): self.CalendarTypeValues = CalendarTypeValues
    def get_CountryValues(self): return self.CountryValues
    def set_CountryValues(self, CountryValues): self.CountryValues = CountryValues
    def get_CountryRelevanceValues(self): return self.CountryRelevanceValues
    def set_CountryRelevanceValues(self, CountryRelevanceValues): self.CountryRelevanceValues = CountryRelevanceValues
    def get_DecisionMakingBodyValues(self): return self.DecisionMakingBodyValues
    def set_DecisionMakingBodyValues(self, DecisionMakingBodyValues): self.DecisionMakingBodyValues = DecisionMakingBodyValues
    def get_DetailReferenceValues(self): return self.DetailReferenceValues
    def set_DetailReferenceValues(self, DetailReferenceValues): self.DetailReferenceValues = DetailReferenceValues
    def get_DetailTypeValues(self): return self.DetailTypeValues
    def set_DetailTypeValues(self, DetailTypeValues): self.DetailTypeValues = DetailTypeValues
    def get_DocNameStatusValues(self): return self.DocNameStatusValues
    def set_DocNameStatusValues(self, DocNameStatusValues): self.DocNameStatusValues = DocNameStatusValues
    def get_EntryEventTypeValues(self): return self.EntryEventTypeValues
    def set_EntryEventTypeValues(self, EntryEventTypeValues): self.EntryEventTypeValues = EntryEventTypeValues
    def get_EntryLinkTypeValues(self): return self.EntryLinkTypeValues
    def set_EntryLinkTypeValues(self, EntryLinkTypeValues): self.EntryLinkTypeValues = EntryLinkTypeValues
    def get_ExRefTypeValues(self): return self.ExRefTypeValues
    def set_ExRefTypeValues(self, ExRefTypeValues): self.ExRefTypeValues = ExRefTypeValues
    def get_FeatureTypeValues(self): return self.FeatureTypeValues
    def set_FeatureTypeValues(self, FeatureTypeValues): self.FeatureTypeValues = FeatureTypeValues
    def get_FeatureTypeGroupValues(self): return self.FeatureTypeGroupValues
    def set_FeatureTypeGroupValues(self, FeatureTypeGroupValues): self.FeatureTypeGroupValues = FeatureTypeGroupValues
    def get_IDRegDocDateTypeValues(self): return self.IDRegDocDateTypeValues
    def set_IDRegDocDateTypeValues(self, IDRegDocDateTypeValues): self.IDRegDocDateTypeValues = IDRegDocDateTypeValues
    def get_IDRegDocTypeValues(self): return self.IDRegDocTypeValues
    def set_IDRegDocTypeValues(self, IDRegDocTypeValues): self.IDRegDocTypeValues = IDRegDocTypeValues
    def get_IdentityFeatureLinkTypeValues(self): return self.IdentityFeatureLinkTypeValues
    def set_IdentityFeatureLinkTypeValues(self, IdentityFeatureLinkTypeValues): self.IdentityFeatureLinkTypeValues = IdentityFeatureLinkTypeValues
    def get_LegalBasisValues(self): return self.LegalBasisValues
    def set_LegalBasisValues(self, LegalBasisValues): self.LegalBasisValues = LegalBasisValues
    def get_LegalBasisTypeValues(self): return self.LegalBasisTypeValues
    def set_LegalBasisTypeValues(self, LegalBasisTypeValues): self.LegalBasisTypeValues = LegalBasisTypeValues
    def get_ListValues(self): return self.ListValues
    def set_ListValues(self, ListValues): self.ListValues = ListValues
    def get_LocPartTypeValues(self): return self.LocPartTypeValues
    def set_LocPartTypeValues(self, LocPartTypeValues): self.LocPartTypeValues = LocPartTypeValues
    def get_LocPartValueStatusValues(self): return self.LocPartValueStatusValues
    def set_LocPartValueStatusValues(self, LocPartValueStatusValues): self.LocPartValueStatusValues = LocPartValueStatusValues
    def get_LocPartValueTypeValues(self): return self.LocPartValueTypeValues
    def set_LocPartValueTypeValues(self, LocPartValueTypeValues): self.LocPartValueTypeValues = LocPartValueTypeValues
    def get_NamePartTypeValues(self): return self.NamePartTypeValues
    def set_NamePartTypeValues(self, NamePartTypeValues): self.NamePartTypeValues = NamePartTypeValues
    def get_OrganisationValues(self): return self.OrganisationValues
    def set_OrganisationValues(self, OrganisationValues): self.OrganisationValues = OrganisationValues
    def get_PartySubTypeValues(self): return self.PartySubTypeValues
    def set_PartySubTypeValues(self, PartySubTypeValues): self.PartySubTypeValues = PartySubTypeValues
    def get_PartyTypeValues(self): return self.PartyTypeValues
    def set_PartyTypeValues(self, PartyTypeValues): self.PartyTypeValues = PartyTypeValues
    def get_RelationQualityValues(self): return self.RelationQualityValues
    def set_RelationQualityValues(self, RelationQualityValues): self.RelationQualityValues = RelationQualityValues
    def get_RelationTypeValues(self): return self.RelationTypeValues
    def set_RelationTypeValues(self, RelationTypeValues): self.RelationTypeValues = RelationTypeValues
    def get_ReliabilityValues(self): return self.ReliabilityValues
    def set_ReliabilityValues(self, ReliabilityValues): self.ReliabilityValues = ReliabilityValues
    def get_SanctionsProgramValues(self): return self.SanctionsProgramValues
    def set_SanctionsProgramValues(self, SanctionsProgramValues): self.SanctionsProgramValues = SanctionsProgramValues
    def get_SanctionsTypeValues(self): return self.SanctionsTypeValues
    def set_SanctionsTypeValues(self, SanctionsTypeValues): self.SanctionsTypeValues = SanctionsTypeValues
    def get_ScriptValues(self): return self.ScriptValues
    def set_ScriptValues(self, ScriptValues): self.ScriptValues = ScriptValues
    def get_ScriptStatusValues(self): return self.ScriptStatusValues
    def set_ScriptStatusValues(self, ScriptStatusValues): self.ScriptStatusValues = ScriptStatusValues
    def get_SubsidiaryBodyValues(self): return self.SubsidiaryBodyValues
    def set_SubsidiaryBodyValues(self, SubsidiaryBodyValues): self.SubsidiaryBodyValues = SubsidiaryBodyValues
    def get_SupInfoTypeValues(self): return self.SupInfoTypeValues
    def set_SupInfoTypeValues(self, SupInfoTypeValues): self.SupInfoTypeValues = SupInfoTypeValues
    def get_TargetTypeValues(self): return self.TargetTypeValues
    def set_TargetTypeValues(self, TargetTypeValues): self.TargetTypeValues = TargetTypeValues
    def get_ValidityValues(self): return self.ValidityValues
    def set_ValidityValues(self, ValidityValues): self.ValidityValues = ValidityValues
    def hasContent_(self):
        if (
            self.AliasTypeValues is not None or
            self.AreaCodeValues is not None or
            self.AreaCodeTypeValues is not None or
            self.CalendarTypeValues is not None or
            self.CountryValues is not None or
            self.CountryRelevanceValues is not None or
            self.DecisionMakingBodyValues is not None or
            self.DetailReferenceValues is not None or
            self.DetailTypeValues is not None or
            self.DocNameStatusValues is not None or
            self.EntryEventTypeValues is not None or
            self.EntryLinkTypeValues is not None or
            self.ExRefTypeValues is not None or
            self.FeatureTypeValues is not None or
            self.FeatureTypeGroupValues is not None or
            self.IDRegDocDateTypeValues is not None or
            self.IDRegDocTypeValues is not None or
            self.IdentityFeatureLinkTypeValues is not None or
            self.LegalBasisValues is not None or
            self.LegalBasisTypeValues is not None or
            self.ListValues is not None or
            self.LocPartTypeValues is not None or
            self.LocPartValueStatusValues is not None or
            self.LocPartValueTypeValues is not None or
            self.NamePartTypeValues is not None or
            self.OrganisationValues is not None or
            self.PartySubTypeValues is not None or
            self.PartyTypeValues is not None or
            self.RelationQualityValues is not None or
            self.RelationTypeValues is not None or
            self.ReliabilityValues is not None or
            self.SanctionsProgramValues is not None or
            self.SanctionsTypeValues is not None or
            self.ScriptValues is not None or
            self.ScriptStatusValues is not None or
            self.SubsidiaryBodyValues is not None or
            self.SupInfoTypeValues is not None or
            self.TargetTypeValues is not None or
            self.ValidityValues is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='un:', name_='ReferenceValueSetsSchemaType', namespacedef_='xmlns:un="http://www.un.org/sanctions/1.0"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ReferenceValueSetsSchemaType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ReferenceValueSetsSchemaType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='un:', name_='ReferenceValueSetsSchemaType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='un:', name_='ReferenceValueSetsSchemaType'):
        pass
    def exportChildren(self, outfile, level, namespace_='un:', name_='ReferenceValueSetsSchemaType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.AliasTypeValues is not None:
            self.AliasTypeValues.export(outfile, level, namespace_, name_='AliasTypeValues', pretty_print=pretty_print)
        if self.AreaCodeValues is not None:
            self.AreaCodeValues.export(outfile, level, namespace_, name_='AreaCodeValues', pretty_print=pretty_print)
        if self.AreaCodeTypeValues is not None:
            self.AreaCodeTypeValues.export(outfile, level, namespace_, name_='AreaCodeTypeValues', pretty_print=pretty_print)
        if self.CalendarTypeValues is not None:
            self.CalendarTypeValues.export(outfile, level, namespace_, name_='CalendarTypeValues', pretty_print=pretty_print)
        if self.CountryValues is not None:
            self.CountryValues.export(outfile, level, namespace_, name_='CountryValues', pretty_print=pretty_print)
        if self.CountryRelevanceValues is not None:
            self.CountryRelevanceValues.export(outfile, level, namespace_, name_='CountryRelevanceValues', pretty_print=pretty_print)
        if self.DecisionMakingBodyValues is not None:
            self.DecisionMakingBodyValues.export(outfile, level, namespace_, name_='DecisionMakingBodyValues', pretty_print=pretty_print)
        if self.DetailReferenceValues is not None:
            self.DetailReferenceValues.export(outfile, level, namespace_, name_='DetailReferenceValues', pretty_print=pretty_print)
        if self.DetailTypeValues is not None:
            self.DetailTypeValues.export(outfile, level, namespace_, name_='DetailTypeValues', pretty_print=pretty_print)
        if self.DocNameStatusValues is not None:
            self.DocNameStatusValues.export(outfile, level, namespace_, name_='DocNameStatusValues', pretty_print=pretty_print)
        if self.EntryEventTypeValues is not None:
            self.EntryEventTypeValues.export(outfile, level, namespace_, name_='EntryEventTypeValues', pretty_print=pretty_print)
        if self.EntryLinkTypeValues is not None:
            self.EntryLinkTypeValues.export(outfile, level, namespace_, name_='EntryLinkTypeValues', pretty_print=pretty_print)
        if self.ExRefTypeValues is not None:
            self.ExRefTypeValues.export(outfile, level, namespace_, name_='ExRefTypeValues', pretty_print=pretty_print)
        if self.FeatureTypeValues is not None:
            self.FeatureTypeValues.export(outfile, level, namespace_, name_='FeatureTypeValues', pretty_print=pretty_print)
        if self.FeatureTypeGroupValues is not None:
            self.FeatureTypeGroupValues.export(outfile, level, namespace_, name_='FeatureTypeGroupValues', pretty_print=pretty_print)
        if self.IDRegDocDateTypeValues is not None:
            self.IDRegDocDateTypeValues.export(outfile, level, namespace_, name_='IDRegDocDateTypeValues', pretty_print=pretty_print)
        if self.IDRegDocTypeValues is not None:
            self.IDRegDocTypeValues.export(outfile, level, namespace_, name_='IDRegDocTypeValues', pretty_print=pretty_print)
        if self.IdentityFeatureLinkTypeValues is not None:
            self.IdentityFeatureLinkTypeValues.export(outfile, level, namespace_, name_='IdentityFeatureLinkTypeValues', pretty_print=pretty_print)
        if self.LegalBasisValues is not None:
            self.LegalBasisValues.export(outfile, level, namespace_, name_='LegalBasisValues', pretty_print=pretty_print)
        if self.LegalBasisTypeValues is not None:
            self.LegalBasisTypeValues.export(outfile, level, namespace_, name_='LegalBasisTypeValues', pretty_print=pretty_print)
        if self.ListValues is not None:
            self.ListValues.export(outfile, level, namespace_, name_='ListValues', pretty_print=pretty_print)
        if self.LocPartTypeValues is not None:
            self.LocPartTypeValues.export(outfile, level, namespace_, name_='LocPartTypeValues', pretty_print=pretty_print)
        if self.LocPartValueStatusValues is not None:
            self.LocPartValueStatusValues.export(outfile, level, namespace_, name_='LocPartValueStatusValues', pretty_print=pretty_print)
        if self.LocPartValueTypeValues is not None:
            self.LocPartValueTypeValues.export(outfile, level, namespace_, name_='LocPartValueTypeValues', pretty_print=pretty_print)
        if self.NamePartTypeValues is not None:
            self.NamePartTypeValues.export(outfile, level, namespace_, name_='NamePartTypeValues', pretty_print=pretty_print)
        if self.OrganisationValues is not None:
            self.OrganisationValues.export(outfile, level, namespace_, name_='OrganisationValues', pretty_print=pretty_print)
        if self.PartySubTypeValues is not None:
            self.PartySubTypeValues.export(outfile, level, namespace_, name_='PartySubTypeValues', pretty_print=pretty_print)
        if self.PartyTypeValues is not None:
            self.PartyTypeValues.export(outfile, level, namespace_, name_='PartyTypeValues', pretty_print=pretty_print)
        if self.RelationQualityValues is not None:
            self.RelationQualityValues.export(outfile, level, namespace_, name_='RelationQualityValues', pretty_print=pretty_print)
        if self.RelationTypeValues is not None:
            self.RelationTypeValues.export(outfile, level, namespace_, name_='RelationTypeValues', pretty_print=pretty_print)
        if self.ReliabilityValues is not None:
            self.ReliabilityValues.export(outfile, level, namespace_, name_='ReliabilityValues', pretty_print=pretty_print)
        if self.SanctionsProgramValues is not None:
            self.SanctionsProgramValues.export(outfile, level, namespace_, name_='SanctionsProgramValues', pretty_print=pretty_print)
        if self.SanctionsTypeValues is not None:
            self.SanctionsTypeValues.export(outfile, level, namespace_, name_='SanctionsTypeValues', pretty_print=pretty_print)
        if self.ScriptValues is not None:
            self.ScriptValues.export(outfile, level, namespace_, name_='ScriptValues', pretty_print=pretty_print)
        if self.ScriptStatusValues is not None:
            self.ScriptStatusValues.export(outfile, level, namespace_, name_='ScriptStatusValues', pretty_print=pretty_print)
        if self.SubsidiaryBodyValues is not None:
            self.SubsidiaryBodyValues.export(outfile, level, namespace_, name_='SubsidiaryBodyValues', pretty_print=pretty_print)
        if self.SupInfoTypeValues is not None:
            self.SupInfoTypeValues.export(outfile, level, namespace_, name_='SupInfoTypeValues', pretty_print=pretty_print)
        if self.TargetTypeValues is not None:
            self.TargetTypeValues.export(outfile, level, namespace_, name_='TargetTypeValues', pretty_print=pretty_print)
        if self.ValidityValues is not None:
            self.ValidityValues.export(outfile, level, namespace_, name_='ValidityValues', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'AliasTypeValues':
            obj_ = AliasTypeValuesType.factory()
            obj_.build(child_)
            self.AliasTypeValues = obj_
            obj_.original_tagname_ = 'AliasTypeValues'
        elif nodeName_ == 'AreaCodeValues':
            obj_ = AreaCodeValuesType.factory()
            obj_.build(child_)
            self.AreaCodeValues = obj_
            obj_.original_tagname_ = 'AreaCodeValues'
        elif nodeName_ == 'AreaCodeTypeValues':
            obj_ = AreaCodeTypeValuesType.factory()
            obj_.build(child_)
            self.AreaCodeTypeValues = obj_
            obj_.original_tagname_ = 'AreaCodeTypeValues'
        elif nodeName_ == 'CalendarTypeValues':
            obj_ = CalendarTypeValuesType.factory()
            obj_.build(child_)
            self.CalendarTypeValues = obj_
            obj_.original_tagname_ = 'CalendarTypeValues'
        elif nodeName_ == 'CountryValues':
            obj_ = CountryValuesType.factory()
            obj_.build(child_)
            self.CountryValues = obj_
            obj_.original_tagname_ = 'CountryValues'
        elif nodeName_ == 'CountryRelevanceValues':
            obj_ = CountryRelevanceValuesType.factory()
            obj_.build(child_)
            self.CountryRelevanceValues = obj_
            obj_.original_tagname_ = 'CountryRelevanceValues'
        elif nodeName_ == 'DecisionMakingBodyValues':
            obj_ = DecisionMakingBodyValuesType.factory()
            obj_.build(child_)
            self.DecisionMakingBodyValues = obj_
            obj_.original_tagname_ = 'DecisionMakingBodyValues'
        elif nodeName_ == 'DetailReferenceValues':
            obj_ = DetailReferenceValuesType.factory()
            obj_.build(child_)
            self.DetailReferenceValues = obj_
            obj_.original_tagname_ = 'DetailReferenceValues'
        elif nodeName_ == 'DetailTypeValues':
            obj_ = DetailTypeValuesType.factory()
            obj_.build(child_)
            self.DetailTypeValues = obj_
            obj_.original_tagname_ = 'DetailTypeValues'
        elif nodeName_ == 'DocNameStatusValues':
            obj_ = DocNameStatusValuesType.factory()
            obj_.build(child_)
            self.DocNameStatusValues = obj_
            obj_.original_tagname_ = 'DocNameStatusValues'
        elif nodeName_ == 'EntryEventTypeValues':
            obj_ = EntryEventTypeValuesType.factory()
            obj_.build(child_)
            self.EntryEventTypeValues = obj_
            obj_.original_tagname_ = 'EntryEventTypeValues'
        elif nodeName_ == 'EntryLinkTypeValues':
            obj_ = EntryLinkTypeValuesType.factory()
            obj_.build(child_)
            self.EntryLinkTypeValues = obj_
            obj_.original_tagname_ = 'EntryLinkTypeValues'
        elif nodeName_ == 'ExRefTypeValues':
            obj_ = ExRefTypeValuesType.factory()
            obj_.build(child_)
            self.ExRefTypeValues = obj_
            obj_.original_tagname_ = 'ExRefTypeValues'
        elif nodeName_ == 'FeatureTypeValues':
            obj_ = FeatureTypeValuesType.factory()
            obj_.build(child_)
            self.FeatureTypeValues = obj_
            obj_.original_tagname_ = 'FeatureTypeValues'
        elif nodeName_ == 'FeatureTypeGroupValues':
            obj_ = FeatureTypeGroupValuesType.factory()
            obj_.build(child_)
            self.FeatureTypeGroupValues = obj_
            obj_.original_tagname_ = 'FeatureTypeGroupValues'
        elif nodeName_ == 'IDRegDocDateTypeValues':
            obj_ = IDRegDocDateTypeValuesType.factory()
            obj_.build(child_)
            self.IDRegDocDateTypeValues = obj_
            obj_.original_tagname_ = 'IDRegDocDateTypeValues'
        elif nodeName_ == 'IDRegDocTypeValues':
            obj_ = IDRegDocTypeValuesType.factory()
            obj_.build(child_)
            self.IDRegDocTypeValues = obj_
            obj_.original_tagname_ = 'IDRegDocTypeValues'
        elif nodeName_ == 'IdentityFeatureLinkTypeValues':
            obj_ = IdentityFeatureLinkTypeValuesType.factory()
            obj_.build(child_)
            self.IdentityFeatureLinkTypeValues = obj_
            obj_.original_tagname_ = 'IdentityFeatureLinkTypeValues'
        elif nodeName_ == 'LegalBasisValues':
            obj_ = LegalBasisValuesType.factory()
            obj_.build(child_)
            self.LegalBasisValues = obj_
            obj_.original_tagname_ = 'LegalBasisValues'
        elif nodeName_ == 'LegalBasisTypeValues':
            obj_ = LegalBasisTypeValuesType.factory()
            obj_.build(child_)
            self.LegalBasisTypeValues = obj_
            obj_.original_tagname_ = 'LegalBasisTypeValues'
        elif nodeName_ == 'ListValues':
            obj_ = ListValuesType.factory()
            obj_.build(child_)
            self.ListValues = obj_
            obj_.original_tagname_ = 'ListValues'
        elif nodeName_ == 'LocPartTypeValues':
            obj_ = LocPartTypeValuesType.factory()
            obj_.build(child_)
            self.LocPartTypeValues = obj_
            obj_.original_tagname_ = 'LocPartTypeValues'
        elif nodeName_ == 'LocPartValueStatusValues':
            obj_ = LocPartValueStatusValuesType.factory()
            obj_.build(child_)
            self.LocPartValueStatusValues = obj_
            obj_.original_tagname_ = 'LocPartValueStatusValues'
        elif nodeName_ == 'LocPartValueTypeValues':
            obj_ = LocPartValueTypeValuesType.factory()
            obj_.build(child_)
            self.LocPartValueTypeValues = obj_
            obj_.original_tagname_ = 'LocPartValueTypeValues'
        elif nodeName_ == 'NamePartTypeValues':
            obj_ = NamePartTypeValuesType.factory()
            obj_.build(child_)
            self.NamePartTypeValues = obj_
            obj_.original_tagname_ = 'NamePartTypeValues'
        elif nodeName_ == 'OrganisationValues':
            obj_ = OrganisationValuesType.factory()
            obj_.build(child_)
            self.OrganisationValues = obj_
            obj_.original_tagname_ = 'OrganisationValues'
        elif nodeName_ == 'PartySubTypeValues':
            obj_ = PartySubTypeValuesType.factory()
            obj_.build(child_)
            self.PartySubTypeValues = obj_
            obj_.original_tagname_ = 'PartySubTypeValues'
        elif nodeName_ == 'PartyTypeValues':
            obj_ = PartyTypeValuesType.factory()
            obj_.build(child_)
            self.PartyTypeValues = obj_
            obj_.original_tagname_ = 'PartyTypeValues'
        elif nodeName_ == 'RelationQualityValues':
            obj_ = RelationQualityValuesType.factory()
            obj_.build(child_)
            self.RelationQualityValues = obj_
            obj_.original_tagname_ = 'RelationQualityValues'
        elif nodeName_ == 'RelationTypeValues':
            obj_ = RelationTypeValuesType.factory()
            obj_.build(child_)
            self.RelationTypeValues = obj_
            obj_.original_tagname_ = 'RelationTypeValues'
        elif nodeName_ == 'ReliabilityValues':
            obj_ = ReliabilityValuesType.factory()
            obj_.build(child_)
            self.ReliabilityValues = obj_
            obj_.original_tagname_ = 'ReliabilityValues'
        elif nodeName_ == 'SanctionsProgramValues':
            obj_ = SanctionsProgramValuesType.factory()
            obj_.build(child_)
            self.SanctionsProgramValues = obj_
            obj_.original_tagname_ = 'SanctionsProgramValues'
        elif nodeName_ == 'SanctionsTypeValues':
            obj_ = SanctionsTypeValuesType.factory()
            obj_.build(child_)
            self.SanctionsTypeValues = obj_
            obj_.original_tagname_ = 'SanctionsTypeValues'
        elif nodeName_ == 'ScriptValues':
            obj_ = ScriptValuesType.factory()
            obj_.build(child_)
            self.ScriptValues = obj_
            obj_.original_tagname_ = 'ScriptValues'
        elif nodeName_ == 'ScriptStatusValues':
            obj_ = ScriptStatusValuesType.factory()
            obj_.build(child_)
            self.ScriptStatusValues = obj_
            obj_.original_tagname_ = 'ScriptStatusValues'
        elif nodeName_ == 'SubsidiaryBodyValues':
            obj_ = SubsidiaryBodyValuesType.factory()
            obj_.build(child_)
            self.SubsidiaryBodyValues = obj_
            obj_.original_tagname_ = 'SubsidiaryBodyValues'
        elif nodeName_ == 'SupInfoTypeValues':
            obj_ = SupInfoTypeValuesType.factory()
            obj_.build(child_)
            self.SupInfoTypeValues = obj_
            obj_.original_tagname_ = 'SupInfoTypeValues'
        elif nodeName_ == 'TargetTypeValues':
            obj_ = TargetTypeValuesType.factory()
            obj_.build(child_)
            self.TargetTypeValues = obj_
            obj_.original_tagname_ = 'TargetTypeValues'
        elif nodeName_ == 'ValidityValues':
            obj_ = ValidityValuesType.factory()
            obj_.build(child_)
            self.ValidityValues = obj_
            obj_.original_tagname_ = 'ValidityValues'
# end class ReferenceValueSetsSchemaType


class DateBoundarySchemaType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Approximate=None, YearFixed=None, MonthFixed=None, DayFixed=None, DeltaAction=None, From=None, To=None):
        self.original_tagname_ = None
        self.Approximate = _cast(bool, Approximate)
        self.YearFixed = _cast(bool, YearFixed)
        self.MonthFixed = _cast(bool, MonthFixed)
        self.DayFixed = _cast(bool, DayFixed)
        self.DeltaAction = _cast(None, DeltaAction)
        self.From = From
        self.To = To
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DateBoundarySchemaType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DateBoundarySchemaType.subclass:
            return DateBoundarySchemaType.subclass(*args_, **kwargs_)
        else:
            return DateBoundarySchemaType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_From(self): return self.From
    def set_From(self, From): self.From = From
    def get_To(self): return self.To
    def set_To(self, To): self.To = To
    def get_Approximate(self): return self.Approximate
    def set_Approximate(self, Approximate): self.Approximate = Approximate
    def get_YearFixed(self): return self.YearFixed
    def set_YearFixed(self, YearFixed): self.YearFixed = YearFixed
    def get_MonthFixed(self): return self.MonthFixed
    def set_MonthFixed(self, MonthFixed): self.MonthFixed = MonthFixed
    def get_DayFixed(self): return self.DayFixed
    def set_DayFixed(self, DayFixed): self.DayFixed = DayFixed
    def get_DeltaAction(self): return self.DeltaAction
    def set_DeltaAction(self, DeltaAction): self.DeltaAction = DeltaAction
    def validate_DeltaActionSchemaType(self, value):
        # Validate type DeltaActionSchemaType, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['add', 'amend', 'delete', 'revise']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on DeltaActionSchemaType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.From is not None or
            self.To is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='un:', name_='DateBoundarySchemaType', namespacedef_='xmlns:un="http://www.un.org/sanctions/1.0"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DateBoundarySchemaType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DateBoundarySchemaType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='un:', name_='DateBoundarySchemaType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='un:', name_='DateBoundarySchemaType'):
        if self.Approximate is not None and 'Approximate' not in already_processed:
            already_processed.add('Approximate')
            outfile.write(' Approximate="%s"' % self.gds_format_boolean(self.Approximate, input_name='Approximate'))
        if self.YearFixed is not None and 'YearFixed' not in already_processed:
            already_processed.add('YearFixed')
            outfile.write(' YearFixed="%s"' % self.gds_format_boolean(self.YearFixed, input_name='YearFixed'))
        if self.MonthFixed is not None and 'MonthFixed' not in already_processed:
            already_processed.add('MonthFixed')
            outfile.write(' MonthFixed="%s"' % self.gds_format_boolean(self.MonthFixed, input_name='MonthFixed'))
        if self.DayFixed is not None and 'DayFixed' not in already_processed:
            already_processed.add('DayFixed')
            outfile.write(' DayFixed="%s"' % self.gds_format_boolean(self.DayFixed, input_name='DayFixed'))
        if self.DeltaAction is not None and 'DeltaAction' not in already_processed:
            already_processed.add('DeltaAction')
            outfile.write(' DeltaAction=%s' % (quote_attrib(self.DeltaAction), ))
    def exportChildren(self, outfile, level, namespace_='un:', name_='DateBoundarySchemaType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.From is not None:
            self.From.export(outfile, level, namespace_, name_='From', pretty_print=pretty_print)
        if self.To is not None:
            self.To.export(outfile, level, namespace_, name_='To', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Approximate', node)
        if value is not None and 'Approximate' not in already_processed:
            already_processed.add('Approximate')
            if value in ('true', '1'):
                self.Approximate = True
            elif value in ('false', '0'):
                self.Approximate = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('YearFixed', node)
        if value is not None and 'YearFixed' not in already_processed:
            already_processed.add('YearFixed')
            if value in ('true', '1'):
                self.YearFixed = True
            elif value in ('false', '0'):
                self.YearFixed = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('MonthFixed', node)
        if value is not None and 'MonthFixed' not in already_processed:
            already_processed.add('MonthFixed')
            if value in ('true', '1'):
                self.MonthFixed = True
            elif value in ('false', '0'):
                self.MonthFixed = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('DayFixed', node)
        if value is not None and 'DayFixed' not in already_processed:
            already_processed.add('DayFixed')
            if value in ('true', '1'):
                self.DayFixed = True
            elif value in ('false', '0'):
                self.DayFixed = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('DeltaAction', node)
        if value is not None and 'DeltaAction' not in already_processed:
            already_processed.add('DeltaAction')
            self.DeltaAction = value
            self.validate_DeltaActionSchemaType(self.DeltaAction)    # validate type DeltaActionSchemaType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'From':
            obj_ = DatePointSchemaType.factory()
            obj_.build(child_)
            self.From = obj_
            obj_.original_tagname_ = 'From'
        elif nodeName_ == 'To':
            obj_ = DatePointSchemaType.factory()
            obj_.build(child_)
            self.To = obj_
            obj_.original_tagname_ = 'To'
# end class DateBoundarySchemaType


class DatePointSchemaType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, DeltaAction=None, Year=None, Month=None, Day=None):
        self.original_tagname_ = None
        self.DeltaAction = _cast(None, DeltaAction)
        self.Year = Year
        self.Month = Month
        self.Day = Day
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DatePointSchemaType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DatePointSchemaType.subclass:
            return DatePointSchemaType.subclass(*args_, **kwargs_)
        else:
            return DatePointSchemaType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Year(self): return self.Year
    def set_Year(self, Year): self.Year = Year
    def get_Month(self): return self.Month
    def set_Month(self, Month): self.Month = Month
    def get_Day(self): return self.Day
    def set_Day(self, Day): self.Day = Day
    def get_DeltaAction(self): return self.DeltaAction
    def set_DeltaAction(self, DeltaAction): self.DeltaAction = DeltaAction
    def validate_DeltaActionSchemaType(self, value):
        # Validate type DeltaActionSchemaType, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['add', 'amend', 'delete', 'revise']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on DeltaActionSchemaType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.Year is not None or
            self.Month is not None or
            self.Day is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='un:', name_='DatePointSchemaType', namespacedef_='xmlns:un="http://www.un.org/sanctions/1.0"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DatePointSchemaType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DatePointSchemaType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='un:', name_='DatePointSchemaType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='un:', name_='DatePointSchemaType'):
        if self.DeltaAction is not None and 'DeltaAction' not in already_processed:
            already_processed.add('DeltaAction')
            outfile.write(' DeltaAction=%s' % (quote_attrib(self.DeltaAction), ))
    def exportChildren(self, outfile, level, namespace_='un:', name_='DatePointSchemaType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Year is not None:
            self.Year.export(outfile, level, namespace_, name_='Year', pretty_print=pretty_print)
        if self.Month is not None:
            self.Month.export(outfile, level, namespace_, name_='Month', pretty_print=pretty_print)
        if self.Day is not None:
            self.Day.export(outfile, level, namespace_, name_='Day', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('DeltaAction', node)
        if value is not None and 'DeltaAction' not in already_processed:
            already_processed.add('DeltaAction')
            self.DeltaAction = value
            self.validate_DeltaActionSchemaType(self.DeltaAction)    # validate type DeltaActionSchemaType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Year':
            obj_ = Year.factory()
            obj_.build(child_)
            self.Year = obj_
            obj_.original_tagname_ = 'Year'
        elif nodeName_ == 'Month':
            obj_ = Month.factory()
            obj_.build(child_)
            self.Month = obj_
            obj_.original_tagname_ = 'Month'
        elif nodeName_ == 'Day':
            obj_ = Day.factory()
            obj_.build(child_)
            self.Day = obj_
            obj_.original_tagname_ = 'Day'
# end class DatePointSchemaType


class DurationSchemaType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Approximate=None, DeltaAction=None, Years=None, Months=None, Days=None):
        self.original_tagname_ = None
        self.Approximate = _cast(bool, Approximate)
        self.DeltaAction = _cast(None, DeltaAction)
        self.Years = Years
        self.Months = Months
        self.Days = Days
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DurationSchemaType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DurationSchemaType.subclass:
            return DurationSchemaType.subclass(*args_, **kwargs_)
        else:
            return DurationSchemaType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Years(self): return self.Years
    def set_Years(self, Years): self.Years = Years
    def get_Months(self): return self.Months
    def set_Months(self, Months): self.Months = Months
    def get_Days(self): return self.Days
    def set_Days(self, Days): self.Days = Days
    def get_Approximate(self): return self.Approximate
    def set_Approximate(self, Approximate): self.Approximate = Approximate
    def get_DeltaAction(self): return self.DeltaAction
    def set_DeltaAction(self, DeltaAction): self.DeltaAction = DeltaAction
    def validate_DeltaActionSchemaType(self, value):
        # Validate type DeltaActionSchemaType, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['add', 'amend', 'delete', 'revise']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on DeltaActionSchemaType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.Years is not None or
            self.Months is not None or
            self.Days is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='un:', name_='DurationSchemaType', namespacedef_='xmlns:un="http://www.un.org/sanctions/1.0"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DurationSchemaType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DurationSchemaType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='un:', name_='DurationSchemaType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='un:', name_='DurationSchemaType'):
        if self.Approximate is not None and 'Approximate' not in already_processed:
            already_processed.add('Approximate')
            outfile.write(' Approximate="%s"' % self.gds_format_boolean(self.Approximate, input_name='Approximate'))
        if self.DeltaAction is not None and 'DeltaAction' not in already_processed:
            already_processed.add('DeltaAction')
            outfile.write(' DeltaAction=%s' % (quote_attrib(self.DeltaAction), ))
    def exportChildren(self, outfile, level, namespace_='un:', name_='DurationSchemaType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Years is not None:
            self.Years.export(outfile, level, namespace_, name_='Years', pretty_print=pretty_print)
        if self.Months is not None:
            self.Months.export(outfile, level, namespace_, name_='Months', pretty_print=pretty_print)
        if self.Days is not None:
            self.Days.export(outfile, level, namespace_, name_='Days', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Approximate', node)
        if value is not None and 'Approximate' not in already_processed:
            already_processed.add('Approximate')
            if value in ('true', '1'):
                self.Approximate = True
            elif value in ('false', '0'):
                self.Approximate = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('DeltaAction', node)
        if value is not None and 'DeltaAction' not in already_processed:
            already_processed.add('DeltaAction')
            self.DeltaAction = value
            self.validate_DeltaActionSchemaType(self.DeltaAction)    # validate type DeltaActionSchemaType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Years':
            obj_ = YearsType.factory()
            obj_.build(child_)
            self.Years = obj_
            obj_.original_tagname_ = 'Years'
        elif nodeName_ == 'Months':
            obj_ = MonthsType.factory()
            obj_.build(child_)
            self.Months = obj_
            obj_.original_tagname_ = 'Months'
        elif nodeName_ == 'Days':
            obj_ = DaysType.factory()
            obj_.build(child_)
            self.Days = obj_
            obj_.original_tagname_ = 'Days'
# end class DurationSchemaType


class DateSchemaType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, CalendarTypeID=None, DeltaAction=None, Year=None, Month=None, Day=None):
        self.original_tagname_ = None
        self.CalendarTypeID = _cast(int, CalendarTypeID)
        self.DeltaAction = _cast(None, DeltaAction)
        self.Year = Year
        self.Month = Month
        self.Day = Day
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DateSchemaType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DateSchemaType.subclass:
            return DateSchemaType.subclass(*args_, **kwargs_)
        else:
            return DateSchemaType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Year(self): return self.Year
    def set_Year(self, Year): self.Year = Year
    def get_Month(self): return self.Month
    def set_Month(self, Month): self.Month = Month
    def get_Day(self): return self.Day
    def set_Day(self, Day): self.Day = Day
    def get_CalendarTypeID(self): return self.CalendarTypeID
    def set_CalendarTypeID(self, CalendarTypeID): self.CalendarTypeID = CalendarTypeID
    def get_DeltaAction(self): return self.DeltaAction
    def set_DeltaAction(self, DeltaAction): self.DeltaAction = DeltaAction
    def validate_DeltaActionSchemaType(self, value):
        # Validate type DeltaActionSchemaType, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['add', 'amend', 'delete', 'revise']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on DeltaActionSchemaType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.Year is not None or
            self.Month is not None or
            self.Day is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='un:', name_='DateSchemaType', namespacedef_='xmlns:un="http://www.un.org/sanctions/1.0"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DateSchemaType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DateSchemaType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='un:', name_='DateSchemaType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='un:', name_='DateSchemaType'):
        if self.CalendarTypeID is not None and 'CalendarTypeID' not in already_processed:
            already_processed.add('CalendarTypeID')
            outfile.write(' CalendarTypeID="%s"' % self.gds_format_integer(self.CalendarTypeID, input_name='CalendarTypeID'))
        if self.DeltaAction is not None and 'DeltaAction' not in already_processed:
            already_processed.add('DeltaAction')
            outfile.write(' DeltaAction=%s' % (quote_attrib(self.DeltaAction), ))
    def exportChildren(self, outfile, level, namespace_='un:', name_='DateSchemaType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Year is not None:
            self.Year.export(outfile, level, namespace_, name_='Year', pretty_print=pretty_print)
        if self.Month is not None:
            self.Month.export(outfile, level, namespace_, name_='Month', pretty_print=pretty_print)
        if self.Day is not None:
            self.Day.export(outfile, level, namespace_, name_='Day', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('CalendarTypeID', node)
        if value is not None and 'CalendarTypeID' not in already_processed:
            already_processed.add('CalendarTypeID')
            try:
                self.CalendarTypeID = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.CalendarTypeID < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = find_attr_value_('DeltaAction', node)
        if value is not None and 'DeltaAction' not in already_processed:
            already_processed.add('DeltaAction')
            self.DeltaAction = value
            self.validate_DeltaActionSchemaType(self.DeltaAction)    # validate type DeltaActionSchemaType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Year':
            obj_ = Year.factory()
            obj_.build(child_)
            self.Year = obj_
            obj_.original_tagname_ = 'Year'
        elif nodeName_ == 'Month':
            obj_ = Month.factory()
            obj_.build(child_)
            self.Month = obj_
            obj_.original_tagname_ = 'Month'
        elif nodeName_ == 'Day':
            obj_ = Day.factory()
            obj_.build(child_)
            self.Day = obj_
            obj_.original_tagname_ = 'Day'
# end class DateSchemaType


class LocationSchemaType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ID=None, DeltaAction=None, Comment=None, LocationAreaCode=None, LocationCountry=None, LocationPart=None, FeatureVersionReference=None, IDRegDocumentReference=None):
        self.original_tagname_ = None
        self.ID = _cast(int, ID)
        self.DeltaAction = _cast(None, DeltaAction)
        self.Comment = Comment
        if LocationAreaCode is None:
            self.LocationAreaCode = []
        else:
            self.LocationAreaCode = LocationAreaCode
        if LocationCountry is None:
            self.LocationCountry = []
        else:
            self.LocationCountry = LocationCountry
        if LocationPart is None:
            self.LocationPart = []
        else:
            self.LocationPart = LocationPart
        if FeatureVersionReference is None:
            self.FeatureVersionReference = []
        else:
            self.FeatureVersionReference = FeatureVersionReference
        if IDRegDocumentReference is None:
            self.IDRegDocumentReference = []
        else:
            self.IDRegDocumentReference = IDRegDocumentReference
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, LocationSchemaType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LocationSchemaType.subclass:
            return LocationSchemaType.subclass(*args_, **kwargs_)
        else:
            return LocationSchemaType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Comment(self): return self.Comment
    def set_Comment(self, Comment): self.Comment = Comment
    def get_LocationAreaCode(self): return self.LocationAreaCode
    def set_LocationAreaCode(self, LocationAreaCode): self.LocationAreaCode = LocationAreaCode
    def add_LocationAreaCode(self, value): self.LocationAreaCode.append(value)
    def insert_LocationAreaCode_at(self, index, value): self.LocationAreaCode.insert(index, value)
    def replace_LocationAreaCode_at(self, index, value): self.LocationAreaCode[index] = value
    def get_LocationCountry(self): return self.LocationCountry
    def set_LocationCountry(self, LocationCountry): self.LocationCountry = LocationCountry
    def add_LocationCountry(self, value): self.LocationCountry.append(value)
    def insert_LocationCountry_at(self, index, value): self.LocationCountry.insert(index, value)
    def replace_LocationCountry_at(self, index, value): self.LocationCountry[index] = value
    def get_LocationPart(self): return self.LocationPart
    def set_LocationPart(self, LocationPart): self.LocationPart = LocationPart
    def add_LocationPart(self, value): self.LocationPart.append(value)
    def insert_LocationPart_at(self, index, value): self.LocationPart.insert(index, value)
    def replace_LocationPart_at(self, index, value): self.LocationPart[index] = value
    def get_FeatureVersionReference(self): return self.FeatureVersionReference
    def set_FeatureVersionReference(self, FeatureVersionReference): self.FeatureVersionReference = FeatureVersionReference
    def add_FeatureVersionReference(self, value): self.FeatureVersionReference.append(value)
    def insert_FeatureVersionReference_at(self, index, value): self.FeatureVersionReference.insert(index, value)
    def replace_FeatureVersionReference_at(self, index, value): self.FeatureVersionReference[index] = value
    def get_IDRegDocumentReference(self): return self.IDRegDocumentReference
    def set_IDRegDocumentReference(self, IDRegDocumentReference): self.IDRegDocumentReference = IDRegDocumentReference
    def add_IDRegDocumentReference(self, value): self.IDRegDocumentReference.append(value)
    def insert_IDRegDocumentReference_at(self, index, value): self.IDRegDocumentReference.insert(index, value)
    def replace_IDRegDocumentReference_at(self, index, value): self.IDRegDocumentReference[index] = value
    def get_ID(self): return self.ID
    def set_ID(self, ID): self.ID = ID
    def get_DeltaAction(self): return self.DeltaAction
    def set_DeltaAction(self, DeltaAction): self.DeltaAction = DeltaAction
    def validate_DeltaActionSchemaType(self, value):
        # Validate type DeltaActionSchemaType, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['add', 'amend', 'delete', 'revise']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on DeltaActionSchemaType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.Comment is not None or
            self.LocationAreaCode or
            self.LocationCountry or
            self.LocationPart or
            self.FeatureVersionReference or
            self.IDRegDocumentReference
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='un:', name_='LocationSchemaType', namespacedef_='xmlns:un="http://www.un.org/sanctions/1.0"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('LocationSchemaType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LocationSchemaType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='un:', name_='LocationSchemaType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='un:', name_='LocationSchemaType'):
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            outfile.write(' ID="%s"' % self.gds_format_integer(self.ID, input_name='ID'))
        if self.DeltaAction is not None and 'DeltaAction' not in already_processed:
            already_processed.add('DeltaAction')
            outfile.write(' DeltaAction=%s' % (quote_attrib(self.DeltaAction), ))
    def exportChildren(self, outfile, level, namespace_='un:', name_='LocationSchemaType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Comment is not None:
            self.Comment.export(outfile, level, namespace_, name_='Comment', pretty_print=pretty_print)
        for LocationAreaCode_ in self.LocationAreaCode:
            LocationAreaCode_.export(outfile, level, namespace_, name_='LocationAreaCode', pretty_print=pretty_print)
        for LocationCountry_ in self.LocationCountry:
            LocationCountry_.export(outfile, level, namespace_, name_='LocationCountry', pretty_print=pretty_print)
        for LocationPart_ in self.LocationPart:
            LocationPart_.export(outfile, level, namespace_, name_='LocationPart', pretty_print=pretty_print)
        for FeatureVersionReference_ in self.FeatureVersionReference:
            FeatureVersionReference_.export(outfile, level, namespace_, name_='FeatureVersionReference', pretty_print=pretty_print)
        for IDRegDocumentReference_ in self.IDRegDocumentReference:
            IDRegDocumentReference_.export(outfile, level, namespace_, name_='IDRegDocumentReference', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            try:
                self.ID = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.ID < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = find_attr_value_('DeltaAction', node)
        if value is not None and 'DeltaAction' not in already_processed:
            already_processed.add('DeltaAction')
            self.DeltaAction = value
            self.validate_DeltaActionSchemaType(self.DeltaAction)    # validate type DeltaActionSchemaType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Comment':
            obj_ = Comment.factory()
            obj_.build(child_)
            self.Comment = obj_
            obj_.original_tagname_ = 'Comment'
        elif nodeName_ == 'LocationAreaCode':
            obj_ = LocationAreaCodeType.factory()
            obj_.build(child_)
            self.LocationAreaCode.append(obj_)
            obj_.original_tagname_ = 'LocationAreaCode'
        elif nodeName_ == 'LocationCountry':
            obj_ = LocationCountryType.factory()
            obj_.build(child_)
            self.LocationCountry.append(obj_)
            obj_.original_tagname_ = 'LocationCountry'
        elif nodeName_ == 'LocationPart':
            obj_ = LocationPartType.factory()
            obj_.build(child_)
            self.LocationPart.append(obj_)
            obj_.original_tagname_ = 'LocationPart'
        elif nodeName_ == 'FeatureVersionReference':
            obj_ = FeatureVersionReference.factory()
            obj_.build(child_)
            self.FeatureVersionReference.append(obj_)
            obj_.original_tagname_ = 'FeatureVersionReference'
        elif nodeName_ == 'IDRegDocumentReference':
            obj_ = IDRegDocumentReference.factory()
            obj_.build(child_)
            self.IDRegDocumentReference.append(obj_)
            obj_.original_tagname_ = 'IDRegDocumentReference'
# end class LocationSchemaType


class IDRegDocumentSchemaType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ID=None, IDRegDocTypeID=None, IdentityID=None, IssuedBy_CountryID=None, IssuedIn_LocationID=None, ValidityID=None, DeltaAction=None, Comment=None, IDRegistrationNo=None, IssuingAuthority=None, DocumentDate=None, IDRegDocumentMention=None, FeatureVersionReference=None, DocumentedNameReference=None, ProfileRelationshipReference=None):
        self.original_tagname_ = None
        self.ID = _cast(int, ID)
        self.IDRegDocTypeID = _cast(int, IDRegDocTypeID)
        self.IdentityID = _cast(int, IdentityID)
        self.IssuedBy_CountryID = _cast(int, IssuedBy_CountryID)
        self.IssuedIn_LocationID = _cast(int, IssuedIn_LocationID)
        self.ValidityID = _cast(int, ValidityID)
        self.DeltaAction = _cast(None, DeltaAction)
        self.Comment = Comment
        self.IDRegistrationNo = IDRegistrationNo
        self.IssuingAuthority = IssuingAuthority
        if DocumentDate is None:
            self.DocumentDate = []
        else:
            self.DocumentDate = DocumentDate
        if IDRegDocumentMention is None:
            self.IDRegDocumentMention = []
        else:
            self.IDRegDocumentMention = IDRegDocumentMention
        if FeatureVersionReference is None:
            self.FeatureVersionReference = []
        else:
            self.FeatureVersionReference = FeatureVersionReference
        if DocumentedNameReference is None:
            self.DocumentedNameReference = []
        else:
            self.DocumentedNameReference = DocumentedNameReference
        if ProfileRelationshipReference is None:
            self.ProfileRelationshipReference = []
        else:
            self.ProfileRelationshipReference = ProfileRelationshipReference
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, IDRegDocumentSchemaType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if IDRegDocumentSchemaType.subclass:
            return IDRegDocumentSchemaType.subclass(*args_, **kwargs_)
        else:
            return IDRegDocumentSchemaType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Comment(self): return self.Comment
    def set_Comment(self, Comment): self.Comment = Comment
    def get_IDRegistrationNo(self): return self.IDRegistrationNo
    def set_IDRegistrationNo(self, IDRegistrationNo): self.IDRegistrationNo = IDRegistrationNo
    def get_IssuingAuthority(self): return self.IssuingAuthority
    def set_IssuingAuthority(self, IssuingAuthority): self.IssuingAuthority = IssuingAuthority
    def get_DocumentDate(self): return self.DocumentDate
    def set_DocumentDate(self, DocumentDate): self.DocumentDate = DocumentDate
    def add_DocumentDate(self, value): self.DocumentDate.append(value)
    def insert_DocumentDate_at(self, index, value): self.DocumentDate.insert(index, value)
    def replace_DocumentDate_at(self, index, value): self.DocumentDate[index] = value
    def get_IDRegDocumentMention(self): return self.IDRegDocumentMention
    def set_IDRegDocumentMention(self, IDRegDocumentMention): self.IDRegDocumentMention = IDRegDocumentMention
    def add_IDRegDocumentMention(self, value): self.IDRegDocumentMention.append(value)
    def insert_IDRegDocumentMention_at(self, index, value): self.IDRegDocumentMention.insert(index, value)
    def replace_IDRegDocumentMention_at(self, index, value): self.IDRegDocumentMention[index] = value
    def get_FeatureVersionReference(self): return self.FeatureVersionReference
    def set_FeatureVersionReference(self, FeatureVersionReference): self.FeatureVersionReference = FeatureVersionReference
    def add_FeatureVersionReference(self, value): self.FeatureVersionReference.append(value)
    def insert_FeatureVersionReference_at(self, index, value): self.FeatureVersionReference.insert(index, value)
    def replace_FeatureVersionReference_at(self, index, value): self.FeatureVersionReference[index] = value
    def get_DocumentedNameReference(self): return self.DocumentedNameReference
    def set_DocumentedNameReference(self, DocumentedNameReference): self.DocumentedNameReference = DocumentedNameReference
    def add_DocumentedNameReference(self, value): self.DocumentedNameReference.append(value)
    def insert_DocumentedNameReference_at(self, index, value): self.DocumentedNameReference.insert(index, value)
    def replace_DocumentedNameReference_at(self, index, value): self.DocumentedNameReference[index] = value
    def get_ProfileRelationshipReference(self): return self.ProfileRelationshipReference
    def set_ProfileRelationshipReference(self, ProfileRelationshipReference): self.ProfileRelationshipReference = ProfileRelationshipReference
    def add_ProfileRelationshipReference(self, value): self.ProfileRelationshipReference.append(value)
    def insert_ProfileRelationshipReference_at(self, index, value): self.ProfileRelationshipReference.insert(index, value)
    def replace_ProfileRelationshipReference_at(self, index, value): self.ProfileRelationshipReference[index] = value
    def get_ID(self): return self.ID
    def set_ID(self, ID): self.ID = ID
    def get_IDRegDocTypeID(self): return self.IDRegDocTypeID
    def set_IDRegDocTypeID(self, IDRegDocTypeID): self.IDRegDocTypeID = IDRegDocTypeID
    def get_IdentityID(self): return self.IdentityID
    def set_IdentityID(self, IdentityID): self.IdentityID = IdentityID
    def get_IssuedBy_CountryID(self): return self.IssuedBy_CountryID
    def set_IssuedBy_CountryID(self, IssuedBy_CountryID): self.IssuedBy_CountryID = IssuedBy_CountryID
    def get_IssuedIn_LocationID(self): return self.IssuedIn_LocationID
    def set_IssuedIn_LocationID(self, IssuedIn_LocationID): self.IssuedIn_LocationID = IssuedIn_LocationID
    def get_ValidityID(self): return self.ValidityID
    def set_ValidityID(self, ValidityID): self.ValidityID = ValidityID
    def get_DeltaAction(self): return self.DeltaAction
    def set_DeltaAction(self, DeltaAction): self.DeltaAction = DeltaAction
    def validate_DeltaActionSchemaType(self, value):
        # Validate type DeltaActionSchemaType, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['add', 'amend', 'delete', 'revise']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on DeltaActionSchemaType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.Comment is not None or
            self.IDRegistrationNo is not None or
            self.IssuingAuthority is not None or
            self.DocumentDate or
            self.IDRegDocumentMention or
            self.FeatureVersionReference or
            self.DocumentedNameReference or
            self.ProfileRelationshipReference
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='un:', name_='IDRegDocumentSchemaType', namespacedef_='xmlns:un="http://www.un.org/sanctions/1.0"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('IDRegDocumentSchemaType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='IDRegDocumentSchemaType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='un:', name_='IDRegDocumentSchemaType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='un:', name_='IDRegDocumentSchemaType'):
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            outfile.write(' ID="%s"' % self.gds_format_integer(self.ID, input_name='ID'))
        if self.IDRegDocTypeID is not None and 'IDRegDocTypeID' not in already_processed:
            already_processed.add('IDRegDocTypeID')
            outfile.write(' IDRegDocTypeID="%s"' % self.gds_format_integer(self.IDRegDocTypeID, input_name='IDRegDocTypeID'))
        if self.IdentityID is not None and 'IdentityID' not in already_processed:
            already_processed.add('IdentityID')
            outfile.write(' IdentityID="%s"' % self.gds_format_integer(self.IdentityID, input_name='IdentityID'))
        if self.IssuedBy_CountryID is not None and 'IssuedBy_CountryID' not in already_processed:
            already_processed.add('IssuedBy_CountryID')
            outfile.write(' IssuedBy-CountryID="%s"' % self.gds_format_integer(self.IssuedBy_CountryID, input_name='IssuedBy-CountryID'))
        if self.IssuedIn_LocationID is not None and 'IssuedIn_LocationID' not in already_processed:
            already_processed.add('IssuedIn_LocationID')
            outfile.write(' IssuedIn-LocationID="%s"' % self.gds_format_integer(self.IssuedIn_LocationID, input_name='IssuedIn-LocationID'))
        if self.ValidityID is not None and 'ValidityID' not in already_processed:
            already_processed.add('ValidityID')
            outfile.write(' ValidityID="%s"' % self.gds_format_integer(self.ValidityID, input_name='ValidityID'))
        if self.DeltaAction is not None and 'DeltaAction' not in already_processed:
            already_processed.add('DeltaAction')
            outfile.write(' DeltaAction=%s' % (quote_attrib(self.DeltaAction), ))
    def exportChildren(self, outfile, level, namespace_='un:', name_='IDRegDocumentSchemaType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Comment is not None:
            self.Comment.export(outfile, level, namespace_, name_='Comment', pretty_print=pretty_print)
        if self.IDRegistrationNo is not None:
            self.IDRegistrationNo.export(outfile, level, namespace_, name_='IDRegistrationNo', pretty_print=pretty_print)
        if self.IssuingAuthority is not None:
            self.IssuingAuthority.export(outfile, level, namespace_, name_='IssuingAuthority', pretty_print=pretty_print)
        for DocumentDate_ in self.DocumentDate:
            DocumentDate_.export(outfile, level, namespace_, name_='DocumentDate', pretty_print=pretty_print)
        for IDRegDocumentMention_ in self.IDRegDocumentMention:
            IDRegDocumentMention_.export(outfile, level, namespace_, name_='IDRegDocumentMention', pretty_print=pretty_print)
        for FeatureVersionReference_ in self.FeatureVersionReference:
            FeatureVersionReference_.export(outfile, level, namespace_, name_='FeatureVersionReference', pretty_print=pretty_print)
        for DocumentedNameReference_ in self.DocumentedNameReference:
            DocumentedNameReference_.export(outfile, level, namespace_, name_='DocumentedNameReference', pretty_print=pretty_print)
        for ProfileRelationshipReference_ in self.ProfileRelationshipReference:
            ProfileRelationshipReference_.export(outfile, level, namespace_, name_='ProfileRelationshipReference', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            try:
                self.ID = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.ID < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = find_attr_value_('IDRegDocTypeID', node)
        if value is not None and 'IDRegDocTypeID' not in already_processed:
            already_processed.add('IDRegDocTypeID')
            try:
                self.IDRegDocTypeID = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.IDRegDocTypeID < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = find_attr_value_('IdentityID', node)
        if value is not None and 'IdentityID' not in already_processed:
            already_processed.add('IdentityID')
            try:
                self.IdentityID = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.IdentityID < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = find_attr_value_('IssuedBy-CountryID', node)
        if value is not None and 'IssuedBy-CountryID' not in already_processed:
            already_processed.add('IssuedBy-CountryID')
            try:
                self.IssuedBy_CountryID = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.IssuedBy_CountryID < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = find_attr_value_('IssuedIn-LocationID', node)
        if value is not None and 'IssuedIn-LocationID' not in already_processed:
            already_processed.add('IssuedIn-LocationID')
            try:
                self.IssuedIn_LocationID = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.IssuedIn_LocationID < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = find_attr_value_('ValidityID', node)
        if value is not None and 'ValidityID' not in already_processed:
            already_processed.add('ValidityID')
            try:
                self.ValidityID = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.ValidityID < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = find_attr_value_('DeltaAction', node)
        if value is not None and 'DeltaAction' not in already_processed:
            already_processed.add('DeltaAction')
            self.DeltaAction = value
            self.validate_DeltaActionSchemaType(self.DeltaAction)    # validate type DeltaActionSchemaType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Comment':
            obj_ = Comment.factory()
            obj_.build(child_)
            self.Comment = obj_
            obj_.original_tagname_ = 'Comment'
        elif nodeName_ == 'IDRegistrationNo':
            obj_ = IDRegistrationNoType.factory()
            obj_.build(child_)
            self.IDRegistrationNo = obj_
            obj_.original_tagname_ = 'IDRegistrationNo'
        elif nodeName_ == 'IssuingAuthority':
            obj_ = IssuingAuthorityType.factory()
            obj_.build(child_)
            self.IssuingAuthority = obj_
            obj_.original_tagname_ = 'IssuingAuthority'
        elif nodeName_ == 'DocumentDate':
            obj_ = DocumentDateType.factory()
            obj_.build(child_)
            self.DocumentDate.append(obj_)
            obj_.original_tagname_ = 'DocumentDate'
        elif nodeName_ == 'IDRegDocumentMention':
            obj_ = IDRegDocumentMentionType.factory()
            obj_.build(child_)
            self.IDRegDocumentMention.append(obj_)
            obj_.original_tagname_ = 'IDRegDocumentMention'
        elif nodeName_ == 'FeatureVersionReference':
            obj_ = FeatureVersionReference.factory()
            obj_.build(child_)
            self.FeatureVersionReference.append(obj_)
            obj_.original_tagname_ = 'FeatureVersionReference'
        elif nodeName_ == 'DocumentedNameReference':
            obj_ = DocumentedNameReferenceType.factory()
            obj_.build(child_)
            self.DocumentedNameReference.append(obj_)
            obj_.original_tagname_ = 'DocumentedNameReference'
        elif nodeName_ == 'ProfileRelationshipReference':
            obj_ = ProfileRelationshipReference.factory()
            obj_.build(child_)
            self.ProfileRelationshipReference.append(obj_)
            obj_.original_tagname_ = 'ProfileRelationshipReference'
# end class IDRegDocumentSchemaType


class DistinctPartySchemaType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, FixedRef=None, DeltaAction=None, Comment=None, Profile=None):
        self.original_tagname_ = None
        self.FixedRef = _cast(None, FixedRef)
        self.DeltaAction = _cast(None, DeltaAction)
        if Comment is None:
            self.Comment = []
        else:
            self.Comment = Comment
        if Profile is None:
            self.Profile = []
        else:
            self.Profile = Profile
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DistinctPartySchemaType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DistinctPartySchemaType.subclass:
            return DistinctPartySchemaType.subclass(*args_, **kwargs_)
        else:
            return DistinctPartySchemaType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Comment(self): return self.Comment
    def set_Comment(self, Comment): self.Comment = Comment
    def add_Comment(self, value): self.Comment.append(value)
    def insert_Comment_at(self, index, value): self.Comment.insert(index, value)
    def replace_Comment_at(self, index, value): self.Comment[index] = value
    def get_Profile(self): return self.Profile
    def set_Profile(self, Profile): self.Profile = Profile
    def add_Profile(self, value): self.Profile.append(value)
    def insert_Profile_at(self, index, value): self.Profile.insert(index, value)
    def replace_Profile_at(self, index, value): self.Profile[index] = value
    def get_FixedRef(self): return self.FixedRef
    def set_FixedRef(self, FixedRef): self.FixedRef = FixedRef
    def get_DeltaAction(self): return self.DeltaAction
    def set_DeltaAction(self, DeltaAction): self.DeltaAction = DeltaAction
    def validate_DeltaActionSchemaType(self, value):
        # Validate type DeltaActionSchemaType, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['add', 'amend', 'delete', 'revise']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on DeltaActionSchemaType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.Comment or
            self.Profile
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='un:', name_='DistinctPartySchemaType', namespacedef_='xmlns:un="http://www.un.org/sanctions/1.0"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DistinctPartySchemaType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DistinctPartySchemaType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='un:', name_='DistinctPartySchemaType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='un:', name_='DistinctPartySchemaType'):
        if self.FixedRef is not None and 'FixedRef' not in already_processed:
            already_processed.add('FixedRef')
            outfile.write(' FixedRef=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.FixedRef), input_name='FixedRef')), ))
        if self.DeltaAction is not None and 'DeltaAction' not in already_processed:
            already_processed.add('DeltaAction')
            outfile.write(' DeltaAction=%s' % (quote_attrib(self.DeltaAction), ))
    def exportChildren(self, outfile, level, namespace_='un:', name_='DistinctPartySchemaType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Comment_ in self.Comment:
            Comment_.export(outfile, level, namespace_, name_='Comment', pretty_print=pretty_print)
        for Profile_ in self.Profile:
            Profile_.export(outfile, level, namespace_, name_='Profile', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('FixedRef', node)
        if value is not None and 'FixedRef' not in already_processed:
            already_processed.add('FixedRef')
            self.FixedRef = value
        value = find_attr_value_('DeltaAction', node)
        if value is not None and 'DeltaAction' not in already_processed:
            already_processed.add('DeltaAction')
            self.DeltaAction = value
            self.validate_DeltaActionSchemaType(self.DeltaAction)    # validate type DeltaActionSchemaType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Comment':
            obj_ = Comment.factory()
            obj_.build(child_)
            self.Comment.append(obj_)
            obj_.original_tagname_ = 'Comment'
        elif nodeName_ == 'Profile':
            obj_ = ProfileType.factory()
            obj_.build(child_)
            self.Profile.append(obj_)
            obj_.original_tagname_ = 'Profile'
# end class DistinctPartySchemaType


class FeatureSchemaType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ID=None, FeatureTypeID=None, DeltaAction=None, FeatureVersion=None, IdentityReference=None):
        self.original_tagname_ = None
        self.ID = _cast(int, ID)
        self.FeatureTypeID = _cast(int, FeatureTypeID)
        self.DeltaAction = _cast(None, DeltaAction)
        if FeatureVersion is None:
            self.FeatureVersion = []
        else:
            self.FeatureVersion = FeatureVersion
        if IdentityReference is None:
            self.IdentityReference = []
        else:
            self.IdentityReference = IdentityReference
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FeatureSchemaType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FeatureSchemaType.subclass:
            return FeatureSchemaType.subclass(*args_, **kwargs_)
        else:
            return FeatureSchemaType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_FeatureVersion(self): return self.FeatureVersion
    def set_FeatureVersion(self, FeatureVersion): self.FeatureVersion = FeatureVersion
    def add_FeatureVersion(self, value): self.FeatureVersion.append(value)
    def insert_FeatureVersion_at(self, index, value): self.FeatureVersion.insert(index, value)
    def replace_FeatureVersion_at(self, index, value): self.FeatureVersion[index] = value
    def get_IdentityReference(self): return self.IdentityReference
    def set_IdentityReference(self, IdentityReference): self.IdentityReference = IdentityReference
    def add_IdentityReference(self, value): self.IdentityReference.append(value)
    def insert_IdentityReference_at(self, index, value): self.IdentityReference.insert(index, value)
    def replace_IdentityReference_at(self, index, value): self.IdentityReference[index] = value
    def get_ID(self): return self.ID
    def set_ID(self, ID): self.ID = ID
    def get_FeatureTypeID(self): return self.FeatureTypeID
    def set_FeatureTypeID(self, FeatureTypeID): self.FeatureTypeID = FeatureTypeID
    def get_DeltaAction(self): return self.DeltaAction
    def set_DeltaAction(self, DeltaAction): self.DeltaAction = DeltaAction
    def validate_DeltaActionSchemaType(self, value):
        # Validate type DeltaActionSchemaType, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['add', 'amend', 'delete', 'revise']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on DeltaActionSchemaType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.FeatureVersion or
            self.IdentityReference
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='un:', name_='FeatureSchemaType', namespacedef_='xmlns:un="http://www.un.org/sanctions/1.0"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('FeatureSchemaType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FeatureSchemaType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='un:', name_='FeatureSchemaType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='un:', name_='FeatureSchemaType'):
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            outfile.write(' ID="%s"' % self.gds_format_integer(self.ID, input_name='ID'))
        if self.FeatureTypeID is not None and 'FeatureTypeID' not in already_processed:
            already_processed.add('FeatureTypeID')
            outfile.write(' FeatureTypeID="%s"' % self.gds_format_integer(self.FeatureTypeID, input_name='FeatureTypeID'))
        if self.DeltaAction is not None and 'DeltaAction' not in already_processed:
            already_processed.add('DeltaAction')
            outfile.write(' DeltaAction=%s' % (quote_attrib(self.DeltaAction), ))
    def exportChildren(self, outfile, level, namespace_='un:', name_='FeatureSchemaType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for FeatureVersion_ in self.FeatureVersion:
            FeatureVersion_.export(outfile, level, namespace_, name_='FeatureVersion', pretty_print=pretty_print)
        for IdentityReference_ in self.IdentityReference:
            IdentityReference_.export(outfile, level, namespace_, name_='IdentityReference', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            try:
                self.ID = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.ID < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = find_attr_value_('FeatureTypeID', node)
        if value is not None and 'FeatureTypeID' not in already_processed:
            already_processed.add('FeatureTypeID')
            try:
                self.FeatureTypeID = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.FeatureTypeID < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = find_attr_value_('DeltaAction', node)
        if value is not None and 'DeltaAction' not in already_processed:
            already_processed.add('DeltaAction')
            self.DeltaAction = value
            self.validate_DeltaActionSchemaType(self.DeltaAction)    # validate type DeltaActionSchemaType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'FeatureVersion':
            obj_ = FeatureVersionType.factory()
            obj_.build(child_)
            self.FeatureVersion.append(obj_)
            obj_.original_tagname_ = 'FeatureVersion'
        elif nodeName_ == 'IdentityReference':
            obj_ = IdentityReferenceType.factory()
            obj_.build(child_)
            self.IdentityReference.append(obj_)
            obj_.original_tagname_ = 'IdentityReference'
# end class FeatureSchemaType


class IdentitySchemaType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ID=None, FixedRef=None, Primary=None, False_=None, DeltaAction=None, Comment=None, Alias=None, NamePartGroups=None, IDRegDocumentReference=None):
        self.original_tagname_ = None
        self.ID = _cast(int, ID)
        self.FixedRef = _cast(None, FixedRef)
        self.Primary = _cast(bool, Primary)
        self.False_ = _cast(bool, False_)
        self.DeltaAction = _cast(None, DeltaAction)
        self.Comment = Comment
        if Alias is None:
            self.Alias = []
        else:
            self.Alias = Alias
        self.NamePartGroups = NamePartGroups
        if IDRegDocumentReference is None:
            self.IDRegDocumentReference = []
        else:
            self.IDRegDocumentReference = IDRegDocumentReference
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, IdentitySchemaType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if IdentitySchemaType.subclass:
            return IdentitySchemaType.subclass(*args_, **kwargs_)
        else:
            return IdentitySchemaType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Comment(self): return self.Comment
    def set_Comment(self, Comment): self.Comment = Comment
    def get_Alias(self): return self.Alias
    def set_Alias(self, Alias): self.Alias = Alias
    def add_Alias(self, value): self.Alias.append(value)
    def insert_Alias_at(self, index, value): self.Alias.insert(index, value)
    def replace_Alias_at(self, index, value): self.Alias[index] = value
    def get_NamePartGroups(self): return self.NamePartGroups
    def set_NamePartGroups(self, NamePartGroups): self.NamePartGroups = NamePartGroups
    def get_IDRegDocumentReference(self): return self.IDRegDocumentReference
    def set_IDRegDocumentReference(self, IDRegDocumentReference): self.IDRegDocumentReference = IDRegDocumentReference
    def add_IDRegDocumentReference(self, value): self.IDRegDocumentReference.append(value)
    def insert_IDRegDocumentReference_at(self, index, value): self.IDRegDocumentReference.insert(index, value)
    def replace_IDRegDocumentReference_at(self, index, value): self.IDRegDocumentReference[index] = value
    def get_ID(self): return self.ID
    def set_ID(self, ID): self.ID = ID
    def get_FixedRef(self): return self.FixedRef
    def set_FixedRef(self, FixedRef): self.FixedRef = FixedRef
    def get_Primary(self): return self.Primary
    def set_Primary(self, Primary): self.Primary = Primary
    def get_False(self): return self.False_
    def set_False(self, False_): self.False_ = False_
    def get_DeltaAction(self): return self.DeltaAction
    def set_DeltaAction(self, DeltaAction): self.DeltaAction = DeltaAction
    def validate_DeltaActionSchemaType(self, value):
        # Validate type DeltaActionSchemaType, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['add', 'amend', 'delete', 'revise']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on DeltaActionSchemaType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.Comment is not None or
            self.Alias or
            self.NamePartGroups is not None or
            self.IDRegDocumentReference
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='un:', name_='IdentitySchemaType', namespacedef_='xmlns:un="http://www.un.org/sanctions/1.0"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('IdentitySchemaType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='IdentitySchemaType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='un:', name_='IdentitySchemaType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='un:', name_='IdentitySchemaType'):
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            outfile.write(' ID="%s"' % self.gds_format_integer(self.ID, input_name='ID'))
        if self.FixedRef is not None and 'FixedRef' not in already_processed:
            already_processed.add('FixedRef')
            outfile.write(' FixedRef=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.FixedRef), input_name='FixedRef')), ))
        if self.Primary is not None and 'Primary' not in already_processed:
            already_processed.add('Primary')
            outfile.write(' Primary="%s"' % self.gds_format_boolean(self.Primary, input_name='Primary'))
        if self.False_ is not None and 'False_' not in already_processed:
            already_processed.add('False_')
            outfile.write(' False="%s"' % self.gds_format_boolean(self.False_, input_name='False'))
        if self.DeltaAction is not None and 'DeltaAction' not in already_processed:
            already_processed.add('DeltaAction')
            outfile.write(' DeltaAction=%s' % (quote_attrib(self.DeltaAction), ))
    def exportChildren(self, outfile, level, namespace_='un:', name_='IdentitySchemaType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Comment is not None:
            self.Comment.export(outfile, level, namespace_, name_='Comment', pretty_print=pretty_print)
        for Alias_ in self.Alias:
            Alias_.export(outfile, level, namespace_, name_='Alias', pretty_print=pretty_print)
        if self.NamePartGroups is not None:
            self.NamePartGroups.export(outfile, level, namespace_, name_='NamePartGroups', pretty_print=pretty_print)
        for IDRegDocumentReference_ in self.IDRegDocumentReference:
            IDRegDocumentReference_.export(outfile, level, namespace_, name_='IDRegDocumentReference', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            try:
                self.ID = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.ID < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = find_attr_value_('FixedRef', node)
        if value is not None and 'FixedRef' not in already_processed:
            already_processed.add('FixedRef')
            self.FixedRef = value
        value = find_attr_value_('Primary', node)
        if value is not None and 'Primary' not in already_processed:
            already_processed.add('Primary')
            if value in ('true', '1'):
                self.Primary = True
            elif value in ('false', '0'):
                self.Primary = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('False', node)
        if value is not None and 'False' not in already_processed:
            already_processed.add('False')
            if value in ('true', '1'):
                self.False_ = True
            elif value in ('false', '0'):
                self.False_ = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('DeltaAction', node)
        if value is not None and 'DeltaAction' not in already_processed:
            already_processed.add('DeltaAction')
            self.DeltaAction = value
            self.validate_DeltaActionSchemaType(self.DeltaAction)    # validate type DeltaActionSchemaType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Comment':
            obj_ = Comment.factory()
            obj_.build(child_)
            self.Comment = obj_
            obj_.original_tagname_ = 'Comment'
        elif nodeName_ == 'Alias':
            obj_ = AliasType3.factory()
            obj_.build(child_)
            self.Alias.append(obj_)
            obj_.original_tagname_ = 'Alias'
        elif nodeName_ == 'NamePartGroups':
            obj_ = NamePartGroupsType.factory()
            obj_.build(child_)
            self.NamePartGroups = obj_
            obj_.original_tagname_ = 'NamePartGroups'
        elif nodeName_ == 'IDRegDocumentReference':
            obj_ = IDRegDocumentReference.factory()
            obj_.build(child_)
            self.IDRegDocumentReference.append(obj_)
            obj_.original_tagname_ = 'IDRegDocumentReference'
# end class IdentitySchemaType


class DocumentedNameSchemaType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ID=None, FixedRef=None, DocNameStatusID=None, DeltaAction=None, Comment=None, DocumentedNamePart=None, DocumentedNameCountry=None, IDRegDocumentReference=None):
        self.original_tagname_ = None
        self.ID = _cast(int, ID)
        self.FixedRef = _cast(None, FixedRef)
        self.DocNameStatusID = _cast(int, DocNameStatusID)
        self.DeltaAction = _cast(None, DeltaAction)
        self.Comment = Comment
        if DocumentedNamePart is None:
            self.DocumentedNamePart = []
        else:
            self.DocumentedNamePart = DocumentedNamePart
        if DocumentedNameCountry is None:
            self.DocumentedNameCountry = []
        else:
            self.DocumentedNameCountry = DocumentedNameCountry
        if IDRegDocumentReference is None:
            self.IDRegDocumentReference = []
        else:
            self.IDRegDocumentReference = IDRegDocumentReference
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DocumentedNameSchemaType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DocumentedNameSchemaType.subclass:
            return DocumentedNameSchemaType.subclass(*args_, **kwargs_)
        else:
            return DocumentedNameSchemaType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Comment(self): return self.Comment
    def set_Comment(self, Comment): self.Comment = Comment
    def get_DocumentedNamePart(self): return self.DocumentedNamePart
    def set_DocumentedNamePart(self, DocumentedNamePart): self.DocumentedNamePart = DocumentedNamePart
    def add_DocumentedNamePart(self, value): self.DocumentedNamePart.append(value)
    def insert_DocumentedNamePart_at(self, index, value): self.DocumentedNamePart.insert(index, value)
    def replace_DocumentedNamePart_at(self, index, value): self.DocumentedNamePart[index] = value
    def get_DocumentedNameCountry(self): return self.DocumentedNameCountry
    def set_DocumentedNameCountry(self, DocumentedNameCountry): self.DocumentedNameCountry = DocumentedNameCountry
    def add_DocumentedNameCountry(self, value): self.DocumentedNameCountry.append(value)
    def insert_DocumentedNameCountry_at(self, index, value): self.DocumentedNameCountry.insert(index, value)
    def replace_DocumentedNameCountry_at(self, index, value): self.DocumentedNameCountry[index] = value
    def get_IDRegDocumentReference(self): return self.IDRegDocumentReference
    def set_IDRegDocumentReference(self, IDRegDocumentReference): self.IDRegDocumentReference = IDRegDocumentReference
    def add_IDRegDocumentReference(self, value): self.IDRegDocumentReference.append(value)
    def insert_IDRegDocumentReference_at(self, index, value): self.IDRegDocumentReference.insert(index, value)
    def replace_IDRegDocumentReference_at(self, index, value): self.IDRegDocumentReference[index] = value
    def get_ID(self): return self.ID
    def set_ID(self, ID): self.ID = ID
    def get_FixedRef(self): return self.FixedRef
    def set_FixedRef(self, FixedRef): self.FixedRef = FixedRef
    def get_DocNameStatusID(self): return self.DocNameStatusID
    def set_DocNameStatusID(self, DocNameStatusID): self.DocNameStatusID = DocNameStatusID
    def get_DeltaAction(self): return self.DeltaAction
    def set_DeltaAction(self, DeltaAction): self.DeltaAction = DeltaAction
    def validate_DeltaActionSchemaType(self, value):
        # Validate type DeltaActionSchemaType, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['add', 'amend', 'delete', 'revise']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on DeltaActionSchemaType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.Comment is not None or
            self.DocumentedNamePart or
            self.DocumentedNameCountry or
            self.IDRegDocumentReference
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='un:', name_='DocumentedNameSchemaType', namespacedef_='xmlns:un="http://www.un.org/sanctions/1.0"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DocumentedNameSchemaType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DocumentedNameSchemaType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='un:', name_='DocumentedNameSchemaType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='un:', name_='DocumentedNameSchemaType'):
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            outfile.write(' ID="%s"' % self.gds_format_integer(self.ID, input_name='ID'))
        if self.FixedRef is not None and 'FixedRef' not in already_processed:
            already_processed.add('FixedRef')
            outfile.write(' FixedRef=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.FixedRef), input_name='FixedRef')), ))
        if self.DocNameStatusID is not None and 'DocNameStatusID' not in already_processed:
            already_processed.add('DocNameStatusID')
            outfile.write(' DocNameStatusID="%s"' % self.gds_format_integer(self.DocNameStatusID, input_name='DocNameStatusID'))
        if self.DeltaAction is not None and 'DeltaAction' not in already_processed:
            already_processed.add('DeltaAction')
            outfile.write(' DeltaAction=%s' % (quote_attrib(self.DeltaAction), ))
    def exportChildren(self, outfile, level, namespace_='un:', name_='DocumentedNameSchemaType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Comment is not None:
            self.Comment.export(outfile, level, namespace_, name_='Comment', pretty_print=pretty_print)
        for DocumentedNamePart_ in self.DocumentedNamePart:
            DocumentedNamePart_.export(outfile, level, namespace_, name_='DocumentedNamePart', pretty_print=pretty_print)
        for DocumentedNameCountry_ in self.DocumentedNameCountry:
            DocumentedNameCountry_.export(outfile, level, namespace_, name_='DocumentedNameCountry', pretty_print=pretty_print)
        for IDRegDocumentReference_ in self.IDRegDocumentReference:
            IDRegDocumentReference_.export(outfile, level, namespace_, name_='IDRegDocumentReference', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            try:
                self.ID = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.ID < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = find_attr_value_('FixedRef', node)
        if value is not None and 'FixedRef' not in already_processed:
            already_processed.add('FixedRef')
            self.FixedRef = value
        value = find_attr_value_('DocNameStatusID', node)
        if value is not None and 'DocNameStatusID' not in already_processed:
            already_processed.add('DocNameStatusID')
            try:
                self.DocNameStatusID = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.DocNameStatusID < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = find_attr_value_('DeltaAction', node)
        if value is not None and 'DeltaAction' not in already_processed:
            already_processed.add('DeltaAction')
            self.DeltaAction = value
            self.validate_DeltaActionSchemaType(self.DeltaAction)    # validate type DeltaActionSchemaType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Comment':
            obj_ = Comment.factory()
            obj_.build(child_)
            self.Comment = obj_
            obj_.original_tagname_ = 'Comment'
        elif nodeName_ == 'DocumentedNamePart':
            obj_ = DocumentedNamePartType.factory()
            obj_.build(child_)
            self.DocumentedNamePart.append(obj_)
            obj_.original_tagname_ = 'DocumentedNamePart'
        elif nodeName_ == 'DocumentedNameCountry':
            obj_ = DocumentedNameCountryType.factory()
            obj_.build(child_)
            self.DocumentedNameCountry.append(obj_)
            obj_.original_tagname_ = 'DocumentedNameCountry'
        elif nodeName_ == 'IDRegDocumentReference':
            obj_ = IDRegDocumentReference.factory()
            obj_.build(child_)
            self.IDRegDocumentReference.append(obj_)
            obj_.original_tagname_ = 'IDRegDocumentReference'
# end class DocumentedNameSchemaType


class ProfileRelationshipSchemaType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ID=None, From_ProfileID=None, To_ProfileID=None, RelationTypeID=None, RelationQualityID=None, Former=None, SanctionsEntryID=None, DeltaAction=None, Comment=None, DatePeriod=None, IDRegDocumentReference=None):
        self.original_tagname_ = None
        self.ID = _cast(int, ID)
        self.From_ProfileID = _cast(int, From_ProfileID)
        self.To_ProfileID = _cast(int, To_ProfileID)
        self.RelationTypeID = _cast(int, RelationTypeID)
        self.RelationQualityID = _cast(int, RelationQualityID)
        self.Former = _cast(bool, Former)
        self.SanctionsEntryID = _cast(int, SanctionsEntryID)
        self.DeltaAction = _cast(None, DeltaAction)
        self.Comment = Comment
        self.DatePeriod = DatePeriod
        if IDRegDocumentReference is None:
            self.IDRegDocumentReference = []
        else:
            self.IDRegDocumentReference = IDRegDocumentReference
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ProfileRelationshipSchemaType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ProfileRelationshipSchemaType.subclass:
            return ProfileRelationshipSchemaType.subclass(*args_, **kwargs_)
        else:
            return ProfileRelationshipSchemaType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Comment(self): return self.Comment
    def set_Comment(self, Comment): self.Comment = Comment
    def get_DatePeriod(self): return self.DatePeriod
    def set_DatePeriod(self, DatePeriod): self.DatePeriod = DatePeriod
    def get_IDRegDocumentReference(self): return self.IDRegDocumentReference
    def set_IDRegDocumentReference(self, IDRegDocumentReference): self.IDRegDocumentReference = IDRegDocumentReference
    def add_IDRegDocumentReference(self, value): self.IDRegDocumentReference.append(value)
    def insert_IDRegDocumentReference_at(self, index, value): self.IDRegDocumentReference.insert(index, value)
    def replace_IDRegDocumentReference_at(self, index, value): self.IDRegDocumentReference[index] = value
    def get_ID(self): return self.ID
    def set_ID(self, ID): self.ID = ID
    def get_From_ProfileID(self): return self.From_ProfileID
    def set_From_ProfileID(self, From_ProfileID): self.From_ProfileID = From_ProfileID
    def get_To_ProfileID(self): return self.To_ProfileID
    def set_To_ProfileID(self, To_ProfileID): self.To_ProfileID = To_ProfileID
    def get_RelationTypeID(self): return self.RelationTypeID
    def set_RelationTypeID(self, RelationTypeID): self.RelationTypeID = RelationTypeID
    def get_RelationQualityID(self): return self.RelationQualityID
    def set_RelationQualityID(self, RelationQualityID): self.RelationQualityID = RelationQualityID
    def get_Former(self): return self.Former
    def set_Former(self, Former): self.Former = Former
    def get_SanctionsEntryID(self): return self.SanctionsEntryID
    def set_SanctionsEntryID(self, SanctionsEntryID): self.SanctionsEntryID = SanctionsEntryID
    def get_DeltaAction(self): return self.DeltaAction
    def set_DeltaAction(self, DeltaAction): self.DeltaAction = DeltaAction
    def validate_DeltaActionSchemaType(self, value):
        # Validate type DeltaActionSchemaType, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['add', 'amend', 'delete', 'revise']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on DeltaActionSchemaType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.Comment is not None or
            self.DatePeriod is not None or
            self.IDRegDocumentReference
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='un:', name_='ProfileRelationshipSchemaType', namespacedef_='xmlns:un="http://www.un.org/sanctions/1.0"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ProfileRelationshipSchemaType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ProfileRelationshipSchemaType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='un:', name_='ProfileRelationshipSchemaType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='un:', name_='ProfileRelationshipSchemaType'):
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            outfile.write(' ID="%s"' % self.gds_format_integer(self.ID, input_name='ID'))
        if self.From_ProfileID is not None and 'From_ProfileID' not in already_processed:
            already_processed.add('From_ProfileID')
            outfile.write(' From-ProfileID="%s"' % self.gds_format_integer(self.From_ProfileID, input_name='From-ProfileID'))
        if self.To_ProfileID is not None and 'To_ProfileID' not in already_processed:
            already_processed.add('To_ProfileID')
            outfile.write(' To-ProfileID="%s"' % self.gds_format_integer(self.To_ProfileID, input_name='To-ProfileID'))
        if self.RelationTypeID is not None and 'RelationTypeID' not in already_processed:
            already_processed.add('RelationTypeID')
            outfile.write(' RelationTypeID="%s"' % self.gds_format_integer(self.RelationTypeID, input_name='RelationTypeID'))
        if self.RelationQualityID is not None and 'RelationQualityID' not in already_processed:
            already_processed.add('RelationQualityID')
            outfile.write(' RelationQualityID="%s"' % self.gds_format_integer(self.RelationQualityID, input_name='RelationQualityID'))
        if self.Former is not None and 'Former' not in already_processed:
            already_processed.add('Former')
            outfile.write(' Former="%s"' % self.gds_format_boolean(self.Former, input_name='Former'))
        if self.SanctionsEntryID is not None and 'SanctionsEntryID' not in already_processed:
            already_processed.add('SanctionsEntryID')
            outfile.write(' SanctionsEntryID="%s"' % self.gds_format_integer(self.SanctionsEntryID, input_name='SanctionsEntryID'))
        if self.DeltaAction is not None and 'DeltaAction' not in already_processed:
            already_processed.add('DeltaAction')
            outfile.write(' DeltaAction=%s' % (quote_attrib(self.DeltaAction), ))
    def exportChildren(self, outfile, level, namespace_='un:', name_='ProfileRelationshipSchemaType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Comment is not None:
            self.Comment.export(outfile, level, namespace_, name_='Comment', pretty_print=pretty_print)
        if self.DatePeriod is not None:
            self.DatePeriod.export(outfile, level, namespace_, name_='DatePeriod', pretty_print=pretty_print)
        for IDRegDocumentReference_ in self.IDRegDocumentReference:
            IDRegDocumentReference_.export(outfile, level, namespace_, name_='IDRegDocumentReference', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            try:
                self.ID = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.ID < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = find_attr_value_('From-ProfileID', node)
        if value is not None and 'From-ProfileID' not in already_processed:
            already_processed.add('From-ProfileID')
            try:
                self.From_ProfileID = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.From_ProfileID < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = find_attr_value_('To-ProfileID', node)
        if value is not None and 'To-ProfileID' not in already_processed:
            already_processed.add('To-ProfileID')
            try:
                self.To_ProfileID = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.To_ProfileID < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = find_attr_value_('RelationTypeID', node)
        if value is not None and 'RelationTypeID' not in already_processed:
            already_processed.add('RelationTypeID')
            try:
                self.RelationTypeID = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.RelationTypeID < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = find_attr_value_('RelationQualityID', node)
        if value is not None and 'RelationQualityID' not in already_processed:
            already_processed.add('RelationQualityID')
            try:
                self.RelationQualityID = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.RelationQualityID < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = find_attr_value_('Former', node)
        if value is not None and 'Former' not in already_processed:
            already_processed.add('Former')
            if value in ('true', '1'):
                self.Former = True
            elif value in ('false', '0'):
                self.Former = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('SanctionsEntryID', node)
        if value is not None and 'SanctionsEntryID' not in already_processed:
            already_processed.add('SanctionsEntryID')
            try:
                self.SanctionsEntryID = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.SanctionsEntryID < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = find_attr_value_('DeltaAction', node)
        if value is not None and 'DeltaAction' not in already_processed:
            already_processed.add('DeltaAction')
            self.DeltaAction = value
            self.validate_DeltaActionSchemaType(self.DeltaAction)    # validate type DeltaActionSchemaType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Comment':
            obj_ = Comment.factory()
            obj_.build(child_)
            self.Comment = obj_
            obj_.original_tagname_ = 'Comment'
        elif nodeName_ == 'DatePeriod':
            obj_ = DatePeriod.factory()
            obj_.build(child_)
            self.DatePeriod = obj_
            obj_.original_tagname_ = 'DatePeriod'
        elif nodeName_ == 'IDRegDocumentReference':
            obj_ = IDRegDocumentReference.factory()
            obj_.build(child_)
            self.IDRegDocumentReference.append(obj_)
            obj_.original_tagname_ = 'IDRegDocumentReference'
# end class ProfileRelationshipSchemaType


class SanctionsEntrySchemaType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ID=None, ProfileID=None, ListID=None, EntryProfileRef=None, EntryDeltaFlag=None, DeltaAction=None, Comment=None, LimitationsToListing=None, EntryEvent=None, SanctionsMeasure=None, SupportingInfo=None, ProfileRelationshipReference=None):
        self.original_tagname_ = None
        self.ID = _cast(int, ID)
        self.ProfileID = _cast(int, ProfileID)
        self.ListID = _cast(int, ListID)
        self.EntryProfileRef = _cast(None, EntryProfileRef)
        self.EntryDeltaFlag = _cast(None, EntryDeltaFlag)
        self.DeltaAction = _cast(None, DeltaAction)
        self.Comment = Comment
        self.LimitationsToListing = LimitationsToListing
        if EntryEvent is None:
            self.EntryEvent = []
        else:
            self.EntryEvent = EntryEvent
        if SanctionsMeasure is None:
            self.SanctionsMeasure = []
        else:
            self.SanctionsMeasure = SanctionsMeasure
        if SupportingInfo is None:
            self.SupportingInfo = []
        else:
            self.SupportingInfo = SupportingInfo
        if ProfileRelationshipReference is None:
            self.ProfileRelationshipReference = []
        else:
            self.ProfileRelationshipReference = ProfileRelationshipReference
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SanctionsEntrySchemaType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SanctionsEntrySchemaType.subclass:
            return SanctionsEntrySchemaType.subclass(*args_, **kwargs_)
        else:
            return SanctionsEntrySchemaType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Comment(self): return self.Comment
    def set_Comment(self, Comment): self.Comment = Comment
    def get_LimitationsToListing(self): return self.LimitationsToListing
    def set_LimitationsToListing(self, LimitationsToListing): self.LimitationsToListing = LimitationsToListing
    def get_EntryEvent(self): return self.EntryEvent
    def set_EntryEvent(self, EntryEvent): self.EntryEvent = EntryEvent
    def add_EntryEvent(self, value): self.EntryEvent.append(value)
    def insert_EntryEvent_at(self, index, value): self.EntryEvent.insert(index, value)
    def replace_EntryEvent_at(self, index, value): self.EntryEvent[index] = value
    def get_SanctionsMeasure(self): return self.SanctionsMeasure
    def set_SanctionsMeasure(self, SanctionsMeasure): self.SanctionsMeasure = SanctionsMeasure
    def add_SanctionsMeasure(self, value): self.SanctionsMeasure.append(value)
    def insert_SanctionsMeasure_at(self, index, value): self.SanctionsMeasure.insert(index, value)
    def replace_SanctionsMeasure_at(self, index, value): self.SanctionsMeasure[index] = value
    def get_SupportingInfo(self): return self.SupportingInfo
    def set_SupportingInfo(self, SupportingInfo): self.SupportingInfo = SupportingInfo
    def add_SupportingInfo(self, value): self.SupportingInfo.append(value)
    def insert_SupportingInfo_at(self, index, value): self.SupportingInfo.insert(index, value)
    def replace_SupportingInfo_at(self, index, value): self.SupportingInfo[index] = value
    def get_ProfileRelationshipReference(self): return self.ProfileRelationshipReference
    def set_ProfileRelationshipReference(self, ProfileRelationshipReference): self.ProfileRelationshipReference = ProfileRelationshipReference
    def add_ProfileRelationshipReference(self, value): self.ProfileRelationshipReference.append(value)
    def insert_ProfileRelationshipReference_at(self, index, value): self.ProfileRelationshipReference.insert(index, value)
    def replace_ProfileRelationshipReference_at(self, index, value): self.ProfileRelationshipReference[index] = value
    def get_ID(self): return self.ID
    def set_ID(self, ID): self.ID = ID
    def get_ProfileID(self): return self.ProfileID
    def set_ProfileID(self, ProfileID): self.ProfileID = ProfileID
    def get_ListID(self): return self.ListID
    def set_ListID(self, ListID): self.ListID = ListID
    def get_EntryProfileRef(self): return self.EntryProfileRef
    def set_EntryProfileRef(self, EntryProfileRef): self.EntryProfileRef = EntryProfileRef
    def get_EntryDeltaFlag(self): return self.EntryDeltaFlag
    def set_EntryDeltaFlag(self, EntryDeltaFlag): self.EntryDeltaFlag = EntryDeltaFlag
    def get_DeltaAction(self): return self.DeltaAction
    def set_DeltaAction(self, DeltaAction): self.DeltaAction = DeltaAction
    def validate_EntryDeltaFlagSchemaType(self, value):
        # Validate type EntryDeltaFlagSchemaType, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['NewEntry', 'DeletedEntry', 'ModifiedEntry']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on EntryDeltaFlagSchemaType' % {"value" : value.encode("utf-8")} )
    def validate_DeltaActionSchemaType(self, value):
        # Validate type DeltaActionSchemaType, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['add', 'amend', 'delete', 'revise']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on DeltaActionSchemaType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.Comment is not None or
            self.LimitationsToListing is not None or
            self.EntryEvent or
            self.SanctionsMeasure or
            self.SupportingInfo or
            self.ProfileRelationshipReference
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='un:', name_='SanctionsEntrySchemaType', namespacedef_='xmlns:un="http://www.un.org/sanctions/1.0"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SanctionsEntrySchemaType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SanctionsEntrySchemaType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='un:', name_='SanctionsEntrySchemaType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='un:', name_='SanctionsEntrySchemaType'):
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            outfile.write(' ID="%s"' % self.gds_format_integer(self.ID, input_name='ID'))
        if self.ProfileID is not None and 'ProfileID' not in already_processed:
            already_processed.add('ProfileID')
            outfile.write(' ProfileID="%s"' % self.gds_format_integer(self.ProfileID, input_name='ProfileID'))
        if self.ListID is not None and 'ListID' not in already_processed:
            already_processed.add('ListID')
            outfile.write(' ListID="%s"' % self.gds_format_integer(self.ListID, input_name='ListID'))
        if self.EntryProfileRef is not None and 'EntryProfileRef' not in already_processed:
            already_processed.add('EntryProfileRef')
            outfile.write(' EntryProfileRef=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.EntryProfileRef), input_name='EntryProfileRef')), ))
        if self.EntryDeltaFlag is not None and 'EntryDeltaFlag' not in already_processed:
            already_processed.add('EntryDeltaFlag')
            outfile.write(' EntryDeltaFlag=%s' % (quote_attrib(self.EntryDeltaFlag), ))
        if self.DeltaAction is not None and 'DeltaAction' not in already_processed:
            already_processed.add('DeltaAction')
            outfile.write(' DeltaAction=%s' % (quote_attrib(self.DeltaAction), ))
    def exportChildren(self, outfile, level, namespace_='un:', name_='SanctionsEntrySchemaType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Comment is not None:
            self.Comment.export(outfile, level, namespace_, name_='Comment', pretty_print=pretty_print)
        if self.LimitationsToListing is not None:
            self.LimitationsToListing.export(outfile, level, namespace_, name_='LimitationsToListing', pretty_print=pretty_print)
        for EntryEvent_ in self.EntryEvent:
            EntryEvent_.export(outfile, level, namespace_, name_='EntryEvent', pretty_print=pretty_print)
        for SanctionsMeasure_ in self.SanctionsMeasure:
            SanctionsMeasure_.export(outfile, level, namespace_, name_='SanctionsMeasure', pretty_print=pretty_print)
        for SupportingInfo_ in self.SupportingInfo:
            SupportingInfo_.export(outfile, level, namespace_, name_='SupportingInfo', pretty_print=pretty_print)
        for ProfileRelationshipReference_ in self.ProfileRelationshipReference:
            ProfileRelationshipReference_.export(outfile, level, namespace_, name_='ProfileRelationshipReference', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            try:
                self.ID = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.ID < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = find_attr_value_('ProfileID', node)
        if value is not None and 'ProfileID' not in already_processed:
            already_processed.add('ProfileID')
            try:
                self.ProfileID = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.ProfileID < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = find_attr_value_('ListID', node)
        if value is not None and 'ListID' not in already_processed:
            already_processed.add('ListID')
            try:
                self.ListID = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.ListID < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = find_attr_value_('EntryProfileRef', node)
        if value is not None and 'EntryProfileRef' not in already_processed:
            already_processed.add('EntryProfileRef')
            self.EntryProfileRef = value
        value = find_attr_value_('EntryDeltaFlag', node)
        if value is not None and 'EntryDeltaFlag' not in already_processed:
            already_processed.add('EntryDeltaFlag')
            self.EntryDeltaFlag = value
            self.validate_EntryDeltaFlagSchemaType(self.EntryDeltaFlag)    # validate type EntryDeltaFlagSchemaType
        value = find_attr_value_('DeltaAction', node)
        if value is not None and 'DeltaAction' not in already_processed:
            already_processed.add('DeltaAction')
            self.DeltaAction = value
            self.validate_DeltaActionSchemaType(self.DeltaAction)    # validate type DeltaActionSchemaType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Comment':
            obj_ = Comment.factory()
            obj_.build(child_)
            self.Comment = obj_
            obj_.original_tagname_ = 'Comment'
        elif nodeName_ == 'LimitationsToListing':
            obj_ = LimitationsToListingType.factory()
            obj_.build(child_)
            self.LimitationsToListing = obj_
            obj_.original_tagname_ = 'LimitationsToListing'
        elif nodeName_ == 'EntryEvent':
            obj_ = EntryEventType4.factory()
            obj_.build(child_)
            self.EntryEvent.append(obj_)
            obj_.original_tagname_ = 'EntryEvent'
        elif nodeName_ == 'SanctionsMeasure':
            obj_ = SanctionsMeasureType.factory()
            obj_.build(child_)
            self.SanctionsMeasure.append(obj_)
            obj_.original_tagname_ = 'SanctionsMeasure'
        elif nodeName_ == 'SupportingInfo':
            obj_ = SupportingInfoType.factory()
            obj_.build(child_)
            self.SupportingInfo.append(obj_)
            obj_.original_tagname_ = 'SupportingInfo'
        elif nodeName_ == 'ProfileRelationshipReference':
            obj_ = ProfileRelationshipReference.factory()
            obj_.build(child_)
            self.ProfileRelationshipReference.append(obj_)
            obj_.original_tagname_ = 'ProfileRelationshipReference'
# end class SanctionsEntrySchemaType


class SanctionsEntryLinkSchemaType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ID=None, EntryA_SanctionsEntryID=None, EntryB_SanctionsEntryID=None, EntryLinkTypeID=None, DeltaAction=None, Comment=None, Date=None):
        self.original_tagname_ = None
        self.ID = _cast(int, ID)
        self.EntryA_SanctionsEntryID = _cast(int, EntryA_SanctionsEntryID)
        self.EntryB_SanctionsEntryID = _cast(int, EntryB_SanctionsEntryID)
        self.EntryLinkTypeID = _cast(int, EntryLinkTypeID)
        self.DeltaAction = _cast(None, DeltaAction)
        self.Comment = Comment
        self.Date = Date
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SanctionsEntryLinkSchemaType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SanctionsEntryLinkSchemaType.subclass:
            return SanctionsEntryLinkSchemaType.subclass(*args_, **kwargs_)
        else:
            return SanctionsEntryLinkSchemaType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Comment(self): return self.Comment
    def set_Comment(self, Comment): self.Comment = Comment
    def get_Date(self): return self.Date
    def set_Date(self, Date): self.Date = Date
    def get_ID(self): return self.ID
    def set_ID(self, ID): self.ID = ID
    def get_EntryA_SanctionsEntryID(self): return self.EntryA_SanctionsEntryID
    def set_EntryA_SanctionsEntryID(self, EntryA_SanctionsEntryID): self.EntryA_SanctionsEntryID = EntryA_SanctionsEntryID
    def get_EntryB_SanctionsEntryID(self): return self.EntryB_SanctionsEntryID
    def set_EntryB_SanctionsEntryID(self, EntryB_SanctionsEntryID): self.EntryB_SanctionsEntryID = EntryB_SanctionsEntryID
    def get_EntryLinkTypeID(self): return self.EntryLinkTypeID
    def set_EntryLinkTypeID(self, EntryLinkTypeID): self.EntryLinkTypeID = EntryLinkTypeID
    def get_DeltaAction(self): return self.DeltaAction
    def set_DeltaAction(self, DeltaAction): self.DeltaAction = DeltaAction
    def validate_DeltaActionSchemaType(self, value):
        # Validate type DeltaActionSchemaType, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['add', 'amend', 'delete', 'revise']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on DeltaActionSchemaType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.Comment is not None or
            self.Date is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='un:', name_='SanctionsEntryLinkSchemaType', namespacedef_='xmlns:un="http://www.un.org/sanctions/1.0"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SanctionsEntryLinkSchemaType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SanctionsEntryLinkSchemaType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='un:', name_='SanctionsEntryLinkSchemaType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='un:', name_='SanctionsEntryLinkSchemaType'):
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            outfile.write(' ID="%s"' % self.gds_format_integer(self.ID, input_name='ID'))
        if self.EntryA_SanctionsEntryID is not None and 'EntryA_SanctionsEntryID' not in already_processed:
            already_processed.add('EntryA_SanctionsEntryID')
            outfile.write(' EntryA-SanctionsEntryID="%s"' % self.gds_format_integer(self.EntryA_SanctionsEntryID, input_name='EntryA-SanctionsEntryID'))
        if self.EntryB_SanctionsEntryID is not None and 'EntryB_SanctionsEntryID' not in already_processed:
            already_processed.add('EntryB_SanctionsEntryID')
            outfile.write(' EntryB-SanctionsEntryID="%s"' % self.gds_format_integer(self.EntryB_SanctionsEntryID, input_name='EntryB-SanctionsEntryID'))
        if self.EntryLinkTypeID is not None and 'EntryLinkTypeID' not in already_processed:
            already_processed.add('EntryLinkTypeID')
            outfile.write(' EntryLinkTypeID="%s"' % self.gds_format_integer(self.EntryLinkTypeID, input_name='EntryLinkTypeID'))
        if self.DeltaAction is not None and 'DeltaAction' not in already_processed:
            already_processed.add('DeltaAction')
            outfile.write(' DeltaAction=%s' % (quote_attrib(self.DeltaAction), ))
    def exportChildren(self, outfile, level, namespace_='un:', name_='SanctionsEntryLinkSchemaType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Comment is not None:
            self.Comment.export(outfile, level, namespace_, name_='Comment', pretty_print=pretty_print)
        if self.Date is not None:
            self.Date.export(outfile, level, namespace_, name_='Date', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            try:
                self.ID = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.ID < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = find_attr_value_('EntryA-SanctionsEntryID', node)
        if value is not None and 'EntryA-SanctionsEntryID' not in already_processed:
            already_processed.add('EntryA-SanctionsEntryID')
            try:
                self.EntryA_SanctionsEntryID = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.EntryA_SanctionsEntryID < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = find_attr_value_('EntryB-SanctionsEntryID', node)
        if value is not None and 'EntryB-SanctionsEntryID' not in already_processed:
            already_processed.add('EntryB-SanctionsEntryID')
            try:
                self.EntryB_SanctionsEntryID = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.EntryB_SanctionsEntryID < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = find_attr_value_('EntryLinkTypeID', node)
        if value is not None and 'EntryLinkTypeID' not in already_processed:
            already_processed.add('EntryLinkTypeID')
            try:
                self.EntryLinkTypeID = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.EntryLinkTypeID < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = find_attr_value_('DeltaAction', node)
        if value is not None and 'DeltaAction' not in already_processed:
            already_processed.add('DeltaAction')
            self.DeltaAction = value
            self.validate_DeltaActionSchemaType(self.DeltaAction)    # validate type DeltaActionSchemaType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Comment':
            obj_ = Comment.factory()
            obj_.build(child_)
            self.Comment = obj_
            obj_.original_tagname_ = 'Comment'
        elif nodeName_ == 'Date':
            obj_ = DateSchemaType.factory()
            obj_.build(child_)
            self.Date = obj_
            obj_.original_tagname_ = 'Date'
# end class SanctionsEntryLinkSchemaType


class LocationsType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Location=None):
        self.original_tagname_ = None
        if Location is None:
            self.Location = []
        else:
            self.Location = Location
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, LocationsType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LocationsType.subclass:
            return LocationsType.subclass(*args_, **kwargs_)
        else:
            return LocationsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Location(self): return self.Location
    def set_Location(self, Location): self.Location = Location
    def add_Location(self, value): self.Location.append(value)
    def insert_Location_at(self, index, value): self.Location.insert(index, value)
    def replace_Location_at(self, index, value): self.Location[index] = value
    def hasContent_(self):
        if (
            self.Location
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='un:', name_='LocationsType', namespacedef_='xmlns:un="http://www.un.org/sanctions/1.0"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('LocationsType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LocationsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='un:', name_='LocationsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='un:', name_='LocationsType'):
        pass
    def exportChildren(self, outfile, level, namespace_='un:', name_='LocationsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Location_ in self.Location:
            Location_.export(outfile, level, namespace_, name_='Location', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Location':
            obj_ = LocationSchemaType.factory()
            obj_.build(child_)
            self.Location.append(obj_)
            obj_.original_tagname_ = 'Location'
# end class LocationsType


class IDRegDocumentsType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, IDRegDocument=None):
        self.original_tagname_ = None
        if IDRegDocument is None:
            self.IDRegDocument = []
        else:
            self.IDRegDocument = IDRegDocument
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, IDRegDocumentsType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if IDRegDocumentsType.subclass:
            return IDRegDocumentsType.subclass(*args_, **kwargs_)
        else:
            return IDRegDocumentsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_IDRegDocument(self): return self.IDRegDocument
    def set_IDRegDocument(self, IDRegDocument): self.IDRegDocument = IDRegDocument
    def add_IDRegDocument(self, value): self.IDRegDocument.append(value)
    def insert_IDRegDocument_at(self, index, value): self.IDRegDocument.insert(index, value)
    def replace_IDRegDocument_at(self, index, value): self.IDRegDocument[index] = value
    def hasContent_(self):
        if (
            self.IDRegDocument
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='un:', name_='IDRegDocumentsType', namespacedef_='xmlns:un="http://www.un.org/sanctions/1.0"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('IDRegDocumentsType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='IDRegDocumentsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='un:', name_='IDRegDocumentsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='un:', name_='IDRegDocumentsType'):
        pass
    def exportChildren(self, outfile, level, namespace_='un:', name_='IDRegDocumentsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for IDRegDocument_ in self.IDRegDocument:
            IDRegDocument_.export(outfile, level, namespace_, name_='IDRegDocument', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'IDRegDocument':
            obj_ = IDRegDocumentSchemaType.factory()
            obj_.build(child_)
            self.IDRegDocument.append(obj_)
            obj_.original_tagname_ = 'IDRegDocument'
# end class IDRegDocumentsType


class DistinctPartiesType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, DistinctParty=None):
        self.original_tagname_ = None
        if DistinctParty is None:
            self.DistinctParty = []
        else:
            self.DistinctParty = DistinctParty
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DistinctPartiesType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DistinctPartiesType.subclass:
            return DistinctPartiesType.subclass(*args_, **kwargs_)
        else:
            return DistinctPartiesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_DistinctParty(self): return self.DistinctParty
    def set_DistinctParty(self, DistinctParty): self.DistinctParty = DistinctParty
    def add_DistinctParty(self, value): self.DistinctParty.append(value)
    def insert_DistinctParty_at(self, index, value): self.DistinctParty.insert(index, value)
    def replace_DistinctParty_at(self, index, value): self.DistinctParty[index] = value
    def hasContent_(self):
        if (
            self.DistinctParty
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='un:', name_='DistinctPartiesType', namespacedef_='xmlns:un="http://www.un.org/sanctions/1.0"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DistinctPartiesType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DistinctPartiesType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='un:', name_='DistinctPartiesType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='un:', name_='DistinctPartiesType'):
        pass
    def exportChildren(self, outfile, level, namespace_='un:', name_='DistinctPartiesType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for DistinctParty_ in self.DistinctParty:
            DistinctParty_.export(outfile, level, namespace_, name_='DistinctParty', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'DistinctParty':
            obj_ = DistinctPartySchemaType.factory()
            obj_.build(child_)
            self.DistinctParty.append(obj_)
            obj_.original_tagname_ = 'DistinctParty'
# end class DistinctPartiesType


class ProfileRelationshipsType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ProfileRelationship=None):
        self.original_tagname_ = None
        if ProfileRelationship is None:
            self.ProfileRelationship = []
        else:
            self.ProfileRelationship = ProfileRelationship
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ProfileRelationshipsType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ProfileRelationshipsType.subclass:
            return ProfileRelationshipsType.subclass(*args_, **kwargs_)
        else:
            return ProfileRelationshipsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ProfileRelationship(self): return self.ProfileRelationship
    def set_ProfileRelationship(self, ProfileRelationship): self.ProfileRelationship = ProfileRelationship
    def add_ProfileRelationship(self, value): self.ProfileRelationship.append(value)
    def insert_ProfileRelationship_at(self, index, value): self.ProfileRelationship.insert(index, value)
    def replace_ProfileRelationship_at(self, index, value): self.ProfileRelationship[index] = value
    def hasContent_(self):
        if (
            self.ProfileRelationship
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='un:', name_='ProfileRelationshipsType', namespacedef_='xmlns:un="http://www.un.org/sanctions/1.0"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ProfileRelationshipsType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ProfileRelationshipsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='un:', name_='ProfileRelationshipsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='un:', name_='ProfileRelationshipsType'):
        pass
    def exportChildren(self, outfile, level, namespace_='un:', name_='ProfileRelationshipsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for ProfileRelationship_ in self.ProfileRelationship:
            ProfileRelationship_.export(outfile, level, namespace_, name_='ProfileRelationship', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ProfileRelationship':
            obj_ = ProfileRelationshipSchemaType.factory()
            obj_.build(child_)
            self.ProfileRelationship.append(obj_)
            obj_.original_tagname_ = 'ProfileRelationship'
# end class ProfileRelationshipsType


class SanctionsEntriesType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, SanctionsEntry=None):
        self.original_tagname_ = None
        if SanctionsEntry is None:
            self.SanctionsEntry = []
        else:
            self.SanctionsEntry = SanctionsEntry
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SanctionsEntriesType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SanctionsEntriesType.subclass:
            return SanctionsEntriesType.subclass(*args_, **kwargs_)
        else:
            return SanctionsEntriesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_SanctionsEntry(self): return self.SanctionsEntry
    def set_SanctionsEntry(self, SanctionsEntry): self.SanctionsEntry = SanctionsEntry
    def add_SanctionsEntry(self, value): self.SanctionsEntry.append(value)
    def insert_SanctionsEntry_at(self, index, value): self.SanctionsEntry.insert(index, value)
    def replace_SanctionsEntry_at(self, index, value): self.SanctionsEntry[index] = value
    def hasContent_(self):
        if (
            self.SanctionsEntry
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='un:', name_='SanctionsEntriesType', namespacedef_='xmlns:un="http://www.un.org/sanctions/1.0"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SanctionsEntriesType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SanctionsEntriesType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='un:', name_='SanctionsEntriesType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='un:', name_='SanctionsEntriesType'):
        pass
    def exportChildren(self, outfile, level, namespace_='un:', name_='SanctionsEntriesType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for SanctionsEntry_ in self.SanctionsEntry:
            SanctionsEntry_.export(outfile, level, namespace_, name_='SanctionsEntry', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'SanctionsEntry':
            obj_ = SanctionsEntrySchemaType.factory()
            obj_.build(child_)
            self.SanctionsEntry.append(obj_)
            obj_.original_tagname_ = 'SanctionsEntry'
# end class SanctionsEntriesType


class SanctionsEntryLinksType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, SanctionsEntryLink=None):
        self.original_tagname_ = None
        if SanctionsEntryLink is None:
            self.SanctionsEntryLink = []
        else:
            self.SanctionsEntryLink = SanctionsEntryLink
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SanctionsEntryLinksType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SanctionsEntryLinksType.subclass:
            return SanctionsEntryLinksType.subclass(*args_, **kwargs_)
        else:
            return SanctionsEntryLinksType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_SanctionsEntryLink(self): return self.SanctionsEntryLink
    def set_SanctionsEntryLink(self, SanctionsEntryLink): self.SanctionsEntryLink = SanctionsEntryLink
    def add_SanctionsEntryLink(self, value): self.SanctionsEntryLink.append(value)
    def insert_SanctionsEntryLink_at(self, index, value): self.SanctionsEntryLink.insert(index, value)
    def replace_SanctionsEntryLink_at(self, index, value): self.SanctionsEntryLink[index] = value
    def hasContent_(self):
        if (
            self.SanctionsEntryLink
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='un:', name_='SanctionsEntryLinksType', namespacedef_='xmlns:un="http://www.un.org/sanctions/1.0"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SanctionsEntryLinksType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SanctionsEntryLinksType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='un:', name_='SanctionsEntryLinksType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='un:', name_='SanctionsEntryLinksType'):
        pass
    def exportChildren(self, outfile, level, namespace_='un:', name_='SanctionsEntryLinksType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for SanctionsEntryLink_ in self.SanctionsEntryLink:
            SanctionsEntryLink_.export(outfile, level, namespace_, name_='SanctionsEntryLink', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'SanctionsEntryLink':
            obj_ = SanctionsEntryLinkSchemaType.factory()
            obj_.build(child_)
            self.SanctionsEntryLink.append(obj_)
            obj_.original_tagname_ = 'SanctionsEntryLink'
# end class SanctionsEntryLinksType


class AliasTypeValuesType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, AliasType=None):
        self.original_tagname_ = None
        if AliasType is None:
            self.AliasType = []
        else:
            self.AliasType = AliasType
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AliasTypeValuesType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AliasTypeValuesType.subclass:
            return AliasTypeValuesType.subclass(*args_, **kwargs_)
        else:
            return AliasTypeValuesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_AliasType(self): return self.AliasType
    def set_AliasType(self, AliasType): self.AliasType = AliasType
    def add_AliasType(self, value): self.AliasType.append(value)
    def insert_AliasType_at(self, index, value): self.AliasType.insert(index, value)
    def replace_AliasType_at(self, index, value): self.AliasType[index] = value
    def hasContent_(self):
        if (
            self.AliasType
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='un:', name_='AliasTypeValuesType', namespacedef_='xmlns:un="http://www.un.org/sanctions/1.0"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('AliasTypeValuesType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AliasTypeValuesType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='un:', name_='AliasTypeValuesType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='un:', name_='AliasTypeValuesType'):
        pass
    def exportChildren(self, outfile, level, namespace_='un:', name_='AliasTypeValuesType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for AliasType_ in self.AliasType:
            AliasType_.export(outfile, level, namespace_, name_='AliasType', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'AliasType':
            obj_ = AliasTypeType.factory()
            obj_.build(child_)
            self.AliasType.append(obj_)
            obj_.original_tagname_ = 'AliasType'
# end class AliasTypeValuesType


class AliasTypeType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ID=None, DeltaAction=None, valueOf_=None):
        self.original_tagname_ = None
        self.ID = _cast(int, ID)
        self.DeltaAction = _cast(None, DeltaAction)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AliasTypeType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AliasTypeType.subclass:
            return AliasTypeType.subclass(*args_, **kwargs_)
        else:
            return AliasTypeType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ID(self): return self.ID
    def set_ID(self, ID): self.ID = ID
    def get_DeltaAction(self): return self.DeltaAction
    def set_DeltaAction(self, DeltaAction): self.DeltaAction = DeltaAction
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_DeltaActionSchemaType(self, value):
        # Validate type DeltaActionSchemaType, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['add', 'amend', 'delete', 'revise']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on DeltaActionSchemaType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='un:', name_='AliasTypeType', namespacedef_='xmlns:un="http://www.un.org/sanctions/1.0"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('AliasTypeType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AliasTypeType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='un:', name_='AliasTypeType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='un:', name_='AliasTypeType'):
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            outfile.write(' ID="%s"' % self.gds_format_integer(self.ID, input_name='ID'))
        if self.DeltaAction is not None and 'DeltaAction' not in already_processed:
            already_processed.add('DeltaAction')
            outfile.write(' DeltaAction=%s' % (quote_attrib(self.DeltaAction), ))
    def exportChildren(self, outfile, level, namespace_='un:', name_='AliasTypeType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            try:
                self.ID = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.ID < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = find_attr_value_('DeltaAction', node)
        if value is not None and 'DeltaAction' not in already_processed:
            already_processed.add('DeltaAction')
            self.DeltaAction = value
            self.validate_DeltaActionSchemaType(self.DeltaAction)    # validate type DeltaActionSchemaType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class AliasTypeType


class AreaCodeValuesType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, AreaCode=None):
        self.original_tagname_ = None
        if AreaCode is None:
            self.AreaCode = []
        else:
            self.AreaCode = AreaCode
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AreaCodeValuesType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AreaCodeValuesType.subclass:
            return AreaCodeValuesType.subclass(*args_, **kwargs_)
        else:
            return AreaCodeValuesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_AreaCode(self): return self.AreaCode
    def set_AreaCode(self, AreaCode): self.AreaCode = AreaCode
    def add_AreaCode(self, value): self.AreaCode.append(value)
    def insert_AreaCode_at(self, index, value): self.AreaCode.insert(index, value)
    def replace_AreaCode_at(self, index, value): self.AreaCode[index] = value
    def hasContent_(self):
        if (
            self.AreaCode
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='un:', name_='AreaCodeValuesType', namespacedef_='xmlns:un="http://www.un.org/sanctions/1.0"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('AreaCodeValuesType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AreaCodeValuesType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='un:', name_='AreaCodeValuesType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='un:', name_='AreaCodeValuesType'):
        pass
    def exportChildren(self, outfile, level, namespace_='un:', name_='AreaCodeValuesType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for AreaCode_ in self.AreaCode:
            AreaCode_.export(outfile, level, namespace_, name_='AreaCode', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'AreaCode':
            obj_ = AreaCodeType1.factory()
            obj_.build(child_)
            self.AreaCode.append(obj_)
            obj_.original_tagname_ = 'AreaCode'
# end class AreaCodeValuesType


class AreaCodeType1(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ID=None, CountryID=None, Description=None, AreaCodeTypeID=None, DeltaAction=None, valueOf_=None):
        self.original_tagname_ = None
        self.ID = _cast(int, ID)
        self.CountryID = _cast(int, CountryID)
        self.Description = _cast(None, Description)
        self.AreaCodeTypeID = _cast(int, AreaCodeTypeID)
        self.DeltaAction = _cast(None, DeltaAction)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AreaCodeType1)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AreaCodeType1.subclass:
            return AreaCodeType1.subclass(*args_, **kwargs_)
        else:
            return AreaCodeType1(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ID(self): return self.ID
    def set_ID(self, ID): self.ID = ID
    def get_CountryID(self): return self.CountryID
    def set_CountryID(self, CountryID): self.CountryID = CountryID
    def get_Description(self): return self.Description
    def set_Description(self, Description): self.Description = Description
    def get_AreaCodeTypeID(self): return self.AreaCodeTypeID
    def set_AreaCodeTypeID(self, AreaCodeTypeID): self.AreaCodeTypeID = AreaCodeTypeID
    def get_DeltaAction(self): return self.DeltaAction
    def set_DeltaAction(self, DeltaAction): self.DeltaAction = DeltaAction
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_DeltaActionSchemaType(self, value):
        # Validate type DeltaActionSchemaType, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['add', 'amend', 'delete', 'revise']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on DeltaActionSchemaType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='un:', name_='AreaCodeType1', namespacedef_='xmlns:un="http://www.un.org/sanctions/1.0"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('AreaCodeType1')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AreaCodeType1')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='un:', name_='AreaCodeType1', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='un:', name_='AreaCodeType1'):
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            outfile.write(' ID="%s"' % self.gds_format_integer(self.ID, input_name='ID'))
        if self.CountryID is not None and 'CountryID' not in already_processed:
            already_processed.add('CountryID')
            outfile.write(' CountryID="%s"' % self.gds_format_integer(self.CountryID, input_name='CountryID'))
        if self.Description is not None and 'Description' not in already_processed:
            already_processed.add('Description')
            outfile.write(' Description=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Description), input_name='Description')), ))
        if self.AreaCodeTypeID is not None and 'AreaCodeTypeID' not in already_processed:
            already_processed.add('AreaCodeTypeID')
            outfile.write(' AreaCodeTypeID="%s"' % self.gds_format_integer(self.AreaCodeTypeID, input_name='AreaCodeTypeID'))
        if self.DeltaAction is not None and 'DeltaAction' not in already_processed:
            already_processed.add('DeltaAction')
            outfile.write(' DeltaAction=%s' % (quote_attrib(self.DeltaAction), ))
    def exportChildren(self, outfile, level, namespace_='un:', name_='AreaCodeType1', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            try:
                self.ID = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.ID < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = find_attr_value_('CountryID', node)
        if value is not None and 'CountryID' not in already_processed:
            already_processed.add('CountryID')
            try:
                self.CountryID = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.CountryID < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = find_attr_value_('Description', node)
        if value is not None and 'Description' not in already_processed:
            already_processed.add('Description')
            self.Description = value
        value = find_attr_value_('AreaCodeTypeID', node)
        if value is not None and 'AreaCodeTypeID' not in already_processed:
            already_processed.add('AreaCodeTypeID')
            try:
                self.AreaCodeTypeID = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.AreaCodeTypeID < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = find_attr_value_('DeltaAction', node)
        if value is not None and 'DeltaAction' not in already_processed:
            already_processed.add('DeltaAction')
            self.DeltaAction = value
            self.validate_DeltaActionSchemaType(self.DeltaAction)    # validate type DeltaActionSchemaType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class AreaCodeType1


class AreaCodeTypeValuesType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, AreaCodeType=None):
        self.original_tagname_ = None
        if AreaCodeType is None:
            self.AreaCodeType = []
        else:
            self.AreaCodeType = AreaCodeType
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AreaCodeTypeValuesType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AreaCodeTypeValuesType.subclass:
            return AreaCodeTypeValuesType.subclass(*args_, **kwargs_)
        else:
            return AreaCodeTypeValuesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_AreaCodeType(self): return self.AreaCodeType
    def set_AreaCodeType(self, AreaCodeType): self.AreaCodeType = AreaCodeType
    def add_AreaCodeType(self, value): self.AreaCodeType.append(value)
    def insert_AreaCodeType_at(self, index, value): self.AreaCodeType.insert(index, value)
    def replace_AreaCodeType_at(self, index, value): self.AreaCodeType[index] = value
    def hasContent_(self):
        if (
            self.AreaCodeType
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='un:', name_='AreaCodeTypeValuesType', namespacedef_='xmlns:un="http://www.un.org/sanctions/1.0"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('AreaCodeTypeValuesType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AreaCodeTypeValuesType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='un:', name_='AreaCodeTypeValuesType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='un:', name_='AreaCodeTypeValuesType'):
        pass
    def exportChildren(self, outfile, level, namespace_='un:', name_='AreaCodeTypeValuesType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for AreaCodeType_ in self.AreaCodeType:
            AreaCodeType_.export(outfile, level, namespace_, name_='AreaCodeType', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'AreaCodeType':
            obj_ = AreaCodeTypeType.factory()
            obj_.build(child_)
            self.AreaCodeType.append(obj_)
            obj_.original_tagname_ = 'AreaCodeType'
# end class AreaCodeTypeValuesType


class AreaCodeTypeType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ID=None, DeltaAction=None, valueOf_=None):
        self.original_tagname_ = None
        self.ID = _cast(int, ID)
        self.DeltaAction = _cast(None, DeltaAction)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AreaCodeTypeType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AreaCodeTypeType.subclass:
            return AreaCodeTypeType.subclass(*args_, **kwargs_)
        else:
            return AreaCodeTypeType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ID(self): return self.ID
    def set_ID(self, ID): self.ID = ID
    def get_DeltaAction(self): return self.DeltaAction
    def set_DeltaAction(self, DeltaAction): self.DeltaAction = DeltaAction
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_DeltaActionSchemaType(self, value):
        # Validate type DeltaActionSchemaType, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['add', 'amend', 'delete', 'revise']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on DeltaActionSchemaType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='un:', name_='AreaCodeTypeType', namespacedef_='xmlns:un="http://www.un.org/sanctions/1.0"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('AreaCodeTypeType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AreaCodeTypeType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='un:', name_='AreaCodeTypeType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='un:', name_='AreaCodeTypeType'):
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            outfile.write(' ID="%s"' % self.gds_format_integer(self.ID, input_name='ID'))
        if self.DeltaAction is not None and 'DeltaAction' not in already_processed:
            already_processed.add('DeltaAction')
            outfile.write(' DeltaAction=%s' % (quote_attrib(self.DeltaAction), ))
    def exportChildren(self, outfile, level, namespace_='un:', name_='AreaCodeTypeType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            try:
                self.ID = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.ID < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = find_attr_value_('DeltaAction', node)
        if value is not None and 'DeltaAction' not in already_processed:
            already_processed.add('DeltaAction')
            self.DeltaAction = value
            self.validate_DeltaActionSchemaType(self.DeltaAction)    # validate type DeltaActionSchemaType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class AreaCodeTypeType


class CalendarTypeValuesType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, CalendarType=None):
        self.original_tagname_ = None
        if CalendarType is None:
            self.CalendarType = []
        else:
            self.CalendarType = CalendarType
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CalendarTypeValuesType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CalendarTypeValuesType.subclass:
            return CalendarTypeValuesType.subclass(*args_, **kwargs_)
        else:
            return CalendarTypeValuesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_CalendarType(self): return self.CalendarType
    def set_CalendarType(self, CalendarType): self.CalendarType = CalendarType
    def add_CalendarType(self, value): self.CalendarType.append(value)
    def insert_CalendarType_at(self, index, value): self.CalendarType.insert(index, value)
    def replace_CalendarType_at(self, index, value): self.CalendarType[index] = value
    def hasContent_(self):
        if (
            self.CalendarType
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='un:', name_='CalendarTypeValuesType', namespacedef_='xmlns:un="http://www.un.org/sanctions/1.0"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CalendarTypeValuesType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CalendarTypeValuesType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='un:', name_='CalendarTypeValuesType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='un:', name_='CalendarTypeValuesType'):
        pass
    def exportChildren(self, outfile, level, namespace_='un:', name_='CalendarTypeValuesType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for CalendarType_ in self.CalendarType:
            CalendarType_.export(outfile, level, namespace_, name_='CalendarType', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'CalendarType':
            obj_ = CalendarTypeType.factory()
            obj_.build(child_)
            self.CalendarType.append(obj_)
            obj_.original_tagname_ = 'CalendarType'
# end class CalendarTypeValuesType


class CalendarTypeType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ID=None, DeltaAction=None, valueOf_=None):
        self.original_tagname_ = None
        self.ID = _cast(int, ID)
        self.DeltaAction = _cast(None, DeltaAction)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CalendarTypeType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CalendarTypeType.subclass:
            return CalendarTypeType.subclass(*args_, **kwargs_)
        else:
            return CalendarTypeType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ID(self): return self.ID
    def set_ID(self, ID): self.ID = ID
    def get_DeltaAction(self): return self.DeltaAction
    def set_DeltaAction(self, DeltaAction): self.DeltaAction = DeltaAction
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_DeltaActionSchemaType(self, value):
        # Validate type DeltaActionSchemaType, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['add', 'amend', 'delete', 'revise']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on DeltaActionSchemaType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='un:', name_='CalendarTypeType', namespacedef_='xmlns:un="http://www.un.org/sanctions/1.0"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CalendarTypeType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CalendarTypeType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='un:', name_='CalendarTypeType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='un:', name_='CalendarTypeType'):
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            outfile.write(' ID="%s"' % self.gds_format_integer(self.ID, input_name='ID'))
        if self.DeltaAction is not None and 'DeltaAction' not in already_processed:
            already_processed.add('DeltaAction')
            outfile.write(' DeltaAction=%s' % (quote_attrib(self.DeltaAction), ))
    def exportChildren(self, outfile, level, namespace_='un:', name_='CalendarTypeType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            try:
                self.ID = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.ID < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = find_attr_value_('DeltaAction', node)
        if value is not None and 'DeltaAction' not in already_processed:
            already_processed.add('DeltaAction')
            self.DeltaAction = value
            self.validate_DeltaActionSchemaType(self.DeltaAction)    # validate type DeltaActionSchemaType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class CalendarTypeType


class CountryValuesType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Country=None):
        self.original_tagname_ = None
        if Country is None:
            self.Country = []
        else:
            self.Country = Country
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CountryValuesType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CountryValuesType.subclass:
            return CountryValuesType.subclass(*args_, **kwargs_)
        else:
            return CountryValuesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Country(self): return self.Country
    def set_Country(self, Country): self.Country = Country
    def add_Country(self, value): self.Country.append(value)
    def insert_Country_at(self, index, value): self.Country.insert(index, value)
    def replace_Country_at(self, index, value): self.Country[index] = value
    def hasContent_(self):
        if (
            self.Country
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='un:', name_='CountryValuesType', namespacedef_='xmlns:un="http://www.un.org/sanctions/1.0"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CountryValuesType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CountryValuesType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='un:', name_='CountryValuesType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='un:', name_='CountryValuesType'):
        pass
    def exportChildren(self, outfile, level, namespace_='un:', name_='CountryValuesType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Country_ in self.Country:
            Country_.export(outfile, level, namespace_, name_='Country', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Country':
            obj_ = CountryType.factory()
            obj_.build(child_)
            self.Country.append(obj_)
            obj_.original_tagname_ = 'Country'
# end class CountryValuesType


class CountryType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ID=None, Comment=None, IS03166_3Code=None, ISO3=None, ISO2=None, DeltaAction=None, valueOf_=None):
        self.original_tagname_ = None
        self.ID = _cast(int, ID)
        self.Comment = _cast(None, Comment)
        self.IS03166_3Code = _cast(None, IS03166_3Code)
        self.ISO3 = _cast(None, ISO3)
        self.ISO2 = _cast(None, ISO2)
        self.DeltaAction = _cast(None, DeltaAction)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CountryType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CountryType.subclass:
            return CountryType.subclass(*args_, **kwargs_)
        else:
            return CountryType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ID(self): return self.ID
    def set_ID(self, ID): self.ID = ID
    def get_Comment(self): return self.Comment
    def set_Comment(self, Comment): self.Comment = Comment
    def get_IS03166_3Code(self): return self.IS03166_3Code
    def set_IS03166_3Code(self, IS03166_3Code): self.IS03166_3Code = IS03166_3Code
    def get_ISO3(self): return self.ISO3
    def set_ISO3(self, ISO3): self.ISO3 = ISO3
    def get_ISO2(self): return self.ISO2
    def set_ISO2(self, ISO2): self.ISO2 = ISO2
    def get_DeltaAction(self): return self.DeltaAction
    def set_DeltaAction(self, DeltaAction): self.DeltaAction = DeltaAction
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_DeltaActionSchemaType(self, value):
        # Validate type DeltaActionSchemaType, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['add', 'amend', 'delete', 'revise']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on DeltaActionSchemaType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='un:', name_='CountryType', namespacedef_='xmlns:un="http://www.un.org/sanctions/1.0"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CountryType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CountryType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='un:', name_='CountryType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='un:', name_='CountryType'):
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            outfile.write(' ID="%s"' % self.gds_format_integer(self.ID, input_name='ID'))
        if self.Comment is not None and 'Comment' not in already_processed:
            already_processed.add('Comment')
            outfile.write(' Comment=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Comment), input_name='Comment')), ))
        if self.IS03166_3Code is not None and 'IS03166_3Code' not in already_processed:
            already_processed.add('IS03166_3Code')
            outfile.write(' IS03166-3Code=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.IS03166_3Code), input_name='IS03166-3Code')), ))
        if self.ISO3 is not None and 'ISO3' not in already_processed:
            already_processed.add('ISO3')
            outfile.write(' ISO3=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.ISO3), input_name='ISO3')), ))
        if self.ISO2 is not None and 'ISO2' not in already_processed:
            already_processed.add('ISO2')
            outfile.write(' ISO2=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.ISO2), input_name='ISO2')), ))
        if self.DeltaAction is not None and 'DeltaAction' not in already_processed:
            already_processed.add('DeltaAction')
            outfile.write(' DeltaAction=%s' % (quote_attrib(self.DeltaAction), ))
    def exportChildren(self, outfile, level, namespace_='un:', name_='CountryType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            try:
                self.ID = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.ID < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = find_attr_value_('Comment', node)
        if value is not None and 'Comment' not in already_processed:
            already_processed.add('Comment')
            self.Comment = value
        value = find_attr_value_('IS03166-3Code', node)
        if value is not None and 'IS03166-3Code' not in already_processed:
            already_processed.add('IS03166-3Code')
            self.IS03166_3Code = value
        value = find_attr_value_('ISO3', node)
        if value is not None and 'ISO3' not in already_processed:
            already_processed.add('ISO3')
            self.ISO3 = value
        value = find_attr_value_('ISO2', node)
        if value is not None and 'ISO2' not in already_processed:
            already_processed.add('ISO2')
            self.ISO2 = value
        value = find_attr_value_('DeltaAction', node)
        if value is not None and 'DeltaAction' not in already_processed:
            already_processed.add('DeltaAction')
            self.DeltaAction = value
            self.validate_DeltaActionSchemaType(self.DeltaAction)    # validate type DeltaActionSchemaType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class CountryType


class CountryRelevanceValuesType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, CountryRelevance=None):
        self.original_tagname_ = None
        if CountryRelevance is None:
            self.CountryRelevance = []
        else:
            self.CountryRelevance = CountryRelevance
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CountryRelevanceValuesType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CountryRelevanceValuesType.subclass:
            return CountryRelevanceValuesType.subclass(*args_, **kwargs_)
        else:
            return CountryRelevanceValuesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_CountryRelevance(self): return self.CountryRelevance
    def set_CountryRelevance(self, CountryRelevance): self.CountryRelevance = CountryRelevance
    def add_CountryRelevance(self, value): self.CountryRelevance.append(value)
    def insert_CountryRelevance_at(self, index, value): self.CountryRelevance.insert(index, value)
    def replace_CountryRelevance_at(self, index, value): self.CountryRelevance[index] = value
    def hasContent_(self):
        if (
            self.CountryRelevance
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='un:', name_='CountryRelevanceValuesType', namespacedef_='xmlns:un="http://www.un.org/sanctions/1.0"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CountryRelevanceValuesType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CountryRelevanceValuesType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='un:', name_='CountryRelevanceValuesType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='un:', name_='CountryRelevanceValuesType'):
        pass
    def exportChildren(self, outfile, level, namespace_='un:', name_='CountryRelevanceValuesType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for CountryRelevance_ in self.CountryRelevance:
            CountryRelevance_.export(outfile, level, namespace_, name_='CountryRelevance', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'CountryRelevance':
            obj_ = CountryRelevanceType.factory()
            obj_.build(child_)
            self.CountryRelevance.append(obj_)
            obj_.original_tagname_ = 'CountryRelevance'
# end class CountryRelevanceValuesType


class CountryRelevanceType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ID=None, DeltaAction=None, valueOf_=None):
        self.original_tagname_ = None
        self.ID = _cast(int, ID)
        self.DeltaAction = _cast(None, DeltaAction)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CountryRelevanceType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CountryRelevanceType.subclass:
            return CountryRelevanceType.subclass(*args_, **kwargs_)
        else:
            return CountryRelevanceType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ID(self): return self.ID
    def set_ID(self, ID): self.ID = ID
    def get_DeltaAction(self): return self.DeltaAction
    def set_DeltaAction(self, DeltaAction): self.DeltaAction = DeltaAction
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_DeltaActionSchemaType(self, value):
        # Validate type DeltaActionSchemaType, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['add', 'amend', 'delete', 'revise']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on DeltaActionSchemaType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='un:', name_='CountryRelevanceType', namespacedef_='xmlns:un="http://www.un.org/sanctions/1.0"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CountryRelevanceType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CountryRelevanceType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='un:', name_='CountryRelevanceType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='un:', name_='CountryRelevanceType'):
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            outfile.write(' ID="%s"' % self.gds_format_integer(self.ID, input_name='ID'))
        if self.DeltaAction is not None and 'DeltaAction' not in already_processed:
            already_processed.add('DeltaAction')
            outfile.write(' DeltaAction=%s' % (quote_attrib(self.DeltaAction), ))
    def exportChildren(self, outfile, level, namespace_='un:', name_='CountryRelevanceType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            try:
                self.ID = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.ID < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = find_attr_value_('DeltaAction', node)
        if value is not None and 'DeltaAction' not in already_processed:
            already_processed.add('DeltaAction')
            self.DeltaAction = value
            self.validate_DeltaActionSchemaType(self.DeltaAction)    # validate type DeltaActionSchemaType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class CountryRelevanceType


class DecisionMakingBodyValuesType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, DecisionMakingBody=None):
        self.original_tagname_ = None
        if DecisionMakingBody is None:
            self.DecisionMakingBody = []
        else:
            self.DecisionMakingBody = DecisionMakingBody
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DecisionMakingBodyValuesType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DecisionMakingBodyValuesType.subclass:
            return DecisionMakingBodyValuesType.subclass(*args_, **kwargs_)
        else:
            return DecisionMakingBodyValuesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_DecisionMakingBody(self): return self.DecisionMakingBody
    def set_DecisionMakingBody(self, DecisionMakingBody): self.DecisionMakingBody = DecisionMakingBody
    def add_DecisionMakingBody(self, value): self.DecisionMakingBody.append(value)
    def insert_DecisionMakingBody_at(self, index, value): self.DecisionMakingBody.insert(index, value)
    def replace_DecisionMakingBody_at(self, index, value): self.DecisionMakingBody[index] = value
    def hasContent_(self):
        if (
            self.DecisionMakingBody
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='un:', name_='DecisionMakingBodyValuesType', namespacedef_='xmlns:un="http://www.un.org/sanctions/1.0"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DecisionMakingBodyValuesType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DecisionMakingBodyValuesType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='un:', name_='DecisionMakingBodyValuesType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='un:', name_='DecisionMakingBodyValuesType'):
        pass
    def exportChildren(self, outfile, level, namespace_='un:', name_='DecisionMakingBodyValuesType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for DecisionMakingBody_ in self.DecisionMakingBody:
            DecisionMakingBody_.export(outfile, level, namespace_, name_='DecisionMakingBody', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'DecisionMakingBody':
            obj_ = DecisionMakingBodyType.factory()
            obj_.build(child_)
            self.DecisionMakingBody.append(obj_)
            obj_.original_tagname_ = 'DecisionMakingBody'
# end class DecisionMakingBodyValuesType


class DecisionMakingBodyType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ID=None, OrganisationID=None, DeltaAction=None, valueOf_=None):
        self.original_tagname_ = None
        self.ID = _cast(int, ID)
        self.OrganisationID = _cast(int, OrganisationID)
        self.DeltaAction = _cast(None, DeltaAction)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DecisionMakingBodyType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DecisionMakingBodyType.subclass:
            return DecisionMakingBodyType.subclass(*args_, **kwargs_)
        else:
            return DecisionMakingBodyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ID(self): return self.ID
    def set_ID(self, ID): self.ID = ID
    def get_OrganisationID(self): return self.OrganisationID
    def set_OrganisationID(self, OrganisationID): self.OrganisationID = OrganisationID
    def get_DeltaAction(self): return self.DeltaAction
    def set_DeltaAction(self, DeltaAction): self.DeltaAction = DeltaAction
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_DeltaActionSchemaType(self, value):
        # Validate type DeltaActionSchemaType, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['add', 'amend', 'delete', 'revise']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on DeltaActionSchemaType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='un:', name_='DecisionMakingBodyType', namespacedef_='xmlns:un="http://www.un.org/sanctions/1.0"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DecisionMakingBodyType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DecisionMakingBodyType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='un:', name_='DecisionMakingBodyType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='un:', name_='DecisionMakingBodyType'):
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            outfile.write(' ID="%s"' % self.gds_format_integer(self.ID, input_name='ID'))
        if self.OrganisationID is not None and 'OrganisationID' not in already_processed:
            already_processed.add('OrganisationID')
            outfile.write(' OrganisationID="%s"' % self.gds_format_integer(self.OrganisationID, input_name='OrganisationID'))
        if self.DeltaAction is not None and 'DeltaAction' not in already_processed:
            already_processed.add('DeltaAction')
            outfile.write(' DeltaAction=%s' % (quote_attrib(self.DeltaAction), ))
    def exportChildren(self, outfile, level, namespace_='un:', name_='DecisionMakingBodyType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            try:
                self.ID = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.ID < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = find_attr_value_('OrganisationID', node)
        if value is not None and 'OrganisationID' not in already_processed:
            already_processed.add('OrganisationID')
            try:
                self.OrganisationID = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.OrganisationID < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = find_attr_value_('DeltaAction', node)
        if value is not None and 'DeltaAction' not in already_processed:
            already_processed.add('DeltaAction')
            self.DeltaAction = value
            self.validate_DeltaActionSchemaType(self.DeltaAction)    # validate type DeltaActionSchemaType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class DecisionMakingBodyType


class DetailReferenceValuesType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, DetailReference=None):
        self.original_tagname_ = None
        if DetailReference is None:
            self.DetailReference = []
        else:
            self.DetailReference = DetailReference
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DetailReferenceValuesType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DetailReferenceValuesType.subclass:
            return DetailReferenceValuesType.subclass(*args_, **kwargs_)
        else:
            return DetailReferenceValuesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_DetailReference(self): return self.DetailReference
    def set_DetailReference(self, DetailReference): self.DetailReference = DetailReference
    def add_DetailReference(self, value): self.DetailReference.append(value)
    def insert_DetailReference_at(self, index, value): self.DetailReference.insert(index, value)
    def replace_DetailReference_at(self, index, value): self.DetailReference[index] = value
    def hasContent_(self):
        if (
            self.DetailReference
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='un:', name_='DetailReferenceValuesType', namespacedef_='xmlns:un="http://www.un.org/sanctions/1.0"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DetailReferenceValuesType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DetailReferenceValuesType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='un:', name_='DetailReferenceValuesType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='un:', name_='DetailReferenceValuesType'):
        pass
    def exportChildren(self, outfile, level, namespace_='un:', name_='DetailReferenceValuesType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for DetailReference_ in self.DetailReference:
            DetailReference_.export(outfile, level, namespace_, name_='DetailReference', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'DetailReference':
            obj_ = DetailReferenceType.factory()
            obj_.build(child_)
            self.DetailReference.append(obj_)
            obj_.original_tagname_ = 'DetailReference'
# end class DetailReferenceValuesType


class DetailReferenceType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ID=None, DetailCode=None, DeltaAction=None, valueOf_=None):
        self.original_tagname_ = None
        self.ID = _cast(int, ID)
        self.DetailCode = _cast(None, DetailCode)
        self.DeltaAction = _cast(None, DeltaAction)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DetailReferenceType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DetailReferenceType.subclass:
            return DetailReferenceType.subclass(*args_, **kwargs_)
        else:
            return DetailReferenceType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ID(self): return self.ID
    def set_ID(self, ID): self.ID = ID
    def get_DetailCode(self): return self.DetailCode
    def set_DetailCode(self, DetailCode): self.DetailCode = DetailCode
    def get_DeltaAction(self): return self.DeltaAction
    def set_DeltaAction(self, DeltaAction): self.DeltaAction = DeltaAction
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_DeltaActionSchemaType(self, value):
        # Validate type DeltaActionSchemaType, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['add', 'amend', 'delete', 'revise']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on DeltaActionSchemaType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='un:', name_='DetailReferenceType', namespacedef_='xmlns:un="http://www.un.org/sanctions/1.0"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DetailReferenceType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DetailReferenceType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='un:', name_='DetailReferenceType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='un:', name_='DetailReferenceType'):
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            outfile.write(' ID="%s"' % self.gds_format_integer(self.ID, input_name='ID'))
        if self.DetailCode is not None and 'DetailCode' not in already_processed:
            already_processed.add('DetailCode')
            outfile.write(' DetailCode=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.DetailCode), input_name='DetailCode')), ))
        if self.DeltaAction is not None and 'DeltaAction' not in already_processed:
            already_processed.add('DeltaAction')
            outfile.write(' DeltaAction=%s' % (quote_attrib(self.DeltaAction), ))
    def exportChildren(self, outfile, level, namespace_='un:', name_='DetailReferenceType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            try:
                self.ID = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.ID < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = find_attr_value_('DetailCode', node)
        if value is not None and 'DetailCode' not in already_processed:
            already_processed.add('DetailCode')
            self.DetailCode = value
        value = find_attr_value_('DeltaAction', node)
        if value is not None and 'DeltaAction' not in already_processed:
            already_processed.add('DeltaAction')
            self.DeltaAction = value
            self.validate_DeltaActionSchemaType(self.DeltaAction)    # validate type DeltaActionSchemaType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class DetailReferenceType


class DetailTypeValuesType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, DetailType=None):
        self.original_tagname_ = None
        if DetailType is None:
            self.DetailType = []
        else:
            self.DetailType = DetailType
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DetailTypeValuesType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DetailTypeValuesType.subclass:
            return DetailTypeValuesType.subclass(*args_, **kwargs_)
        else:
            return DetailTypeValuesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_DetailType(self): return self.DetailType
    def set_DetailType(self, DetailType): self.DetailType = DetailType
    def add_DetailType(self, value): self.DetailType.append(value)
    def insert_DetailType_at(self, index, value): self.DetailType.insert(index, value)
    def replace_DetailType_at(self, index, value): self.DetailType[index] = value
    def hasContent_(self):
        if (
            self.DetailType
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='un:', name_='DetailTypeValuesType', namespacedef_='xmlns:un="http://www.un.org/sanctions/1.0"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DetailTypeValuesType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DetailTypeValuesType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='un:', name_='DetailTypeValuesType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='un:', name_='DetailTypeValuesType'):
        pass
    def exportChildren(self, outfile, level, namespace_='un:', name_='DetailTypeValuesType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for DetailType_ in self.DetailType:
            DetailType_.export(outfile, level, namespace_, name_='DetailType', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'DetailType':
            obj_ = DetailTypeType.factory()
            obj_.build(child_)
            self.DetailType.append(obj_)
            obj_.original_tagname_ = 'DetailType'
# end class DetailTypeValuesType


class DetailTypeType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ID=None, DeltaAction=None, valueOf_=None):
        self.original_tagname_ = None
        self.ID = _cast(int, ID)
        self.DeltaAction = _cast(None, DeltaAction)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DetailTypeType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DetailTypeType.subclass:
            return DetailTypeType.subclass(*args_, **kwargs_)
        else:
            return DetailTypeType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ID(self): return self.ID
    def set_ID(self, ID): self.ID = ID
    def get_DeltaAction(self): return self.DeltaAction
    def set_DeltaAction(self, DeltaAction): self.DeltaAction = DeltaAction
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_DeltaActionSchemaType(self, value):
        # Validate type DeltaActionSchemaType, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['add', 'amend', 'delete', 'revise']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on DeltaActionSchemaType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='un:', name_='DetailTypeType', namespacedef_='xmlns:un="http://www.un.org/sanctions/1.0"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DetailTypeType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DetailTypeType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='un:', name_='DetailTypeType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='un:', name_='DetailTypeType'):
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            outfile.write(' ID="%s"' % self.gds_format_integer(self.ID, input_name='ID'))
        if self.DeltaAction is not None and 'DeltaAction' not in already_processed:
            already_processed.add('DeltaAction')
            outfile.write(' DeltaAction=%s' % (quote_attrib(self.DeltaAction), ))
    def exportChildren(self, outfile, level, namespace_='un:', name_='DetailTypeType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            try:
                self.ID = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.ID < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = find_attr_value_('DeltaAction', node)
        if value is not None and 'DeltaAction' not in already_processed:
            already_processed.add('DeltaAction')
            self.DeltaAction = value
            self.validate_DeltaActionSchemaType(self.DeltaAction)    # validate type DeltaActionSchemaType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class DetailTypeType


class DocNameStatusValuesType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, DocNameStatus=None):
        self.original_tagname_ = None
        if DocNameStatus is None:
            self.DocNameStatus = []
        else:
            self.DocNameStatus = DocNameStatus
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DocNameStatusValuesType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DocNameStatusValuesType.subclass:
            return DocNameStatusValuesType.subclass(*args_, **kwargs_)
        else:
            return DocNameStatusValuesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_DocNameStatus(self): return self.DocNameStatus
    def set_DocNameStatus(self, DocNameStatus): self.DocNameStatus = DocNameStatus
    def add_DocNameStatus(self, value): self.DocNameStatus.append(value)
    def insert_DocNameStatus_at(self, index, value): self.DocNameStatus.insert(index, value)
    def replace_DocNameStatus_at(self, index, value): self.DocNameStatus[index] = value
    def hasContent_(self):
        if (
            self.DocNameStatus
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='un:', name_='DocNameStatusValuesType', namespacedef_='xmlns:un="http://www.un.org/sanctions/1.0"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DocNameStatusValuesType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DocNameStatusValuesType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='un:', name_='DocNameStatusValuesType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='un:', name_='DocNameStatusValuesType'):
        pass
    def exportChildren(self, outfile, level, namespace_='un:', name_='DocNameStatusValuesType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for DocNameStatus_ in self.DocNameStatus:
            DocNameStatus_.export(outfile, level, namespace_, name_='DocNameStatus', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'DocNameStatus':
            obj_ = DocNameStatusType.factory()
            obj_.build(child_)
            self.DocNameStatus.append(obj_)
            obj_.original_tagname_ = 'DocNameStatus'
# end class DocNameStatusValuesType


class DocNameStatusType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ID=None, DeltaAction=None, valueOf_=None):
        self.original_tagname_ = None
        self.ID = _cast(int, ID)
        self.DeltaAction = _cast(None, DeltaAction)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DocNameStatusType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DocNameStatusType.subclass:
            return DocNameStatusType.subclass(*args_, **kwargs_)
        else:
            return DocNameStatusType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ID(self): return self.ID
    def set_ID(self, ID): self.ID = ID
    def get_DeltaAction(self): return self.DeltaAction
    def set_DeltaAction(self, DeltaAction): self.DeltaAction = DeltaAction
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_DeltaActionSchemaType(self, value):
        # Validate type DeltaActionSchemaType, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['add', 'amend', 'delete', 'revise']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on DeltaActionSchemaType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='un:', name_='DocNameStatusType', namespacedef_='xmlns:un="http://www.un.org/sanctions/1.0"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DocNameStatusType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DocNameStatusType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='un:', name_='DocNameStatusType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='un:', name_='DocNameStatusType'):
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            outfile.write(' ID="%s"' % self.gds_format_integer(self.ID, input_name='ID'))
        if self.DeltaAction is not None and 'DeltaAction' not in already_processed:
            already_processed.add('DeltaAction')
            outfile.write(' DeltaAction=%s' % (quote_attrib(self.DeltaAction), ))
    def exportChildren(self, outfile, level, namespace_='un:', name_='DocNameStatusType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            try:
                self.ID = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.ID < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = find_attr_value_('DeltaAction', node)
        if value is not None and 'DeltaAction' not in already_processed:
            already_processed.add('DeltaAction')
            self.DeltaAction = value
            self.validate_DeltaActionSchemaType(self.DeltaAction)    # validate type DeltaActionSchemaType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class DocNameStatusType


class EntryEventTypeValuesType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, EntryEventType=None):
        self.original_tagname_ = None
        if EntryEventType is None:
            self.EntryEventType = []
        else:
            self.EntryEventType = EntryEventType
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, EntryEventTypeValuesType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if EntryEventTypeValuesType.subclass:
            return EntryEventTypeValuesType.subclass(*args_, **kwargs_)
        else:
            return EntryEventTypeValuesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_EntryEventType(self): return self.EntryEventType
    def set_EntryEventType(self, EntryEventType): self.EntryEventType = EntryEventType
    def add_EntryEventType(self, value): self.EntryEventType.append(value)
    def insert_EntryEventType_at(self, index, value): self.EntryEventType.insert(index, value)
    def replace_EntryEventType_at(self, index, value): self.EntryEventType[index] = value
    def hasContent_(self):
        if (
            self.EntryEventType
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='un:', name_='EntryEventTypeValuesType', namespacedef_='xmlns:un="http://www.un.org/sanctions/1.0"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('EntryEventTypeValuesType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='EntryEventTypeValuesType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='un:', name_='EntryEventTypeValuesType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='un:', name_='EntryEventTypeValuesType'):
        pass
    def exportChildren(self, outfile, level, namespace_='un:', name_='EntryEventTypeValuesType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for EntryEventType_ in self.EntryEventType:
            EntryEventType_.export(outfile, level, namespace_, name_='EntryEventType', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'EntryEventType':
            obj_ = EntryEventTypeType.factory()
            obj_.build(child_)
            self.EntryEventType.append(obj_)
            obj_.original_tagname_ = 'EntryEventType'
# end class EntryEventTypeValuesType


class EntryEventTypeType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ID=None, DeltaAction=None, valueOf_=None):
        self.original_tagname_ = None
        self.ID = _cast(int, ID)
        self.DeltaAction = _cast(None, DeltaAction)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, EntryEventTypeType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if EntryEventTypeType.subclass:
            return EntryEventTypeType.subclass(*args_, **kwargs_)
        else:
            return EntryEventTypeType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ID(self): return self.ID
    def set_ID(self, ID): self.ID = ID
    def get_DeltaAction(self): return self.DeltaAction
    def set_DeltaAction(self, DeltaAction): self.DeltaAction = DeltaAction
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_DeltaActionSchemaType(self, value):
        # Validate type DeltaActionSchemaType, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['add', 'amend', 'delete', 'revise']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on DeltaActionSchemaType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='un:', name_='EntryEventTypeType', namespacedef_='xmlns:un="http://www.un.org/sanctions/1.0"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('EntryEventTypeType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='EntryEventTypeType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='un:', name_='EntryEventTypeType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='un:', name_='EntryEventTypeType'):
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            outfile.write(' ID="%s"' % self.gds_format_integer(self.ID, input_name='ID'))
        if self.DeltaAction is not None and 'DeltaAction' not in already_processed:
            already_processed.add('DeltaAction')
            outfile.write(' DeltaAction=%s' % (quote_attrib(self.DeltaAction), ))
    def exportChildren(self, outfile, level, namespace_='un:', name_='EntryEventTypeType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            try:
                self.ID = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.ID < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = find_attr_value_('DeltaAction', node)
        if value is not None and 'DeltaAction' not in already_processed:
            already_processed.add('DeltaAction')
            self.DeltaAction = value
            self.validate_DeltaActionSchemaType(self.DeltaAction)    # validate type DeltaActionSchemaType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class EntryEventTypeType


class EntryLinkTypeValuesType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, EntryLinkType=None):
        self.original_tagname_ = None
        if EntryLinkType is None:
            self.EntryLinkType = []
        else:
            self.EntryLinkType = EntryLinkType
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, EntryLinkTypeValuesType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if EntryLinkTypeValuesType.subclass:
            return EntryLinkTypeValuesType.subclass(*args_, **kwargs_)
        else:
            return EntryLinkTypeValuesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_EntryLinkType(self): return self.EntryLinkType
    def set_EntryLinkType(self, EntryLinkType): self.EntryLinkType = EntryLinkType
    def add_EntryLinkType(self, value): self.EntryLinkType.append(value)
    def insert_EntryLinkType_at(self, index, value): self.EntryLinkType.insert(index, value)
    def replace_EntryLinkType_at(self, index, value): self.EntryLinkType[index] = value
    def hasContent_(self):
        if (
            self.EntryLinkType
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='un:', name_='EntryLinkTypeValuesType', namespacedef_='xmlns:un="http://www.un.org/sanctions/1.0"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('EntryLinkTypeValuesType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='EntryLinkTypeValuesType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='un:', name_='EntryLinkTypeValuesType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='un:', name_='EntryLinkTypeValuesType'):
        pass
    def exportChildren(self, outfile, level, namespace_='un:', name_='EntryLinkTypeValuesType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for EntryLinkType_ in self.EntryLinkType:
            EntryLinkType_.export(outfile, level, namespace_, name_='EntryLinkType', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'EntryLinkType':
            obj_ = EntryLinkTypeType.factory()
            obj_.build(child_)
            self.EntryLinkType.append(obj_)
            obj_.original_tagname_ = 'EntryLinkType'
# end class EntryLinkTypeValuesType


class EntryLinkTypeType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ID=None, DeltaAction=None, valueOf_=None):
        self.original_tagname_ = None
        self.ID = _cast(int, ID)
        self.DeltaAction = _cast(None, DeltaAction)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, EntryLinkTypeType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if EntryLinkTypeType.subclass:
            return EntryLinkTypeType.subclass(*args_, **kwargs_)
        else:
            return EntryLinkTypeType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ID(self): return self.ID
    def set_ID(self, ID): self.ID = ID
    def get_DeltaAction(self): return self.DeltaAction
    def set_DeltaAction(self, DeltaAction): self.DeltaAction = DeltaAction
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_DeltaActionSchemaType(self, value):
        # Validate type DeltaActionSchemaType, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['add', 'amend', 'delete', 'revise']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on DeltaActionSchemaType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='un:', name_='EntryLinkTypeType', namespacedef_='xmlns:un="http://www.un.org/sanctions/1.0"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('EntryLinkTypeType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='EntryLinkTypeType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='un:', name_='EntryLinkTypeType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='un:', name_='EntryLinkTypeType'):
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            outfile.write(' ID="%s"' % self.gds_format_integer(self.ID, input_name='ID'))
        if self.DeltaAction is not None and 'DeltaAction' not in already_processed:
            already_processed.add('DeltaAction')
            outfile.write(' DeltaAction=%s' % (quote_attrib(self.DeltaAction), ))
    def exportChildren(self, outfile, level, namespace_='un:', name_='EntryLinkTypeType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            try:
                self.ID = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.ID < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = find_attr_value_('DeltaAction', node)
        if value is not None and 'DeltaAction' not in already_processed:
            already_processed.add('DeltaAction')
            self.DeltaAction = value
            self.validate_DeltaActionSchemaType(self.DeltaAction)    # validate type DeltaActionSchemaType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class EntryLinkTypeType


class ExRefTypeValuesType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ExRefType=None):
        self.original_tagname_ = None
        if ExRefType is None:
            self.ExRefType = []
        else:
            self.ExRefType = ExRefType
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ExRefTypeValuesType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ExRefTypeValuesType.subclass:
            return ExRefTypeValuesType.subclass(*args_, **kwargs_)
        else:
            return ExRefTypeValuesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ExRefType(self): return self.ExRefType
    def set_ExRefType(self, ExRefType): self.ExRefType = ExRefType
    def add_ExRefType(self, value): self.ExRefType.append(value)
    def insert_ExRefType_at(self, index, value): self.ExRefType.insert(index, value)
    def replace_ExRefType_at(self, index, value): self.ExRefType[index] = value
    def hasContent_(self):
        if (
            self.ExRefType
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='un:', name_='ExRefTypeValuesType', namespacedef_='xmlns:un="http://www.un.org/sanctions/1.0"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ExRefTypeValuesType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ExRefTypeValuesType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='un:', name_='ExRefTypeValuesType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='un:', name_='ExRefTypeValuesType'):
        pass
    def exportChildren(self, outfile, level, namespace_='un:', name_='ExRefTypeValuesType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for ExRefType_ in self.ExRefType:
            ExRefType_.export(outfile, level, namespace_, name_='ExRefType', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ExRefType':
            obj_ = ExRefTypeType.factory()
            obj_.build(child_)
            self.ExRefType.append(obj_)
            obj_.original_tagname_ = 'ExRefType'
# end class ExRefTypeValuesType


class ExRefTypeType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ID=None, DeltaAction=None, valueOf_=None):
        self.original_tagname_ = None
        self.ID = _cast(int, ID)
        self.DeltaAction = _cast(None, DeltaAction)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ExRefTypeType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ExRefTypeType.subclass:
            return ExRefTypeType.subclass(*args_, **kwargs_)
        else:
            return ExRefTypeType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ID(self): return self.ID
    def set_ID(self, ID): self.ID = ID
    def get_DeltaAction(self): return self.DeltaAction
    def set_DeltaAction(self, DeltaAction): self.DeltaAction = DeltaAction
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_DeltaActionSchemaType(self, value):
        # Validate type DeltaActionSchemaType, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['add', 'amend', 'delete', 'revise']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on DeltaActionSchemaType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='un:', name_='ExRefTypeType', namespacedef_='xmlns:un="http://www.un.org/sanctions/1.0"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ExRefTypeType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ExRefTypeType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='un:', name_='ExRefTypeType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='un:', name_='ExRefTypeType'):
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            outfile.write(' ID="%s"' % self.gds_format_integer(self.ID, input_name='ID'))
        if self.DeltaAction is not None and 'DeltaAction' not in already_processed:
            already_processed.add('DeltaAction')
            outfile.write(' DeltaAction=%s' % (quote_attrib(self.DeltaAction), ))
    def exportChildren(self, outfile, level, namespace_='un:', name_='ExRefTypeType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            try:
                self.ID = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.ID < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = find_attr_value_('DeltaAction', node)
        if value is not None and 'DeltaAction' not in already_processed:
            already_processed.add('DeltaAction')
            self.DeltaAction = value
            self.validate_DeltaActionSchemaType(self.DeltaAction)    # validate type DeltaActionSchemaType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ExRefTypeType


class FeatureTypeValuesType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, FeatureType=None):
        self.original_tagname_ = None
        if FeatureType is None:
            self.FeatureType = []
        else:
            self.FeatureType = FeatureType
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FeatureTypeValuesType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FeatureTypeValuesType.subclass:
            return FeatureTypeValuesType.subclass(*args_, **kwargs_)
        else:
            return FeatureTypeValuesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_FeatureType(self): return self.FeatureType
    def set_FeatureType(self, FeatureType): self.FeatureType = FeatureType
    def add_FeatureType(self, value): self.FeatureType.append(value)
    def insert_FeatureType_at(self, index, value): self.FeatureType.insert(index, value)
    def replace_FeatureType_at(self, index, value): self.FeatureType[index] = value
    def hasContent_(self):
        if (
            self.FeatureType
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='un:', name_='FeatureTypeValuesType', namespacedef_='xmlns:un="http://www.un.org/sanctions/1.0"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('FeatureTypeValuesType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FeatureTypeValuesType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='un:', name_='FeatureTypeValuesType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='un:', name_='FeatureTypeValuesType'):
        pass
    def exportChildren(self, outfile, level, namespace_='un:', name_='FeatureTypeValuesType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for FeatureType_ in self.FeatureType:
            FeatureType_.export(outfile, level, namespace_, name_='FeatureType', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'FeatureType':
            obj_ = FeatureTypeType.factory()
            obj_.build(child_)
            self.FeatureType.append(obj_)
            obj_.original_tagname_ = 'FeatureType'
# end class FeatureTypeValuesType


class FeatureTypeType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ID=None, FeatureTypeGroupID=None, DeltaAction=None, valueOf_=None):
        self.original_tagname_ = None
        self.ID = _cast(int, ID)
        self.FeatureTypeGroupID = _cast(int, FeatureTypeGroupID)
        self.DeltaAction = _cast(None, DeltaAction)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FeatureTypeType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FeatureTypeType.subclass:
            return FeatureTypeType.subclass(*args_, **kwargs_)
        else:
            return FeatureTypeType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ID(self): return self.ID
    def set_ID(self, ID): self.ID = ID
    def get_FeatureTypeGroupID(self): return self.FeatureTypeGroupID
    def set_FeatureTypeGroupID(self, FeatureTypeGroupID): self.FeatureTypeGroupID = FeatureTypeGroupID
    def get_DeltaAction(self): return self.DeltaAction
    def set_DeltaAction(self, DeltaAction): self.DeltaAction = DeltaAction
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_DeltaActionSchemaType(self, value):
        # Validate type DeltaActionSchemaType, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['add', 'amend', 'delete', 'revise']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on DeltaActionSchemaType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='un:', name_='FeatureTypeType', namespacedef_='xmlns:un="http://www.un.org/sanctions/1.0"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('FeatureTypeType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FeatureTypeType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='un:', name_='FeatureTypeType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='un:', name_='FeatureTypeType'):
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            outfile.write(' ID="%s"' % self.gds_format_integer(self.ID, input_name='ID'))
        if self.FeatureTypeGroupID is not None and 'FeatureTypeGroupID' not in already_processed:
            already_processed.add('FeatureTypeGroupID')
            outfile.write(' FeatureTypeGroupID="%s"' % self.gds_format_integer(self.FeatureTypeGroupID, input_name='FeatureTypeGroupID'))
        if self.DeltaAction is not None and 'DeltaAction' not in already_processed:
            already_processed.add('DeltaAction')
            outfile.write(' DeltaAction=%s' % (quote_attrib(self.DeltaAction), ))
    def exportChildren(self, outfile, level, namespace_='un:', name_='FeatureTypeType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            try:
                self.ID = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.ID < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = find_attr_value_('FeatureTypeGroupID', node)
        if value is not None and 'FeatureTypeGroupID' not in already_processed:
            already_processed.add('FeatureTypeGroupID')
            try:
                self.FeatureTypeGroupID = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.FeatureTypeGroupID < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = find_attr_value_('DeltaAction', node)
        if value is not None and 'DeltaAction' not in already_processed:
            already_processed.add('DeltaAction')
            self.DeltaAction = value
            self.validate_DeltaActionSchemaType(self.DeltaAction)    # validate type DeltaActionSchemaType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class FeatureTypeType


class FeatureTypeGroupValuesType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, FeatureTypeGroup=None):
        self.original_tagname_ = None
        if FeatureTypeGroup is None:
            self.FeatureTypeGroup = []
        else:
            self.FeatureTypeGroup = FeatureTypeGroup
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FeatureTypeGroupValuesType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FeatureTypeGroupValuesType.subclass:
            return FeatureTypeGroupValuesType.subclass(*args_, **kwargs_)
        else:
            return FeatureTypeGroupValuesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_FeatureTypeGroup(self): return self.FeatureTypeGroup
    def set_FeatureTypeGroup(self, FeatureTypeGroup): self.FeatureTypeGroup = FeatureTypeGroup
    def add_FeatureTypeGroup(self, value): self.FeatureTypeGroup.append(value)
    def insert_FeatureTypeGroup_at(self, index, value): self.FeatureTypeGroup.insert(index, value)
    def replace_FeatureTypeGroup_at(self, index, value): self.FeatureTypeGroup[index] = value
    def hasContent_(self):
        if (
            self.FeatureTypeGroup
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='un:', name_='FeatureTypeGroupValuesType', namespacedef_='xmlns:un="http://www.un.org/sanctions/1.0"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('FeatureTypeGroupValuesType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FeatureTypeGroupValuesType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='un:', name_='FeatureTypeGroupValuesType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='un:', name_='FeatureTypeGroupValuesType'):
        pass
    def exportChildren(self, outfile, level, namespace_='un:', name_='FeatureTypeGroupValuesType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for FeatureTypeGroup_ in self.FeatureTypeGroup:
            FeatureTypeGroup_.export(outfile, level, namespace_, name_='FeatureTypeGroup', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'FeatureTypeGroup':
            obj_ = FeatureTypeGroupType.factory()
            obj_.build(child_)
            self.FeatureTypeGroup.append(obj_)
            obj_.original_tagname_ = 'FeatureTypeGroup'
# end class FeatureTypeGroupValuesType


class FeatureTypeGroupType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ID=None, DeltaAction=None, valueOf_=None):
        self.original_tagname_ = None
        self.ID = _cast(int, ID)
        self.DeltaAction = _cast(None, DeltaAction)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FeatureTypeGroupType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FeatureTypeGroupType.subclass:
            return FeatureTypeGroupType.subclass(*args_, **kwargs_)
        else:
            return FeatureTypeGroupType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ID(self): return self.ID
    def set_ID(self, ID): self.ID = ID
    def get_DeltaAction(self): return self.DeltaAction
    def set_DeltaAction(self, DeltaAction): self.DeltaAction = DeltaAction
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_DeltaActionSchemaType(self, value):
        # Validate type DeltaActionSchemaType, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['add', 'amend', 'delete', 'revise']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on DeltaActionSchemaType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='un:', name_='FeatureTypeGroupType', namespacedef_='xmlns:un="http://www.un.org/sanctions/1.0"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('FeatureTypeGroupType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FeatureTypeGroupType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='un:', name_='FeatureTypeGroupType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='un:', name_='FeatureTypeGroupType'):
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            outfile.write(' ID="%s"' % self.gds_format_integer(self.ID, input_name='ID'))
        if self.DeltaAction is not None and 'DeltaAction' not in already_processed:
            already_processed.add('DeltaAction')
            outfile.write(' DeltaAction=%s' % (quote_attrib(self.DeltaAction), ))
    def exportChildren(self, outfile, level, namespace_='un:', name_='FeatureTypeGroupType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            try:
                self.ID = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.ID < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = find_attr_value_('DeltaAction', node)
        if value is not None and 'DeltaAction' not in already_processed:
            already_processed.add('DeltaAction')
            self.DeltaAction = value
            self.validate_DeltaActionSchemaType(self.DeltaAction)    # validate type DeltaActionSchemaType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class FeatureTypeGroupType


class IDRegDocDateTypeValuesType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, IDRegDocDateType=None):
        self.original_tagname_ = None
        if IDRegDocDateType is None:
            self.IDRegDocDateType = []
        else:
            self.IDRegDocDateType = IDRegDocDateType
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, IDRegDocDateTypeValuesType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if IDRegDocDateTypeValuesType.subclass:
            return IDRegDocDateTypeValuesType.subclass(*args_, **kwargs_)
        else:
            return IDRegDocDateTypeValuesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_IDRegDocDateType(self): return self.IDRegDocDateType
    def set_IDRegDocDateType(self, IDRegDocDateType): self.IDRegDocDateType = IDRegDocDateType
    def add_IDRegDocDateType(self, value): self.IDRegDocDateType.append(value)
    def insert_IDRegDocDateType_at(self, index, value): self.IDRegDocDateType.insert(index, value)
    def replace_IDRegDocDateType_at(self, index, value): self.IDRegDocDateType[index] = value
    def hasContent_(self):
        if (
            self.IDRegDocDateType
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='un:', name_='IDRegDocDateTypeValuesType', namespacedef_='xmlns:un="http://www.un.org/sanctions/1.0"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('IDRegDocDateTypeValuesType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='IDRegDocDateTypeValuesType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='un:', name_='IDRegDocDateTypeValuesType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='un:', name_='IDRegDocDateTypeValuesType'):
        pass
    def exportChildren(self, outfile, level, namespace_='un:', name_='IDRegDocDateTypeValuesType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for IDRegDocDateType_ in self.IDRegDocDateType:
            IDRegDocDateType_.export(outfile, level, namespace_, name_='IDRegDocDateType', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'IDRegDocDateType':
            obj_ = IDRegDocDateTypeType.factory()
            obj_.build(child_)
            self.IDRegDocDateType.append(obj_)
            obj_.original_tagname_ = 'IDRegDocDateType'
# end class IDRegDocDateTypeValuesType


class IDRegDocDateTypeType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ID=None, DeltaAction=None, valueOf_=None):
        self.original_tagname_ = None
        self.ID = _cast(int, ID)
        self.DeltaAction = _cast(None, DeltaAction)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, IDRegDocDateTypeType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if IDRegDocDateTypeType.subclass:
            return IDRegDocDateTypeType.subclass(*args_, **kwargs_)
        else:
            return IDRegDocDateTypeType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ID(self): return self.ID
    def set_ID(self, ID): self.ID = ID
    def get_DeltaAction(self): return self.DeltaAction
    def set_DeltaAction(self, DeltaAction): self.DeltaAction = DeltaAction
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_DeltaActionSchemaType(self, value):
        # Validate type DeltaActionSchemaType, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['add', 'amend', 'delete', 'revise']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on DeltaActionSchemaType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='un:', name_='IDRegDocDateTypeType', namespacedef_='xmlns:un="http://www.un.org/sanctions/1.0"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('IDRegDocDateTypeType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='IDRegDocDateTypeType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='un:', name_='IDRegDocDateTypeType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='un:', name_='IDRegDocDateTypeType'):
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            outfile.write(' ID="%s"' % self.gds_format_integer(self.ID, input_name='ID'))
        if self.DeltaAction is not None and 'DeltaAction' not in already_processed:
            already_processed.add('DeltaAction')
            outfile.write(' DeltaAction=%s' % (quote_attrib(self.DeltaAction), ))
    def exportChildren(self, outfile, level, namespace_='un:', name_='IDRegDocDateTypeType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            try:
                self.ID = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.ID < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = find_attr_value_('DeltaAction', node)
        if value is not None and 'DeltaAction' not in already_processed:
            already_processed.add('DeltaAction')
            self.DeltaAction = value
            self.validate_DeltaActionSchemaType(self.DeltaAction)    # validate type DeltaActionSchemaType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class IDRegDocDateTypeType


class IDRegDocTypeValuesType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, IDRegDocType=None):
        self.original_tagname_ = None
        if IDRegDocType is None:
            self.IDRegDocType = []
        else:
            self.IDRegDocType = IDRegDocType
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, IDRegDocTypeValuesType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if IDRegDocTypeValuesType.subclass:
            return IDRegDocTypeValuesType.subclass(*args_, **kwargs_)
        else:
            return IDRegDocTypeValuesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_IDRegDocType(self): return self.IDRegDocType
    def set_IDRegDocType(self, IDRegDocType): self.IDRegDocType = IDRegDocType
    def add_IDRegDocType(self, value): self.IDRegDocType.append(value)
    def insert_IDRegDocType_at(self, index, value): self.IDRegDocType.insert(index, value)
    def replace_IDRegDocType_at(self, index, value): self.IDRegDocType[index] = value
    def hasContent_(self):
        if (
            self.IDRegDocType
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='un:', name_='IDRegDocTypeValuesType', namespacedef_='xmlns:un="http://www.un.org/sanctions/1.0"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('IDRegDocTypeValuesType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='IDRegDocTypeValuesType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='un:', name_='IDRegDocTypeValuesType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='un:', name_='IDRegDocTypeValuesType'):
        pass
    def exportChildren(self, outfile, level, namespace_='un:', name_='IDRegDocTypeValuesType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for IDRegDocType_ in self.IDRegDocType:
            IDRegDocType_.export(outfile, level, namespace_, name_='IDRegDocType', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'IDRegDocType':
            obj_ = IDRegDocTypeType.factory()
            obj_.build(child_)
            self.IDRegDocType.append(obj_)
            obj_.original_tagname_ = 'IDRegDocType'
# end class IDRegDocTypeValuesType


class IDRegDocTypeType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ID=None, DeltaAction=None, valueOf_=None):
        self.original_tagname_ = None
        self.ID = _cast(int, ID)
        self.DeltaAction = _cast(None, DeltaAction)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, IDRegDocTypeType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if IDRegDocTypeType.subclass:
            return IDRegDocTypeType.subclass(*args_, **kwargs_)
        else:
            return IDRegDocTypeType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ID(self): return self.ID
    def set_ID(self, ID): self.ID = ID
    def get_DeltaAction(self): return self.DeltaAction
    def set_DeltaAction(self, DeltaAction): self.DeltaAction = DeltaAction
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_DeltaActionSchemaType(self, value):
        # Validate type DeltaActionSchemaType, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['add', 'amend', 'delete', 'revise']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on DeltaActionSchemaType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='un:', name_='IDRegDocTypeType', namespacedef_='xmlns:un="http://www.un.org/sanctions/1.0"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('IDRegDocTypeType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='IDRegDocTypeType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='un:', name_='IDRegDocTypeType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='un:', name_='IDRegDocTypeType'):
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            outfile.write(' ID="%s"' % self.gds_format_integer(self.ID, input_name='ID'))
        if self.DeltaAction is not None and 'DeltaAction' not in already_processed:
            already_processed.add('DeltaAction')
            outfile.write(' DeltaAction=%s' % (quote_attrib(self.DeltaAction), ))
    def exportChildren(self, outfile, level, namespace_='un:', name_='IDRegDocTypeType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            try:
                self.ID = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.ID < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = find_attr_value_('DeltaAction', node)
        if value is not None and 'DeltaAction' not in already_processed:
            already_processed.add('DeltaAction')
            self.DeltaAction = value
            self.validate_DeltaActionSchemaType(self.DeltaAction)    # validate type DeltaActionSchemaType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class IDRegDocTypeType


class IdentityFeatureLinkTypeValuesType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, IdentityFeatureLinkType=None):
        self.original_tagname_ = None
        if IdentityFeatureLinkType is None:
            self.IdentityFeatureLinkType = []
        else:
            self.IdentityFeatureLinkType = IdentityFeatureLinkType
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, IdentityFeatureLinkTypeValuesType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if IdentityFeatureLinkTypeValuesType.subclass:
            return IdentityFeatureLinkTypeValuesType.subclass(*args_, **kwargs_)
        else:
            return IdentityFeatureLinkTypeValuesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_IdentityFeatureLinkType(self): return self.IdentityFeatureLinkType
    def set_IdentityFeatureLinkType(self, IdentityFeatureLinkType): self.IdentityFeatureLinkType = IdentityFeatureLinkType
    def add_IdentityFeatureLinkType(self, value): self.IdentityFeatureLinkType.append(value)
    def insert_IdentityFeatureLinkType_at(self, index, value): self.IdentityFeatureLinkType.insert(index, value)
    def replace_IdentityFeatureLinkType_at(self, index, value): self.IdentityFeatureLinkType[index] = value
    def hasContent_(self):
        if (
            self.IdentityFeatureLinkType
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='un:', name_='IdentityFeatureLinkTypeValuesType', namespacedef_='xmlns:un="http://www.un.org/sanctions/1.0"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('IdentityFeatureLinkTypeValuesType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='IdentityFeatureLinkTypeValuesType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='un:', name_='IdentityFeatureLinkTypeValuesType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='un:', name_='IdentityFeatureLinkTypeValuesType'):
        pass
    def exportChildren(self, outfile, level, namespace_='un:', name_='IdentityFeatureLinkTypeValuesType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for IdentityFeatureLinkType_ in self.IdentityFeatureLinkType:
            IdentityFeatureLinkType_.export(outfile, level, namespace_, name_='IdentityFeatureLinkType', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'IdentityFeatureLinkType':
            obj_ = IdentityFeatureLinkTypeType.factory()
            obj_.build(child_)
            self.IdentityFeatureLinkType.append(obj_)
            obj_.original_tagname_ = 'IdentityFeatureLinkType'
# end class IdentityFeatureLinkTypeValuesType


class IdentityFeatureLinkTypeType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ID=None, DeltaAction=None, valueOf_=None):
        self.original_tagname_ = None
        self.ID = _cast(int, ID)
        self.DeltaAction = _cast(None, DeltaAction)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, IdentityFeatureLinkTypeType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if IdentityFeatureLinkTypeType.subclass:
            return IdentityFeatureLinkTypeType.subclass(*args_, **kwargs_)
        else:
            return IdentityFeatureLinkTypeType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ID(self): return self.ID
    def set_ID(self, ID): self.ID = ID
    def get_DeltaAction(self): return self.DeltaAction
    def set_DeltaAction(self, DeltaAction): self.DeltaAction = DeltaAction
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_DeltaActionSchemaType(self, value):
        # Validate type DeltaActionSchemaType, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['add', 'amend', 'delete', 'revise']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on DeltaActionSchemaType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='un:', name_='IdentityFeatureLinkTypeType', namespacedef_='xmlns:un="http://www.un.org/sanctions/1.0"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('IdentityFeatureLinkTypeType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='IdentityFeatureLinkTypeType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='un:', name_='IdentityFeatureLinkTypeType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='un:', name_='IdentityFeatureLinkTypeType'):
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            outfile.write(' ID="%s"' % self.gds_format_integer(self.ID, input_name='ID'))
        if self.DeltaAction is not None and 'DeltaAction' not in already_processed:
            already_processed.add('DeltaAction')
            outfile.write(' DeltaAction=%s' % (quote_attrib(self.DeltaAction), ))
    def exportChildren(self, outfile, level, namespace_='un:', name_='IdentityFeatureLinkTypeType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            try:
                self.ID = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.ID < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = find_attr_value_('DeltaAction', node)
        if value is not None and 'DeltaAction' not in already_processed:
            already_processed.add('DeltaAction')
            self.DeltaAction = value
            self.validate_DeltaActionSchemaType(self.DeltaAction)    # validate type DeltaActionSchemaType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class IdentityFeatureLinkTypeType


class LegalBasisValuesType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, LegalBasis=None):
        self.original_tagname_ = None
        if LegalBasis is None:
            self.LegalBasis = []
        else:
            self.LegalBasis = LegalBasis
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, LegalBasisValuesType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LegalBasisValuesType.subclass:
            return LegalBasisValuesType.subclass(*args_, **kwargs_)
        else:
            return LegalBasisValuesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_LegalBasis(self): return self.LegalBasis
    def set_LegalBasis(self, LegalBasis): self.LegalBasis = LegalBasis
    def add_LegalBasis(self, value): self.LegalBasis.append(value)
    def insert_LegalBasis_at(self, index, value): self.LegalBasis.insert(index, value)
    def replace_LegalBasis_at(self, index, value): self.LegalBasis[index] = value
    def hasContent_(self):
        if (
            self.LegalBasis
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='un:', name_='LegalBasisValuesType', namespacedef_='xmlns:un="http://www.un.org/sanctions/1.0"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('LegalBasisValuesType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LegalBasisValuesType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='un:', name_='LegalBasisValuesType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='un:', name_='LegalBasisValuesType'):
        pass
    def exportChildren(self, outfile, level, namespace_='un:', name_='LegalBasisValuesType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for LegalBasis_ in self.LegalBasis:
            LegalBasis_.export(outfile, level, namespace_, name_='LegalBasis', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'LegalBasis':
            obj_ = LegalBasisType2.factory()
            obj_.build(child_)
            self.LegalBasis.append(obj_)
            obj_.original_tagname_ = 'LegalBasis'
# end class LegalBasisValuesType


class LegalBasisType2(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ID=None, LegalBasisShortRef=None, LegalBasisTypeID=None, SanctionsProgramID=None, DeltaAction=None, valueOf_=None):
        self.original_tagname_ = None
        self.ID = _cast(int, ID)
        self.LegalBasisShortRef = _cast(None, LegalBasisShortRef)
        self.LegalBasisTypeID = _cast(int, LegalBasisTypeID)
        self.SanctionsProgramID = _cast(int, SanctionsProgramID)
        self.DeltaAction = _cast(None, DeltaAction)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, LegalBasisType2)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LegalBasisType2.subclass:
            return LegalBasisType2.subclass(*args_, **kwargs_)
        else:
            return LegalBasisType2(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ID(self): return self.ID
    def set_ID(self, ID): self.ID = ID
    def get_LegalBasisShortRef(self): return self.LegalBasisShortRef
    def set_LegalBasisShortRef(self, LegalBasisShortRef): self.LegalBasisShortRef = LegalBasisShortRef
    def get_LegalBasisTypeID(self): return self.LegalBasisTypeID
    def set_LegalBasisTypeID(self, LegalBasisTypeID): self.LegalBasisTypeID = LegalBasisTypeID
    def get_SanctionsProgramID(self): return self.SanctionsProgramID
    def set_SanctionsProgramID(self, SanctionsProgramID): self.SanctionsProgramID = SanctionsProgramID
    def get_DeltaAction(self): return self.DeltaAction
    def set_DeltaAction(self, DeltaAction): self.DeltaAction = DeltaAction
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_DeltaActionSchemaType(self, value):
        # Validate type DeltaActionSchemaType, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['add', 'amend', 'delete', 'revise']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on DeltaActionSchemaType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='un:', name_='LegalBasisType2', namespacedef_='xmlns:un="http://www.un.org/sanctions/1.0"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('LegalBasisType2')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LegalBasisType2')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='un:', name_='LegalBasisType2', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='un:', name_='LegalBasisType2'):
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            outfile.write(' ID="%s"' % self.gds_format_integer(self.ID, input_name='ID'))
        if self.LegalBasisShortRef is not None and 'LegalBasisShortRef' not in already_processed:
            already_processed.add('LegalBasisShortRef')
            outfile.write(' LegalBasisShortRef=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.LegalBasisShortRef), input_name='LegalBasisShortRef')), ))
        if self.LegalBasisTypeID is not None and 'LegalBasisTypeID' not in already_processed:
            already_processed.add('LegalBasisTypeID')
            outfile.write(' LegalBasisTypeID="%s"' % self.gds_format_integer(self.LegalBasisTypeID, input_name='LegalBasisTypeID'))
        if self.SanctionsProgramID is not None and 'SanctionsProgramID' not in already_processed:
            already_processed.add('SanctionsProgramID')
            outfile.write(' SanctionsProgramID="%s"' % self.gds_format_integer(self.SanctionsProgramID, input_name='SanctionsProgramID'))
        if self.DeltaAction is not None and 'DeltaAction' not in already_processed:
            already_processed.add('DeltaAction')
            outfile.write(' DeltaAction=%s' % (quote_attrib(self.DeltaAction), ))
    def exportChildren(self, outfile, level, namespace_='un:', name_='LegalBasisType2', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            try:
                self.ID = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.ID < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = find_attr_value_('LegalBasisShortRef', node)
        if value is not None and 'LegalBasisShortRef' not in already_processed:
            already_processed.add('LegalBasisShortRef')
            self.LegalBasisShortRef = value
        value = find_attr_value_('LegalBasisTypeID', node)
        if value is not None and 'LegalBasisTypeID' not in already_processed:
            already_processed.add('LegalBasisTypeID')
            try:
                self.LegalBasisTypeID = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.LegalBasisTypeID < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = find_attr_value_('SanctionsProgramID', node)
        if value is not None and 'SanctionsProgramID' not in already_processed:
            already_processed.add('SanctionsProgramID')
            try:
                self.SanctionsProgramID = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.SanctionsProgramID < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = find_attr_value_('DeltaAction', node)
        if value is not None and 'DeltaAction' not in already_processed:
            already_processed.add('DeltaAction')
            self.DeltaAction = value
            self.validate_DeltaActionSchemaType(self.DeltaAction)    # validate type DeltaActionSchemaType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class LegalBasisType2


class LegalBasisTypeValuesType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, LegalBasisType=None):
        self.original_tagname_ = None
        if LegalBasisType is None:
            self.LegalBasisType = []
        else:
            self.LegalBasisType = LegalBasisType
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, LegalBasisTypeValuesType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LegalBasisTypeValuesType.subclass:
            return LegalBasisTypeValuesType.subclass(*args_, **kwargs_)
        else:
            return LegalBasisTypeValuesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_LegalBasisType(self): return self.LegalBasisType
    def set_LegalBasisType(self, LegalBasisType): self.LegalBasisType = LegalBasisType
    def add_LegalBasisType(self, value): self.LegalBasisType.append(value)
    def insert_LegalBasisType_at(self, index, value): self.LegalBasisType.insert(index, value)
    def replace_LegalBasisType_at(self, index, value): self.LegalBasisType[index] = value
    def hasContent_(self):
        if (
            self.LegalBasisType
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='un:', name_='LegalBasisTypeValuesType', namespacedef_='xmlns:un="http://www.un.org/sanctions/1.0"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('LegalBasisTypeValuesType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LegalBasisTypeValuesType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='un:', name_='LegalBasisTypeValuesType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='un:', name_='LegalBasisTypeValuesType'):
        pass
    def exportChildren(self, outfile, level, namespace_='un:', name_='LegalBasisTypeValuesType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for LegalBasisType_ in self.LegalBasisType:
            LegalBasisType_.export(outfile, level, namespace_, name_='LegalBasisType', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'LegalBasisType':
            obj_ = LegalBasisTypeType.factory()
            obj_.build(child_)
            self.LegalBasisType.append(obj_)
            obj_.original_tagname_ = 'LegalBasisType'
# end class LegalBasisTypeValuesType


class LegalBasisTypeType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ID=None, DeltaAction=None, valueOf_=None):
        self.original_tagname_ = None
        self.ID = _cast(int, ID)
        self.DeltaAction = _cast(None, DeltaAction)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, LegalBasisTypeType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LegalBasisTypeType.subclass:
            return LegalBasisTypeType.subclass(*args_, **kwargs_)
        else:
            return LegalBasisTypeType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ID(self): return self.ID
    def set_ID(self, ID): self.ID = ID
    def get_DeltaAction(self): return self.DeltaAction
    def set_DeltaAction(self, DeltaAction): self.DeltaAction = DeltaAction
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_DeltaActionSchemaType(self, value):
        # Validate type DeltaActionSchemaType, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['add', 'amend', 'delete', 'revise']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on DeltaActionSchemaType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='un:', name_='LegalBasisTypeType', namespacedef_='xmlns:un="http://www.un.org/sanctions/1.0"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('LegalBasisTypeType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LegalBasisTypeType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='un:', name_='LegalBasisTypeType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='un:', name_='LegalBasisTypeType'):
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            outfile.write(' ID="%s"' % self.gds_format_integer(self.ID, input_name='ID'))
        if self.DeltaAction is not None and 'DeltaAction' not in already_processed:
            already_processed.add('DeltaAction')
            outfile.write(' DeltaAction=%s' % (quote_attrib(self.DeltaAction), ))
    def exportChildren(self, outfile, level, namespace_='un:', name_='LegalBasisTypeType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            try:
                self.ID = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.ID < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = find_attr_value_('DeltaAction', node)
        if value is not None and 'DeltaAction' not in already_processed:
            already_processed.add('DeltaAction')
            self.DeltaAction = value
            self.validate_DeltaActionSchemaType(self.DeltaAction)    # validate type DeltaActionSchemaType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class LegalBasisTypeType


class ListValuesType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, List=None):
        self.original_tagname_ = None
        if List is None:
            self.List = []
        else:
            self.List = List
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ListValuesType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ListValuesType.subclass:
            return ListValuesType.subclass(*args_, **kwargs_)
        else:
            return ListValuesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_List(self): return self.List
    def set_List(self, List): self.List = List
    def add_List(self, value): self.List.append(value)
    def insert_List_at(self, index, value): self.List.insert(index, value)
    def replace_List_at(self, index, value): self.List[index] = value
    def hasContent_(self):
        if (
            self.List
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='un:', name_='ListValuesType', namespacedef_='xmlns:un="http://www.un.org/sanctions/1.0"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ListValuesType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ListValuesType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='un:', name_='ListValuesType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='un:', name_='ListValuesType'):
        pass
    def exportChildren(self, outfile, level, namespace_='un:', name_='ListValuesType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for List_ in self.List:
            List_.export(outfile, level, namespace_, name_='List', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'List':
            obj_ = ListType.factory()
            obj_.build(child_)
            self.List.append(obj_)
            obj_.original_tagname_ = 'List'
# end class ListValuesType


class ListType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ID=None, Comment=None, DeltaAction=None, valueOf_=None):
        self.original_tagname_ = None
        self.ID = _cast(int, ID)
        self.Comment = _cast(None, Comment)
        self.DeltaAction = _cast(None, DeltaAction)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ListType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ListType.subclass:
            return ListType.subclass(*args_, **kwargs_)
        else:
            return ListType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ID(self): return self.ID
    def set_ID(self, ID): self.ID = ID
    def get_Comment(self): return self.Comment
    def set_Comment(self, Comment): self.Comment = Comment
    def get_DeltaAction(self): return self.DeltaAction
    def set_DeltaAction(self, DeltaAction): self.DeltaAction = DeltaAction
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_DeltaActionSchemaType(self, value):
        # Validate type DeltaActionSchemaType, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['add', 'amend', 'delete', 'revise']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on DeltaActionSchemaType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='un:', name_='ListType', namespacedef_='xmlns:un="http://www.un.org/sanctions/1.0"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ListType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ListType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='un:', name_='ListType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='un:', name_='ListType'):
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            outfile.write(' ID="%s"' % self.gds_format_integer(self.ID, input_name='ID'))
        if self.Comment is not None and 'Comment' not in already_processed:
            already_processed.add('Comment')
            outfile.write(' Comment=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Comment), input_name='Comment')), ))
        if self.DeltaAction is not None and 'DeltaAction' not in already_processed:
            already_processed.add('DeltaAction')
            outfile.write(' DeltaAction=%s' % (quote_attrib(self.DeltaAction), ))
    def exportChildren(self, outfile, level, namespace_='un:', name_='ListType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            try:
                self.ID = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.ID < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = find_attr_value_('Comment', node)
        if value is not None and 'Comment' not in already_processed:
            already_processed.add('Comment')
            self.Comment = value
        value = find_attr_value_('DeltaAction', node)
        if value is not None and 'DeltaAction' not in already_processed:
            already_processed.add('DeltaAction')
            self.DeltaAction = value
            self.validate_DeltaActionSchemaType(self.DeltaAction)    # validate type DeltaActionSchemaType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ListType


class LocPartTypeValuesType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, LocPartType=None):
        self.original_tagname_ = None
        if LocPartType is None:
            self.LocPartType = []
        else:
            self.LocPartType = LocPartType
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, LocPartTypeValuesType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LocPartTypeValuesType.subclass:
            return LocPartTypeValuesType.subclass(*args_, **kwargs_)
        else:
            return LocPartTypeValuesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_LocPartType(self): return self.LocPartType
    def set_LocPartType(self, LocPartType): self.LocPartType = LocPartType
    def add_LocPartType(self, value): self.LocPartType.append(value)
    def insert_LocPartType_at(self, index, value): self.LocPartType.insert(index, value)
    def replace_LocPartType_at(self, index, value): self.LocPartType[index] = value
    def hasContent_(self):
        if (
            self.LocPartType
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='un:', name_='LocPartTypeValuesType', namespacedef_='xmlns:un="http://www.un.org/sanctions/1.0"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('LocPartTypeValuesType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LocPartTypeValuesType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='un:', name_='LocPartTypeValuesType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='un:', name_='LocPartTypeValuesType'):
        pass
    def exportChildren(self, outfile, level, namespace_='un:', name_='LocPartTypeValuesType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for LocPartType_ in self.LocPartType:
            LocPartType_.export(outfile, level, namespace_, name_='LocPartType', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'LocPartType':
            obj_ = LocPartTypeType.factory()
            obj_.build(child_)
            self.LocPartType.append(obj_)
            obj_.original_tagname_ = 'LocPartType'
# end class LocPartTypeValuesType


class LocPartTypeType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ID=None, DeltaAction=None, valueOf_=None):
        self.original_tagname_ = None
        self.ID = _cast(int, ID)
        self.DeltaAction = _cast(None, DeltaAction)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, LocPartTypeType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LocPartTypeType.subclass:
            return LocPartTypeType.subclass(*args_, **kwargs_)
        else:
            return LocPartTypeType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ID(self): return self.ID
    def set_ID(self, ID): self.ID = ID
    def get_DeltaAction(self): return self.DeltaAction
    def set_DeltaAction(self, DeltaAction): self.DeltaAction = DeltaAction
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_DeltaActionSchemaType(self, value):
        # Validate type DeltaActionSchemaType, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['add', 'amend', 'delete', 'revise']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on DeltaActionSchemaType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='un:', name_='LocPartTypeType', namespacedef_='xmlns:un="http://www.un.org/sanctions/1.0"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('LocPartTypeType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LocPartTypeType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='un:', name_='LocPartTypeType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='un:', name_='LocPartTypeType'):
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            outfile.write(' ID="%s"' % self.gds_format_integer(self.ID, input_name='ID'))
        if self.DeltaAction is not None and 'DeltaAction' not in already_processed:
            already_processed.add('DeltaAction')
            outfile.write(' DeltaAction=%s' % (quote_attrib(self.DeltaAction), ))
    def exportChildren(self, outfile, level, namespace_='un:', name_='LocPartTypeType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            try:
                self.ID = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.ID < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = find_attr_value_('DeltaAction', node)
        if value is not None and 'DeltaAction' not in already_processed:
            already_processed.add('DeltaAction')
            self.DeltaAction = value
            self.validate_DeltaActionSchemaType(self.DeltaAction)    # validate type DeltaActionSchemaType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class LocPartTypeType


class LocPartValueStatusValuesType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, LocPartValueStatus=None):
        self.original_tagname_ = None
        if LocPartValueStatus is None:
            self.LocPartValueStatus = []
        else:
            self.LocPartValueStatus = LocPartValueStatus
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, LocPartValueStatusValuesType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LocPartValueStatusValuesType.subclass:
            return LocPartValueStatusValuesType.subclass(*args_, **kwargs_)
        else:
            return LocPartValueStatusValuesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_LocPartValueStatus(self): return self.LocPartValueStatus
    def set_LocPartValueStatus(self, LocPartValueStatus): self.LocPartValueStatus = LocPartValueStatus
    def add_LocPartValueStatus(self, value): self.LocPartValueStatus.append(value)
    def insert_LocPartValueStatus_at(self, index, value): self.LocPartValueStatus.insert(index, value)
    def replace_LocPartValueStatus_at(self, index, value): self.LocPartValueStatus[index] = value
    def hasContent_(self):
        if (
            self.LocPartValueStatus
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='un:', name_='LocPartValueStatusValuesType', namespacedef_='xmlns:un="http://www.un.org/sanctions/1.0"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('LocPartValueStatusValuesType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LocPartValueStatusValuesType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='un:', name_='LocPartValueStatusValuesType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='un:', name_='LocPartValueStatusValuesType'):
        pass
    def exportChildren(self, outfile, level, namespace_='un:', name_='LocPartValueStatusValuesType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for LocPartValueStatus_ in self.LocPartValueStatus:
            LocPartValueStatus_.export(outfile, level, namespace_, name_='LocPartValueStatus', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'LocPartValueStatus':
            obj_ = LocPartValueStatusType.factory()
            obj_.build(child_)
            self.LocPartValueStatus.append(obj_)
            obj_.original_tagname_ = 'LocPartValueStatus'
# end class LocPartValueStatusValuesType


class LocPartValueStatusType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ID=None, DeltaAction=None, valueOf_=None):
        self.original_tagname_ = None
        self.ID = _cast(int, ID)
        self.DeltaAction = _cast(None, DeltaAction)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, LocPartValueStatusType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LocPartValueStatusType.subclass:
            return LocPartValueStatusType.subclass(*args_, **kwargs_)
        else:
            return LocPartValueStatusType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ID(self): return self.ID
    def set_ID(self, ID): self.ID = ID
    def get_DeltaAction(self): return self.DeltaAction
    def set_DeltaAction(self, DeltaAction): self.DeltaAction = DeltaAction
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_DeltaActionSchemaType(self, value):
        # Validate type DeltaActionSchemaType, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['add', 'amend', 'delete', 'revise']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on DeltaActionSchemaType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='un:', name_='LocPartValueStatusType', namespacedef_='xmlns:un="http://www.un.org/sanctions/1.0"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('LocPartValueStatusType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LocPartValueStatusType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='un:', name_='LocPartValueStatusType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='un:', name_='LocPartValueStatusType'):
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            outfile.write(' ID="%s"' % self.gds_format_integer(self.ID, input_name='ID'))
        if self.DeltaAction is not None and 'DeltaAction' not in already_processed:
            already_processed.add('DeltaAction')
            outfile.write(' DeltaAction=%s' % (quote_attrib(self.DeltaAction), ))
    def exportChildren(self, outfile, level, namespace_='un:', name_='LocPartValueStatusType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            try:
                self.ID = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.ID < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = find_attr_value_('DeltaAction', node)
        if value is not None and 'DeltaAction' not in already_processed:
            already_processed.add('DeltaAction')
            self.DeltaAction = value
            self.validate_DeltaActionSchemaType(self.DeltaAction)    # validate type DeltaActionSchemaType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class LocPartValueStatusType


class LocPartValueTypeValuesType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, LocPartValueType=None):
        self.original_tagname_ = None
        if LocPartValueType is None:
            self.LocPartValueType = []
        else:
            self.LocPartValueType = LocPartValueType
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, LocPartValueTypeValuesType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LocPartValueTypeValuesType.subclass:
            return LocPartValueTypeValuesType.subclass(*args_, **kwargs_)
        else:
            return LocPartValueTypeValuesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_LocPartValueType(self): return self.LocPartValueType
    def set_LocPartValueType(self, LocPartValueType): self.LocPartValueType = LocPartValueType
    def add_LocPartValueType(self, value): self.LocPartValueType.append(value)
    def insert_LocPartValueType_at(self, index, value): self.LocPartValueType.insert(index, value)
    def replace_LocPartValueType_at(self, index, value): self.LocPartValueType[index] = value
    def hasContent_(self):
        if (
            self.LocPartValueType
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='un:', name_='LocPartValueTypeValuesType', namespacedef_='xmlns:un="http://www.un.org/sanctions/1.0"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('LocPartValueTypeValuesType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LocPartValueTypeValuesType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='un:', name_='LocPartValueTypeValuesType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='un:', name_='LocPartValueTypeValuesType'):
        pass
    def exportChildren(self, outfile, level, namespace_='un:', name_='LocPartValueTypeValuesType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for LocPartValueType_ in self.LocPartValueType:
            LocPartValueType_.export(outfile, level, namespace_, name_='LocPartValueType', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'LocPartValueType':
            obj_ = LocPartValueTypeType.factory()
            obj_.build(child_)
            self.LocPartValueType.append(obj_)
            obj_.original_tagname_ = 'LocPartValueType'
# end class LocPartValueTypeValuesType


class LocPartValueTypeType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ID=None, DeltaAction=None, valueOf_=None):
        self.original_tagname_ = None
        self.ID = _cast(int, ID)
        self.DeltaAction = _cast(None, DeltaAction)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, LocPartValueTypeType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LocPartValueTypeType.subclass:
            return LocPartValueTypeType.subclass(*args_, **kwargs_)
        else:
            return LocPartValueTypeType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ID(self): return self.ID
    def set_ID(self, ID): self.ID = ID
    def get_DeltaAction(self): return self.DeltaAction
    def set_DeltaAction(self, DeltaAction): self.DeltaAction = DeltaAction
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_DeltaActionSchemaType(self, value):
        # Validate type DeltaActionSchemaType, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['add', 'amend', 'delete', 'revise']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on DeltaActionSchemaType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='un:', name_='LocPartValueTypeType', namespacedef_='xmlns:un="http://www.un.org/sanctions/1.0"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('LocPartValueTypeType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LocPartValueTypeType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='un:', name_='LocPartValueTypeType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='un:', name_='LocPartValueTypeType'):
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            outfile.write(' ID="%s"' % self.gds_format_integer(self.ID, input_name='ID'))
        if self.DeltaAction is not None and 'DeltaAction' not in already_processed:
            already_processed.add('DeltaAction')
            outfile.write(' DeltaAction=%s' % (quote_attrib(self.DeltaAction), ))
    def exportChildren(self, outfile, level, namespace_='un:', name_='LocPartValueTypeType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            try:
                self.ID = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.ID < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = find_attr_value_('DeltaAction', node)
        if value is not None and 'DeltaAction' not in already_processed:
            already_processed.add('DeltaAction')
            self.DeltaAction = value
            self.validate_DeltaActionSchemaType(self.DeltaAction)    # validate type DeltaActionSchemaType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class LocPartValueTypeType


class NamePartTypeValuesType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, NamePartType=None):
        self.original_tagname_ = None
        if NamePartType is None:
            self.NamePartType = []
        else:
            self.NamePartType = NamePartType
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, NamePartTypeValuesType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if NamePartTypeValuesType.subclass:
            return NamePartTypeValuesType.subclass(*args_, **kwargs_)
        else:
            return NamePartTypeValuesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_NamePartType(self): return self.NamePartType
    def set_NamePartType(self, NamePartType): self.NamePartType = NamePartType
    def add_NamePartType(self, value): self.NamePartType.append(value)
    def insert_NamePartType_at(self, index, value): self.NamePartType.insert(index, value)
    def replace_NamePartType_at(self, index, value): self.NamePartType[index] = value
    def hasContent_(self):
        if (
            self.NamePartType
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='un:', name_='NamePartTypeValuesType', namespacedef_='xmlns:un="http://www.un.org/sanctions/1.0"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('NamePartTypeValuesType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='NamePartTypeValuesType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='un:', name_='NamePartTypeValuesType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='un:', name_='NamePartTypeValuesType'):
        pass
    def exportChildren(self, outfile, level, namespace_='un:', name_='NamePartTypeValuesType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for NamePartType_ in self.NamePartType:
            NamePartType_.export(outfile, level, namespace_, name_='NamePartType', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'NamePartType':
            obj_ = NamePartTypeType.factory()
            obj_.build(child_)
            self.NamePartType.append(obj_)
            obj_.original_tagname_ = 'NamePartType'
# end class NamePartTypeValuesType


class NamePartTypeType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ID=None, DeltaAction=None, valueOf_=None):
        self.original_tagname_ = None
        self.ID = _cast(int, ID)
        self.DeltaAction = _cast(None, DeltaAction)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, NamePartTypeType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if NamePartTypeType.subclass:
            return NamePartTypeType.subclass(*args_, **kwargs_)
        else:
            return NamePartTypeType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ID(self): return self.ID
    def set_ID(self, ID): self.ID = ID
    def get_DeltaAction(self): return self.DeltaAction
    def set_DeltaAction(self, DeltaAction): self.DeltaAction = DeltaAction
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_DeltaActionSchemaType(self, value):
        # Validate type DeltaActionSchemaType, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['add', 'amend', 'delete', 'revise']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on DeltaActionSchemaType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='un:', name_='NamePartTypeType', namespacedef_='xmlns:un="http://www.un.org/sanctions/1.0"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('NamePartTypeType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='NamePartTypeType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='un:', name_='NamePartTypeType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='un:', name_='NamePartTypeType'):
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            outfile.write(' ID="%s"' % self.gds_format_integer(self.ID, input_name='ID'))
        if self.DeltaAction is not None and 'DeltaAction' not in already_processed:
            already_processed.add('DeltaAction')
            outfile.write(' DeltaAction=%s' % (quote_attrib(self.DeltaAction), ))
    def exportChildren(self, outfile, level, namespace_='un:', name_='NamePartTypeType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            try:
                self.ID = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.ID < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = find_attr_value_('DeltaAction', node)
        if value is not None and 'DeltaAction' not in already_processed:
            already_processed.add('DeltaAction')
            self.DeltaAction = value
            self.validate_DeltaActionSchemaType(self.DeltaAction)    # validate type DeltaActionSchemaType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class NamePartTypeType


class OrganisationValuesType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Organisation=None):
        self.original_tagname_ = None
        if Organisation is None:
            self.Organisation = []
        else:
            self.Organisation = Organisation
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, OrganisationValuesType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if OrganisationValuesType.subclass:
            return OrganisationValuesType.subclass(*args_, **kwargs_)
        else:
            return OrganisationValuesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Organisation(self): return self.Organisation
    def set_Organisation(self, Organisation): self.Organisation = Organisation
    def add_Organisation(self, value): self.Organisation.append(value)
    def insert_Organisation_at(self, index, value): self.Organisation.insert(index, value)
    def replace_Organisation_at(self, index, value): self.Organisation[index] = value
    def hasContent_(self):
        if (
            self.Organisation
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='un:', name_='OrganisationValuesType', namespacedef_='xmlns:un="http://www.un.org/sanctions/1.0"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('OrganisationValuesType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='OrganisationValuesType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='un:', name_='OrganisationValuesType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='un:', name_='OrganisationValuesType'):
        pass
    def exportChildren(self, outfile, level, namespace_='un:', name_='OrganisationValuesType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Organisation_ in self.Organisation:
            Organisation_.export(outfile, level, namespace_, name_='Organisation', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Organisation':
            obj_ = OrganisationType.factory()
            obj_.build(child_)
            self.Organisation.append(obj_)
            obj_.original_tagname_ = 'Organisation'
# end class OrganisationValuesType


class OrganisationType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ID=None, CountryID=None, DeltaAction=None, valueOf_=None):
        self.original_tagname_ = None
        self.ID = _cast(int, ID)
        self.CountryID = _cast(int, CountryID)
        self.DeltaAction = _cast(None, DeltaAction)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, OrganisationType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if OrganisationType.subclass:
            return OrganisationType.subclass(*args_, **kwargs_)
        else:
            return OrganisationType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ID(self): return self.ID
    def set_ID(self, ID): self.ID = ID
    def get_CountryID(self): return self.CountryID
    def set_CountryID(self, CountryID): self.CountryID = CountryID
    def get_DeltaAction(self): return self.DeltaAction
    def set_DeltaAction(self, DeltaAction): self.DeltaAction = DeltaAction
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_DeltaActionSchemaType(self, value):
        # Validate type DeltaActionSchemaType, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['add', 'amend', 'delete', 'revise']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on DeltaActionSchemaType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='un:', name_='OrganisationType', namespacedef_='xmlns:un="http://www.un.org/sanctions/1.0"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('OrganisationType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='OrganisationType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='un:', name_='OrganisationType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='un:', name_='OrganisationType'):
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            outfile.write(' ID="%s"' % self.gds_format_integer(self.ID, input_name='ID'))
        if self.CountryID is not None and 'CountryID' not in already_processed:
            already_processed.add('CountryID')
            outfile.write(' CountryID="%s"' % self.gds_format_integer(self.CountryID, input_name='CountryID'))
        if self.DeltaAction is not None and 'DeltaAction' not in already_processed:
            already_processed.add('DeltaAction')
            outfile.write(' DeltaAction=%s' % (quote_attrib(self.DeltaAction), ))
    def exportChildren(self, outfile, level, namespace_='un:', name_='OrganisationType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            try:
                self.ID = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.ID < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = find_attr_value_('CountryID', node)
        if value is not None and 'CountryID' not in already_processed:
            already_processed.add('CountryID')
            try:
                self.CountryID = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.CountryID < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = find_attr_value_('DeltaAction', node)
        if value is not None and 'DeltaAction' not in already_processed:
            already_processed.add('DeltaAction')
            self.DeltaAction = value
            self.validate_DeltaActionSchemaType(self.DeltaAction)    # validate type DeltaActionSchemaType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class OrganisationType


class PartySubTypeValuesType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, PartySubType=None):
        self.original_tagname_ = None
        if PartySubType is None:
            self.PartySubType = []
        else:
            self.PartySubType = PartySubType
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PartySubTypeValuesType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PartySubTypeValuesType.subclass:
            return PartySubTypeValuesType.subclass(*args_, **kwargs_)
        else:
            return PartySubTypeValuesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_PartySubType(self): return self.PartySubType
    def set_PartySubType(self, PartySubType): self.PartySubType = PartySubType
    def add_PartySubType(self, value): self.PartySubType.append(value)
    def insert_PartySubType_at(self, index, value): self.PartySubType.insert(index, value)
    def replace_PartySubType_at(self, index, value): self.PartySubType[index] = value
    def hasContent_(self):
        if (
            self.PartySubType
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='un:', name_='PartySubTypeValuesType', namespacedef_='xmlns:un="http://www.un.org/sanctions/1.0"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PartySubTypeValuesType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PartySubTypeValuesType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='un:', name_='PartySubTypeValuesType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='un:', name_='PartySubTypeValuesType'):
        pass
    def exportChildren(self, outfile, level, namespace_='un:', name_='PartySubTypeValuesType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for PartySubType_ in self.PartySubType:
            PartySubType_.export(outfile, level, namespace_, name_='PartySubType', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'PartySubType':
            obj_ = PartySubTypeType.factory()
            obj_.build(child_)
            self.PartySubType.append(obj_)
            obj_.original_tagname_ = 'PartySubType'
# end class PartySubTypeValuesType


class PartySubTypeType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ID=None, PartyTypeID=None, DeltaAction=None, valueOf_=None):
        self.original_tagname_ = None
        self.ID = _cast(int, ID)
        self.PartyTypeID = _cast(int, PartyTypeID)
        self.DeltaAction = _cast(None, DeltaAction)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PartySubTypeType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PartySubTypeType.subclass:
            return PartySubTypeType.subclass(*args_, **kwargs_)
        else:
            return PartySubTypeType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ID(self): return self.ID
    def set_ID(self, ID): self.ID = ID
    def get_PartyTypeID(self): return self.PartyTypeID
    def set_PartyTypeID(self, PartyTypeID): self.PartyTypeID = PartyTypeID
    def get_DeltaAction(self): return self.DeltaAction
    def set_DeltaAction(self, DeltaAction): self.DeltaAction = DeltaAction
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_DeltaActionSchemaType(self, value):
        # Validate type DeltaActionSchemaType, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['add', 'amend', 'delete', 'revise']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on DeltaActionSchemaType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='un:', name_='PartySubTypeType', namespacedef_='xmlns:un="http://www.un.org/sanctions/1.0"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PartySubTypeType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PartySubTypeType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='un:', name_='PartySubTypeType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='un:', name_='PartySubTypeType'):
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            outfile.write(' ID="%s"' % self.gds_format_integer(self.ID, input_name='ID'))
        if self.PartyTypeID is not None and 'PartyTypeID' not in already_processed:
            already_processed.add('PartyTypeID')
            outfile.write(' PartyTypeID="%s"' % self.gds_format_integer(self.PartyTypeID, input_name='PartyTypeID'))
        if self.DeltaAction is not None and 'DeltaAction' not in already_processed:
            already_processed.add('DeltaAction')
            outfile.write(' DeltaAction=%s' % (quote_attrib(self.DeltaAction), ))
    def exportChildren(self, outfile, level, namespace_='un:', name_='PartySubTypeType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            try:
                self.ID = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.ID < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = find_attr_value_('PartyTypeID', node)
        if value is not None and 'PartyTypeID' not in already_processed:
            already_processed.add('PartyTypeID')
            try:
                self.PartyTypeID = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.PartyTypeID < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = find_attr_value_('DeltaAction', node)
        if value is not None and 'DeltaAction' not in already_processed:
            already_processed.add('DeltaAction')
            self.DeltaAction = value
            self.validate_DeltaActionSchemaType(self.DeltaAction)    # validate type DeltaActionSchemaType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class PartySubTypeType


class PartyTypeValuesType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, PartyType=None):
        self.original_tagname_ = None
        if PartyType is None:
            self.PartyType = []
        else:
            self.PartyType = PartyType
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PartyTypeValuesType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PartyTypeValuesType.subclass:
            return PartyTypeValuesType.subclass(*args_, **kwargs_)
        else:
            return PartyTypeValuesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_PartyType(self): return self.PartyType
    def set_PartyType(self, PartyType): self.PartyType = PartyType
    def add_PartyType(self, value): self.PartyType.append(value)
    def insert_PartyType_at(self, index, value): self.PartyType.insert(index, value)
    def replace_PartyType_at(self, index, value): self.PartyType[index] = value
    def hasContent_(self):
        if (
            self.PartyType
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='un:', name_='PartyTypeValuesType', namespacedef_='xmlns:un="http://www.un.org/sanctions/1.0"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PartyTypeValuesType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PartyTypeValuesType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='un:', name_='PartyTypeValuesType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='un:', name_='PartyTypeValuesType'):
        pass
    def exportChildren(self, outfile, level, namespace_='un:', name_='PartyTypeValuesType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for PartyType_ in self.PartyType:
            PartyType_.export(outfile, level, namespace_, name_='PartyType', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'PartyType':
            obj_ = PartyTypeType.factory()
            obj_.build(child_)
            self.PartyType.append(obj_)
            obj_.original_tagname_ = 'PartyType'
# end class PartyTypeValuesType


class PartyTypeType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ID=None, DeltaAction=None, valueOf_=None):
        self.original_tagname_ = None
        self.ID = _cast(int, ID)
        self.DeltaAction = _cast(None, DeltaAction)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PartyTypeType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PartyTypeType.subclass:
            return PartyTypeType.subclass(*args_, **kwargs_)
        else:
            return PartyTypeType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ID(self): return self.ID
    def set_ID(self, ID): self.ID = ID
    def get_DeltaAction(self): return self.DeltaAction
    def set_DeltaAction(self, DeltaAction): self.DeltaAction = DeltaAction
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_DeltaActionSchemaType(self, value):
        # Validate type DeltaActionSchemaType, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['add', 'amend', 'delete', 'revise']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on DeltaActionSchemaType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='un:', name_='PartyTypeType', namespacedef_='xmlns:un="http://www.un.org/sanctions/1.0"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PartyTypeType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PartyTypeType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='un:', name_='PartyTypeType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='un:', name_='PartyTypeType'):
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            outfile.write(' ID="%s"' % self.gds_format_integer(self.ID, input_name='ID'))
        if self.DeltaAction is not None and 'DeltaAction' not in already_processed:
            already_processed.add('DeltaAction')
            outfile.write(' DeltaAction=%s' % (quote_attrib(self.DeltaAction), ))
    def exportChildren(self, outfile, level, namespace_='un:', name_='PartyTypeType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            try:
                self.ID = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.ID < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = find_attr_value_('DeltaAction', node)
        if value is not None and 'DeltaAction' not in already_processed:
            already_processed.add('DeltaAction')
            self.DeltaAction = value
            self.validate_DeltaActionSchemaType(self.DeltaAction)    # validate type DeltaActionSchemaType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class PartyTypeType


class RelationQualityValuesType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, RelationQuality=None):
        self.original_tagname_ = None
        if RelationQuality is None:
            self.RelationQuality = []
        else:
            self.RelationQuality = RelationQuality
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RelationQualityValuesType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RelationQualityValuesType.subclass:
            return RelationQualityValuesType.subclass(*args_, **kwargs_)
        else:
            return RelationQualityValuesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_RelationQuality(self): return self.RelationQuality
    def set_RelationQuality(self, RelationQuality): self.RelationQuality = RelationQuality
    def add_RelationQuality(self, value): self.RelationQuality.append(value)
    def insert_RelationQuality_at(self, index, value): self.RelationQuality.insert(index, value)
    def replace_RelationQuality_at(self, index, value): self.RelationQuality[index] = value
    def hasContent_(self):
        if (
            self.RelationQuality
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='un:', name_='RelationQualityValuesType', namespacedef_='xmlns:un="http://www.un.org/sanctions/1.0"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('RelationQualityValuesType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RelationQualityValuesType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='un:', name_='RelationQualityValuesType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='un:', name_='RelationQualityValuesType'):
        pass
    def exportChildren(self, outfile, level, namespace_='un:', name_='RelationQualityValuesType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for RelationQuality_ in self.RelationQuality:
            RelationQuality_.export(outfile, level, namespace_, name_='RelationQuality', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'RelationQuality':
            obj_ = RelationQualityType.factory()
            obj_.build(child_)
            self.RelationQuality.append(obj_)
            obj_.original_tagname_ = 'RelationQuality'
# end class RelationQualityValuesType


class RelationQualityType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ID=None, DeltaAction=None, valueOf_=None):
        self.original_tagname_ = None
        self.ID = _cast(int, ID)
        self.DeltaAction = _cast(None, DeltaAction)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RelationQualityType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RelationQualityType.subclass:
            return RelationQualityType.subclass(*args_, **kwargs_)
        else:
            return RelationQualityType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ID(self): return self.ID
    def set_ID(self, ID): self.ID = ID
    def get_DeltaAction(self): return self.DeltaAction
    def set_DeltaAction(self, DeltaAction): self.DeltaAction = DeltaAction
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_DeltaActionSchemaType(self, value):
        # Validate type DeltaActionSchemaType, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['add', 'amend', 'delete', 'revise']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on DeltaActionSchemaType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='un:', name_='RelationQualityType', namespacedef_='xmlns:un="http://www.un.org/sanctions/1.0"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('RelationQualityType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RelationQualityType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='un:', name_='RelationQualityType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='un:', name_='RelationQualityType'):
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            outfile.write(' ID="%s"' % self.gds_format_integer(self.ID, input_name='ID'))
        if self.DeltaAction is not None and 'DeltaAction' not in already_processed:
            already_processed.add('DeltaAction')
            outfile.write(' DeltaAction=%s' % (quote_attrib(self.DeltaAction), ))
    def exportChildren(self, outfile, level, namespace_='un:', name_='RelationQualityType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            try:
                self.ID = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.ID < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = find_attr_value_('DeltaAction', node)
        if value is not None and 'DeltaAction' not in already_processed:
            already_processed.add('DeltaAction')
            self.DeltaAction = value
            self.validate_DeltaActionSchemaType(self.DeltaAction)    # validate type DeltaActionSchemaType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class RelationQualityType


class RelationTypeValuesType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, RelationType=None):
        self.original_tagname_ = None
        if RelationType is None:
            self.RelationType = []
        else:
            self.RelationType = RelationType
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RelationTypeValuesType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RelationTypeValuesType.subclass:
            return RelationTypeValuesType.subclass(*args_, **kwargs_)
        else:
            return RelationTypeValuesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_RelationType(self): return self.RelationType
    def set_RelationType(self, RelationType): self.RelationType = RelationType
    def add_RelationType(self, value): self.RelationType.append(value)
    def insert_RelationType_at(self, index, value): self.RelationType.insert(index, value)
    def replace_RelationType_at(self, index, value): self.RelationType[index] = value
    def hasContent_(self):
        if (
            self.RelationType
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='un:', name_='RelationTypeValuesType', namespacedef_='xmlns:un="http://www.un.org/sanctions/1.0"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('RelationTypeValuesType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RelationTypeValuesType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='un:', name_='RelationTypeValuesType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='un:', name_='RelationTypeValuesType'):
        pass
    def exportChildren(self, outfile, level, namespace_='un:', name_='RelationTypeValuesType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for RelationType_ in self.RelationType:
            RelationType_.export(outfile, level, namespace_, name_='RelationType', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'RelationType':
            obj_ = RelationTypeType.factory()
            obj_.build(child_)
            self.RelationType.append(obj_)
            obj_.original_tagname_ = 'RelationType'
# end class RelationTypeValuesType


class RelationTypeType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ID=None, Symmetrical=None, DeltaAction=None, valueOf_=None):
        self.original_tagname_ = None
        self.ID = _cast(int, ID)
        self.Symmetrical = _cast(bool, Symmetrical)
        self.DeltaAction = _cast(None, DeltaAction)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RelationTypeType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RelationTypeType.subclass:
            return RelationTypeType.subclass(*args_, **kwargs_)
        else:
            return RelationTypeType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ID(self): return self.ID
    def set_ID(self, ID): self.ID = ID
    def get_Symmetrical(self): return self.Symmetrical
    def set_Symmetrical(self, Symmetrical): self.Symmetrical = Symmetrical
    def get_DeltaAction(self): return self.DeltaAction
    def set_DeltaAction(self, DeltaAction): self.DeltaAction = DeltaAction
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_DeltaActionSchemaType(self, value):
        # Validate type DeltaActionSchemaType, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['add', 'amend', 'delete', 'revise']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on DeltaActionSchemaType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='un:', name_='RelationTypeType', namespacedef_='xmlns:un="http://www.un.org/sanctions/1.0"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('RelationTypeType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RelationTypeType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='un:', name_='RelationTypeType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='un:', name_='RelationTypeType'):
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            outfile.write(' ID="%s"' % self.gds_format_integer(self.ID, input_name='ID'))
        if self.Symmetrical is not None and 'Symmetrical' not in already_processed:
            already_processed.add('Symmetrical')
            outfile.write(' Symmetrical="%s"' % self.gds_format_boolean(self.Symmetrical, input_name='Symmetrical'))
        if self.DeltaAction is not None and 'DeltaAction' not in already_processed:
            already_processed.add('DeltaAction')
            outfile.write(' DeltaAction=%s' % (quote_attrib(self.DeltaAction), ))
    def exportChildren(self, outfile, level, namespace_='un:', name_='RelationTypeType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            try:
                self.ID = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.ID < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = find_attr_value_('Symmetrical', node)
        if value is not None and 'Symmetrical' not in already_processed:
            already_processed.add('Symmetrical')
            if value in ('true', '1'):
                self.Symmetrical = True
            elif value in ('false', '0'):
                self.Symmetrical = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('DeltaAction', node)
        if value is not None and 'DeltaAction' not in already_processed:
            already_processed.add('DeltaAction')
            self.DeltaAction = value
            self.validate_DeltaActionSchemaType(self.DeltaAction)    # validate type DeltaActionSchemaType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class RelationTypeType


class ReliabilityValuesType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Reliability=None):
        self.original_tagname_ = None
        if Reliability is None:
            self.Reliability = []
        else:
            self.Reliability = Reliability
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ReliabilityValuesType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ReliabilityValuesType.subclass:
            return ReliabilityValuesType.subclass(*args_, **kwargs_)
        else:
            return ReliabilityValuesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Reliability(self): return self.Reliability
    def set_Reliability(self, Reliability): self.Reliability = Reliability
    def add_Reliability(self, value): self.Reliability.append(value)
    def insert_Reliability_at(self, index, value): self.Reliability.insert(index, value)
    def replace_Reliability_at(self, index, value): self.Reliability[index] = value
    def hasContent_(self):
        if (
            self.Reliability
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='un:', name_='ReliabilityValuesType', namespacedef_='xmlns:un="http://www.un.org/sanctions/1.0"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ReliabilityValuesType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ReliabilityValuesType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='un:', name_='ReliabilityValuesType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='un:', name_='ReliabilityValuesType'):
        pass
    def exportChildren(self, outfile, level, namespace_='un:', name_='ReliabilityValuesType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Reliability_ in self.Reliability:
            Reliability_.export(outfile, level, namespace_, name_='Reliability', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Reliability':
            obj_ = ReliabilityType.factory()
            obj_.build(child_)
            self.Reliability.append(obj_)
            obj_.original_tagname_ = 'Reliability'
# end class ReliabilityValuesType


class ReliabilityType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ID=None, DeltaAction=None, valueOf_=None):
        self.original_tagname_ = None
        self.ID = _cast(int, ID)
        self.DeltaAction = _cast(None, DeltaAction)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ReliabilityType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ReliabilityType.subclass:
            return ReliabilityType.subclass(*args_, **kwargs_)
        else:
            return ReliabilityType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ID(self): return self.ID
    def set_ID(self, ID): self.ID = ID
    def get_DeltaAction(self): return self.DeltaAction
    def set_DeltaAction(self, DeltaAction): self.DeltaAction = DeltaAction
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_DeltaActionSchemaType(self, value):
        # Validate type DeltaActionSchemaType, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['add', 'amend', 'delete', 'revise']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on DeltaActionSchemaType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='un:', name_='ReliabilityType', namespacedef_='xmlns:un="http://www.un.org/sanctions/1.0"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ReliabilityType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ReliabilityType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='un:', name_='ReliabilityType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='un:', name_='ReliabilityType'):
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            outfile.write(' ID="%s"' % self.gds_format_integer(self.ID, input_name='ID'))
        if self.DeltaAction is not None and 'DeltaAction' not in already_processed:
            already_processed.add('DeltaAction')
            outfile.write(' DeltaAction=%s' % (quote_attrib(self.DeltaAction), ))
    def exportChildren(self, outfile, level, namespace_='un:', name_='ReliabilityType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            try:
                self.ID = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.ID < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = find_attr_value_('DeltaAction', node)
        if value is not None and 'DeltaAction' not in already_processed:
            already_processed.add('DeltaAction')
            self.DeltaAction = value
            self.validate_DeltaActionSchemaType(self.DeltaAction)    # validate type DeltaActionSchemaType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ReliabilityType


class SanctionsProgramValuesType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, SanctionsProgram=None):
        self.original_tagname_ = None
        if SanctionsProgram is None:
            self.SanctionsProgram = []
        else:
            self.SanctionsProgram = SanctionsProgram
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SanctionsProgramValuesType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SanctionsProgramValuesType.subclass:
            return SanctionsProgramValuesType.subclass(*args_, **kwargs_)
        else:
            return SanctionsProgramValuesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_SanctionsProgram(self): return self.SanctionsProgram
    def set_SanctionsProgram(self, SanctionsProgram): self.SanctionsProgram = SanctionsProgram
    def add_SanctionsProgram(self, value): self.SanctionsProgram.append(value)
    def insert_SanctionsProgram_at(self, index, value): self.SanctionsProgram.insert(index, value)
    def replace_SanctionsProgram_at(self, index, value): self.SanctionsProgram[index] = value
    def hasContent_(self):
        if (
            self.SanctionsProgram
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='un:', name_='SanctionsProgramValuesType', namespacedef_='xmlns:un="http://www.un.org/sanctions/1.0"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SanctionsProgramValuesType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SanctionsProgramValuesType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='un:', name_='SanctionsProgramValuesType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='un:', name_='SanctionsProgramValuesType'):
        pass
    def exportChildren(self, outfile, level, namespace_='un:', name_='SanctionsProgramValuesType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for SanctionsProgram_ in self.SanctionsProgram:
            SanctionsProgram_.export(outfile, level, namespace_, name_='SanctionsProgram', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'SanctionsProgram':
            obj_ = SanctionsProgramType.factory()
            obj_.build(child_)
            self.SanctionsProgram.append(obj_)
            obj_.original_tagname_ = 'SanctionsProgram'
# end class SanctionsProgramValuesType


class SanctionsProgramType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ID=None, SubsidiaryBodyID=None, DeltaAction=None, valueOf_=None):
        self.original_tagname_ = None
        self.ID = _cast(int, ID)
        self.SubsidiaryBodyID = _cast(int, SubsidiaryBodyID)
        self.DeltaAction = _cast(None, DeltaAction)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SanctionsProgramType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SanctionsProgramType.subclass:
            return SanctionsProgramType.subclass(*args_, **kwargs_)
        else:
            return SanctionsProgramType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ID(self): return self.ID
    def set_ID(self, ID): self.ID = ID
    def get_SubsidiaryBodyID(self): return self.SubsidiaryBodyID
    def set_SubsidiaryBodyID(self, SubsidiaryBodyID): self.SubsidiaryBodyID = SubsidiaryBodyID
    def get_DeltaAction(self): return self.DeltaAction
    def set_DeltaAction(self, DeltaAction): self.DeltaAction = DeltaAction
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_DeltaActionSchemaType(self, value):
        # Validate type DeltaActionSchemaType, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['add', 'amend', 'delete', 'revise']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on DeltaActionSchemaType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='un:', name_='SanctionsProgramType', namespacedef_='xmlns:un="http://www.un.org/sanctions/1.0"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SanctionsProgramType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SanctionsProgramType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='un:', name_='SanctionsProgramType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='un:', name_='SanctionsProgramType'):
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            outfile.write(' ID="%s"' % self.gds_format_integer(self.ID, input_name='ID'))
        if self.SubsidiaryBodyID is not None and 'SubsidiaryBodyID' not in already_processed:
            already_processed.add('SubsidiaryBodyID')
            outfile.write(' SubsidiaryBodyID="%s"' % self.gds_format_integer(self.SubsidiaryBodyID, input_name='SubsidiaryBodyID'))
        if self.DeltaAction is not None and 'DeltaAction' not in already_processed:
            already_processed.add('DeltaAction')
            outfile.write(' DeltaAction=%s' % (quote_attrib(self.DeltaAction), ))
    def exportChildren(self, outfile, level, namespace_='un:', name_='SanctionsProgramType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            try:
                self.ID = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.ID < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = find_attr_value_('SubsidiaryBodyID', node)
        if value is not None and 'SubsidiaryBodyID' not in already_processed:
            already_processed.add('SubsidiaryBodyID')
            try:
                self.SubsidiaryBodyID = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.SubsidiaryBodyID < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = find_attr_value_('DeltaAction', node)
        if value is not None and 'DeltaAction' not in already_processed:
            already_processed.add('DeltaAction')
            self.DeltaAction = value
            self.validate_DeltaActionSchemaType(self.DeltaAction)    # validate type DeltaActionSchemaType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class SanctionsProgramType


class SanctionsTypeValuesType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, SanctionsType=None):
        self.original_tagname_ = None
        if SanctionsType is None:
            self.SanctionsType = []
        else:
            self.SanctionsType = SanctionsType
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SanctionsTypeValuesType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SanctionsTypeValuesType.subclass:
            return SanctionsTypeValuesType.subclass(*args_, **kwargs_)
        else:
            return SanctionsTypeValuesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_SanctionsType(self): return self.SanctionsType
    def set_SanctionsType(self, SanctionsType): self.SanctionsType = SanctionsType
    def add_SanctionsType(self, value): self.SanctionsType.append(value)
    def insert_SanctionsType_at(self, index, value): self.SanctionsType.insert(index, value)
    def replace_SanctionsType_at(self, index, value): self.SanctionsType[index] = value
    def hasContent_(self):
        if (
            self.SanctionsType
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='un:', name_='SanctionsTypeValuesType', namespacedef_='xmlns:un="http://www.un.org/sanctions/1.0"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SanctionsTypeValuesType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SanctionsTypeValuesType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='un:', name_='SanctionsTypeValuesType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='un:', name_='SanctionsTypeValuesType'):
        pass
    def exportChildren(self, outfile, level, namespace_='un:', name_='SanctionsTypeValuesType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for SanctionsType_ in self.SanctionsType:
            SanctionsType_.export(outfile, level, namespace_, name_='SanctionsType', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'SanctionsType':
            obj_ = SanctionsTypeType.factory()
            obj_.build(child_)
            self.SanctionsType.append(obj_)
            obj_.original_tagname_ = 'SanctionsType'
# end class SanctionsTypeValuesType


class SanctionsTypeType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ID=None, DeltaAction=None, valueOf_=None):
        self.original_tagname_ = None
        self.ID = _cast(int, ID)
        self.DeltaAction = _cast(None, DeltaAction)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SanctionsTypeType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SanctionsTypeType.subclass:
            return SanctionsTypeType.subclass(*args_, **kwargs_)
        else:
            return SanctionsTypeType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ID(self): return self.ID
    def set_ID(self, ID): self.ID = ID
    def get_DeltaAction(self): return self.DeltaAction
    def set_DeltaAction(self, DeltaAction): self.DeltaAction = DeltaAction
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_DeltaActionSchemaType(self, value):
        # Validate type DeltaActionSchemaType, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['add', 'amend', 'delete', 'revise']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on DeltaActionSchemaType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='un:', name_='SanctionsTypeType', namespacedef_='xmlns:un="http://www.un.org/sanctions/1.0"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SanctionsTypeType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SanctionsTypeType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='un:', name_='SanctionsTypeType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='un:', name_='SanctionsTypeType'):
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            outfile.write(' ID="%s"' % self.gds_format_integer(self.ID, input_name='ID'))
        if self.DeltaAction is not None and 'DeltaAction' not in already_processed:
            already_processed.add('DeltaAction')
            outfile.write(' DeltaAction=%s' % (quote_attrib(self.DeltaAction), ))
    def exportChildren(self, outfile, level, namespace_='un:', name_='SanctionsTypeType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            try:
                self.ID = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.ID < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = find_attr_value_('DeltaAction', node)
        if value is not None and 'DeltaAction' not in already_processed:
            already_processed.add('DeltaAction')
            self.DeltaAction = value
            self.validate_DeltaActionSchemaType(self.DeltaAction)    # validate type DeltaActionSchemaType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class SanctionsTypeType


class ScriptValuesType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Script=None):
        self.original_tagname_ = None
        if Script is None:
            self.Script = []
        else:
            self.Script = Script
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ScriptValuesType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ScriptValuesType.subclass:
            return ScriptValuesType.subclass(*args_, **kwargs_)
        else:
            return ScriptValuesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Script(self): return self.Script
    def set_Script(self, Script): self.Script = Script
    def add_Script(self, value): self.Script.append(value)
    def insert_Script_at(self, index, value): self.Script.insert(index, value)
    def replace_Script_at(self, index, value): self.Script[index] = value
    def hasContent_(self):
        if (
            self.Script
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='un:', name_='ScriptValuesType', namespacedef_='xmlns:un="http://www.un.org/sanctions/1.0"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ScriptValuesType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ScriptValuesType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='un:', name_='ScriptValuesType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='un:', name_='ScriptValuesType'):
        pass
    def exportChildren(self, outfile, level, namespace_='un:', name_='ScriptValuesType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Script_ in self.Script:
            Script_.export(outfile, level, namespace_, name_='Script', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Script':
            obj_ = ScriptType.factory()
            obj_.build(child_)
            self.Script.append(obj_)
            obj_.original_tagname_ = 'Script'
# end class ScriptValuesType


class ScriptType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ID=None, ScriptCode=None, DeltaAction=None, valueOf_=None):
        self.original_tagname_ = None
        self.ID = _cast(int, ID)
        self.ScriptCode = _cast(None, ScriptCode)
        self.DeltaAction = _cast(None, DeltaAction)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ScriptType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ScriptType.subclass:
            return ScriptType.subclass(*args_, **kwargs_)
        else:
            return ScriptType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ID(self): return self.ID
    def set_ID(self, ID): self.ID = ID
    def get_ScriptCode(self): return self.ScriptCode
    def set_ScriptCode(self, ScriptCode): self.ScriptCode = ScriptCode
    def get_DeltaAction(self): return self.DeltaAction
    def set_DeltaAction(self, DeltaAction): self.DeltaAction = DeltaAction
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_DeltaActionSchemaType(self, value):
        # Validate type DeltaActionSchemaType, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['add', 'amend', 'delete', 'revise']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on DeltaActionSchemaType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='un:', name_='ScriptType', namespacedef_='xmlns:un="http://www.un.org/sanctions/1.0"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ScriptType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ScriptType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='un:', name_='ScriptType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='un:', name_='ScriptType'):
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            outfile.write(' ID="%s"' % self.gds_format_integer(self.ID, input_name='ID'))
        if self.ScriptCode is not None and 'ScriptCode' not in already_processed:
            already_processed.add('ScriptCode')
            outfile.write(' ScriptCode=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.ScriptCode), input_name='ScriptCode')), ))
        if self.DeltaAction is not None and 'DeltaAction' not in already_processed:
            already_processed.add('DeltaAction')
            outfile.write(' DeltaAction=%s' % (quote_attrib(self.DeltaAction), ))
    def exportChildren(self, outfile, level, namespace_='un:', name_='ScriptType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            try:
                self.ID = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.ID < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = find_attr_value_('ScriptCode', node)
        if value is not None and 'ScriptCode' not in already_processed:
            already_processed.add('ScriptCode')
            self.ScriptCode = value
        value = find_attr_value_('DeltaAction', node)
        if value is not None and 'DeltaAction' not in already_processed:
            already_processed.add('DeltaAction')
            self.DeltaAction = value
            self.validate_DeltaActionSchemaType(self.DeltaAction)    # validate type DeltaActionSchemaType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ScriptType


class ScriptStatusValuesType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ScriptStatus=None):
        self.original_tagname_ = None
        if ScriptStatus is None:
            self.ScriptStatus = []
        else:
            self.ScriptStatus = ScriptStatus
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ScriptStatusValuesType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ScriptStatusValuesType.subclass:
            return ScriptStatusValuesType.subclass(*args_, **kwargs_)
        else:
            return ScriptStatusValuesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ScriptStatus(self): return self.ScriptStatus
    def set_ScriptStatus(self, ScriptStatus): self.ScriptStatus = ScriptStatus
    def add_ScriptStatus(self, value): self.ScriptStatus.append(value)
    def insert_ScriptStatus_at(self, index, value): self.ScriptStatus.insert(index, value)
    def replace_ScriptStatus_at(self, index, value): self.ScriptStatus[index] = value
    def hasContent_(self):
        if (
            self.ScriptStatus
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='un:', name_='ScriptStatusValuesType', namespacedef_='xmlns:un="http://www.un.org/sanctions/1.0"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ScriptStatusValuesType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ScriptStatusValuesType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='un:', name_='ScriptStatusValuesType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='un:', name_='ScriptStatusValuesType'):
        pass
    def exportChildren(self, outfile, level, namespace_='un:', name_='ScriptStatusValuesType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for ScriptStatus_ in self.ScriptStatus:
            ScriptStatus_.export(outfile, level, namespace_, name_='ScriptStatus', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ScriptStatus':
            obj_ = ScriptStatusType.factory()
            obj_.build(child_)
            self.ScriptStatus.append(obj_)
            obj_.original_tagname_ = 'ScriptStatus'
# end class ScriptStatusValuesType


class ScriptStatusType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ID=None, DeltaAction=None, valueOf_=None):
        self.original_tagname_ = None
        self.ID = _cast(int, ID)
        self.DeltaAction = _cast(None, DeltaAction)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ScriptStatusType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ScriptStatusType.subclass:
            return ScriptStatusType.subclass(*args_, **kwargs_)
        else:
            return ScriptStatusType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ID(self): return self.ID
    def set_ID(self, ID): self.ID = ID
    def get_DeltaAction(self): return self.DeltaAction
    def set_DeltaAction(self, DeltaAction): self.DeltaAction = DeltaAction
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_DeltaActionSchemaType(self, value):
        # Validate type DeltaActionSchemaType, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['add', 'amend', 'delete', 'revise']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on DeltaActionSchemaType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='un:', name_='ScriptStatusType', namespacedef_='xmlns:un="http://www.un.org/sanctions/1.0"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ScriptStatusType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ScriptStatusType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='un:', name_='ScriptStatusType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='un:', name_='ScriptStatusType'):
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            outfile.write(' ID="%s"' % self.gds_format_integer(self.ID, input_name='ID'))
        if self.DeltaAction is not None and 'DeltaAction' not in already_processed:
            already_processed.add('DeltaAction')
            outfile.write(' DeltaAction=%s' % (quote_attrib(self.DeltaAction), ))
    def exportChildren(self, outfile, level, namespace_='un:', name_='ScriptStatusType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            try:
                self.ID = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.ID < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = find_attr_value_('DeltaAction', node)
        if value is not None and 'DeltaAction' not in already_processed:
            already_processed.add('DeltaAction')
            self.DeltaAction = value
            self.validate_DeltaActionSchemaType(self.DeltaAction)    # validate type DeltaActionSchemaType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ScriptStatusType


class SubsidiaryBodyValuesType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, SubsidiaryBody=None):
        self.original_tagname_ = None
        if SubsidiaryBody is None:
            self.SubsidiaryBody = []
        else:
            self.SubsidiaryBody = SubsidiaryBody
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SubsidiaryBodyValuesType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SubsidiaryBodyValuesType.subclass:
            return SubsidiaryBodyValuesType.subclass(*args_, **kwargs_)
        else:
            return SubsidiaryBodyValuesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_SubsidiaryBody(self): return self.SubsidiaryBody
    def set_SubsidiaryBody(self, SubsidiaryBody): self.SubsidiaryBody = SubsidiaryBody
    def add_SubsidiaryBody(self, value): self.SubsidiaryBody.append(value)
    def insert_SubsidiaryBody_at(self, index, value): self.SubsidiaryBody.insert(index, value)
    def replace_SubsidiaryBody_at(self, index, value): self.SubsidiaryBody[index] = value
    def hasContent_(self):
        if (
            self.SubsidiaryBody
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='un:', name_='SubsidiaryBodyValuesType', namespacedef_='xmlns:un="http://www.un.org/sanctions/1.0"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SubsidiaryBodyValuesType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SubsidiaryBodyValuesType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='un:', name_='SubsidiaryBodyValuesType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='un:', name_='SubsidiaryBodyValuesType'):
        pass
    def exportChildren(self, outfile, level, namespace_='un:', name_='SubsidiaryBodyValuesType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for SubsidiaryBody_ in self.SubsidiaryBody:
            SubsidiaryBody_.export(outfile, level, namespace_, name_='SubsidiaryBody', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'SubsidiaryBody':
            obj_ = SubsidiaryBodyType.factory()
            obj_.build(child_)
            self.SubsidiaryBody.append(obj_)
            obj_.original_tagname_ = 'SubsidiaryBody'
# end class SubsidiaryBodyValuesType


class SubsidiaryBodyType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ID=None, Notional=None, DecisionMakingBodyID=None, DeltaAction=None, valueOf_=None):
        self.original_tagname_ = None
        self.ID = _cast(int, ID)
        self.Notional = _cast(bool, Notional)
        self.DecisionMakingBodyID = _cast(int, DecisionMakingBodyID)
        self.DeltaAction = _cast(None, DeltaAction)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SubsidiaryBodyType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SubsidiaryBodyType.subclass:
            return SubsidiaryBodyType.subclass(*args_, **kwargs_)
        else:
            return SubsidiaryBodyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ID(self): return self.ID
    def set_ID(self, ID): self.ID = ID
    def get_Notional(self): return self.Notional
    def set_Notional(self, Notional): self.Notional = Notional
    def get_DecisionMakingBodyID(self): return self.DecisionMakingBodyID
    def set_DecisionMakingBodyID(self, DecisionMakingBodyID): self.DecisionMakingBodyID = DecisionMakingBodyID
    def get_DeltaAction(self): return self.DeltaAction
    def set_DeltaAction(self, DeltaAction): self.DeltaAction = DeltaAction
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_DeltaActionSchemaType(self, value):
        # Validate type DeltaActionSchemaType, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['add', 'amend', 'delete', 'revise']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on DeltaActionSchemaType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='un:', name_='SubsidiaryBodyType', namespacedef_='xmlns:un="http://www.un.org/sanctions/1.0"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SubsidiaryBodyType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SubsidiaryBodyType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='un:', name_='SubsidiaryBodyType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='un:', name_='SubsidiaryBodyType'):
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            outfile.write(' ID="%s"' % self.gds_format_integer(self.ID, input_name='ID'))
        if self.Notional is not None and 'Notional' not in already_processed:
            already_processed.add('Notional')
            outfile.write(' Notional="%s"' % self.gds_format_boolean(self.Notional, input_name='Notional'))
        if self.DecisionMakingBodyID is not None and 'DecisionMakingBodyID' not in already_processed:
            already_processed.add('DecisionMakingBodyID')
            outfile.write(' DecisionMakingBodyID="%s"' % self.gds_format_integer(self.DecisionMakingBodyID, input_name='DecisionMakingBodyID'))
        if self.DeltaAction is not None and 'DeltaAction' not in already_processed:
            already_processed.add('DeltaAction')
            outfile.write(' DeltaAction=%s' % (quote_attrib(self.DeltaAction), ))
    def exportChildren(self, outfile, level, namespace_='un:', name_='SubsidiaryBodyType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            try:
                self.ID = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.ID < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = find_attr_value_('Notional', node)
        if value is not None and 'Notional' not in already_processed:
            already_processed.add('Notional')
            if value in ('true', '1'):
                self.Notional = True
            elif value in ('false', '0'):
                self.Notional = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('DecisionMakingBodyID', node)
        if value is not None and 'DecisionMakingBodyID' not in already_processed:
            already_processed.add('DecisionMakingBodyID')
            try:
                self.DecisionMakingBodyID = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.DecisionMakingBodyID < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = find_attr_value_('DeltaAction', node)
        if value is not None and 'DeltaAction' not in already_processed:
            already_processed.add('DeltaAction')
            self.DeltaAction = value
            self.validate_DeltaActionSchemaType(self.DeltaAction)    # validate type DeltaActionSchemaType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class SubsidiaryBodyType


class SupInfoTypeValuesType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, SupInfoType=None):
        self.original_tagname_ = None
        if SupInfoType is None:
            self.SupInfoType = []
        else:
            self.SupInfoType = SupInfoType
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SupInfoTypeValuesType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SupInfoTypeValuesType.subclass:
            return SupInfoTypeValuesType.subclass(*args_, **kwargs_)
        else:
            return SupInfoTypeValuesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_SupInfoType(self): return self.SupInfoType
    def set_SupInfoType(self, SupInfoType): self.SupInfoType = SupInfoType
    def add_SupInfoType(self, value): self.SupInfoType.append(value)
    def insert_SupInfoType_at(self, index, value): self.SupInfoType.insert(index, value)
    def replace_SupInfoType_at(self, index, value): self.SupInfoType[index] = value
    def hasContent_(self):
        if (
            self.SupInfoType
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='un:', name_='SupInfoTypeValuesType', namespacedef_='xmlns:un="http://www.un.org/sanctions/1.0"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SupInfoTypeValuesType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SupInfoTypeValuesType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='un:', name_='SupInfoTypeValuesType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='un:', name_='SupInfoTypeValuesType'):
        pass
    def exportChildren(self, outfile, level, namespace_='un:', name_='SupInfoTypeValuesType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for SupInfoType_ in self.SupInfoType:
            SupInfoType_.export(outfile, level, namespace_, name_='SupInfoType', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'SupInfoType':
            obj_ = SupInfoTypeType.factory()
            obj_.build(child_)
            self.SupInfoType.append(obj_)
            obj_.original_tagname_ = 'SupInfoType'
# end class SupInfoTypeValuesType


class SupInfoTypeType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ID=None, DeltaAction=None, valueOf_=None):
        self.original_tagname_ = None
        self.ID = _cast(int, ID)
        self.DeltaAction = _cast(None, DeltaAction)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SupInfoTypeType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SupInfoTypeType.subclass:
            return SupInfoTypeType.subclass(*args_, **kwargs_)
        else:
            return SupInfoTypeType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ID(self): return self.ID
    def set_ID(self, ID): self.ID = ID
    def get_DeltaAction(self): return self.DeltaAction
    def set_DeltaAction(self, DeltaAction): self.DeltaAction = DeltaAction
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_DeltaActionSchemaType(self, value):
        # Validate type DeltaActionSchemaType, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['add', 'amend', 'delete', 'revise']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on DeltaActionSchemaType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='un:', name_='SupInfoTypeType', namespacedef_='xmlns:un="http://www.un.org/sanctions/1.0"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SupInfoTypeType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SupInfoTypeType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='un:', name_='SupInfoTypeType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='un:', name_='SupInfoTypeType'):
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            outfile.write(' ID="%s"' % self.gds_format_integer(self.ID, input_name='ID'))
        if self.DeltaAction is not None and 'DeltaAction' not in already_processed:
            already_processed.add('DeltaAction')
            outfile.write(' DeltaAction=%s' % (quote_attrib(self.DeltaAction), ))
    def exportChildren(self, outfile, level, namespace_='un:', name_='SupInfoTypeType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            try:
                self.ID = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.ID < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = find_attr_value_('DeltaAction', node)
        if value is not None and 'DeltaAction' not in already_processed:
            already_processed.add('DeltaAction')
            self.DeltaAction = value
            self.validate_DeltaActionSchemaType(self.DeltaAction)    # validate type DeltaActionSchemaType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class SupInfoTypeType


class TargetTypeValuesType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, TargetType=None):
        self.original_tagname_ = None
        if TargetType is None:
            self.TargetType = []
        else:
            self.TargetType = TargetType
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TargetTypeValuesType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TargetTypeValuesType.subclass:
            return TargetTypeValuesType.subclass(*args_, **kwargs_)
        else:
            return TargetTypeValuesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_TargetType(self): return self.TargetType
    def set_TargetType(self, TargetType): self.TargetType = TargetType
    def add_TargetType(self, value): self.TargetType.append(value)
    def insert_TargetType_at(self, index, value): self.TargetType.insert(index, value)
    def replace_TargetType_at(self, index, value): self.TargetType[index] = value
    def hasContent_(self):
        if (
            self.TargetType
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='un:', name_='TargetTypeValuesType', namespacedef_='xmlns:un="http://www.un.org/sanctions/1.0"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TargetTypeValuesType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TargetTypeValuesType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='un:', name_='TargetTypeValuesType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='un:', name_='TargetTypeValuesType'):
        pass
    def exportChildren(self, outfile, level, namespace_='un:', name_='TargetTypeValuesType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for TargetType_ in self.TargetType:
            TargetType_.export(outfile, level, namespace_, name_='TargetType', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'TargetType':
            obj_ = TargetTypeType.factory()
            obj_.build(child_)
            self.TargetType.append(obj_)
            obj_.original_tagname_ = 'TargetType'
# end class TargetTypeValuesType


class TargetTypeType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ID=None, DeltaAction=None, valueOf_=None):
        self.original_tagname_ = None
        self.ID = _cast(int, ID)
        self.DeltaAction = _cast(None, DeltaAction)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TargetTypeType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TargetTypeType.subclass:
            return TargetTypeType.subclass(*args_, **kwargs_)
        else:
            return TargetTypeType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ID(self): return self.ID
    def set_ID(self, ID): self.ID = ID
    def get_DeltaAction(self): return self.DeltaAction
    def set_DeltaAction(self, DeltaAction): self.DeltaAction = DeltaAction
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_DeltaActionSchemaType(self, value):
        # Validate type DeltaActionSchemaType, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['add', 'amend', 'delete', 'revise']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on DeltaActionSchemaType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='un:', name_='TargetTypeType', namespacedef_='xmlns:un="http://www.un.org/sanctions/1.0"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TargetTypeType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TargetTypeType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='un:', name_='TargetTypeType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='un:', name_='TargetTypeType'):
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            outfile.write(' ID="%s"' % self.gds_format_integer(self.ID, input_name='ID'))
        if self.DeltaAction is not None and 'DeltaAction' not in already_processed:
            already_processed.add('DeltaAction')
            outfile.write(' DeltaAction=%s' % (quote_attrib(self.DeltaAction), ))
    def exportChildren(self, outfile, level, namespace_='un:', name_='TargetTypeType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            try:
                self.ID = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.ID < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = find_attr_value_('DeltaAction', node)
        if value is not None and 'DeltaAction' not in already_processed:
            already_processed.add('DeltaAction')
            self.DeltaAction = value
            self.validate_DeltaActionSchemaType(self.DeltaAction)    # validate type DeltaActionSchemaType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class TargetTypeType


class ValidityValuesType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Validity=None):
        self.original_tagname_ = None
        if Validity is None:
            self.Validity = []
        else:
            self.Validity = Validity
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ValidityValuesType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ValidityValuesType.subclass:
            return ValidityValuesType.subclass(*args_, **kwargs_)
        else:
            return ValidityValuesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Validity(self): return self.Validity
    def set_Validity(self, Validity): self.Validity = Validity
    def add_Validity(self, value): self.Validity.append(value)
    def insert_Validity_at(self, index, value): self.Validity.insert(index, value)
    def replace_Validity_at(self, index, value): self.Validity[index] = value
    def hasContent_(self):
        if (
            self.Validity
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='un:', name_='ValidityValuesType', namespacedef_='xmlns:un="http://www.un.org/sanctions/1.0"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ValidityValuesType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ValidityValuesType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='un:', name_='ValidityValuesType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='un:', name_='ValidityValuesType'):
        pass
    def exportChildren(self, outfile, level, namespace_='un:', name_='ValidityValuesType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Validity_ in self.Validity:
            Validity_.export(outfile, level, namespace_, name_='Validity', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Validity':
            obj_ = ValidityType.factory()
            obj_.build(child_)
            self.Validity.append(obj_)
            obj_.original_tagname_ = 'Validity'
# end class ValidityValuesType


class ValidityType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ID=None, DeltaAction=None, valueOf_=None):
        self.original_tagname_ = None
        self.ID = _cast(int, ID)
        self.DeltaAction = _cast(None, DeltaAction)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ValidityType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ValidityType.subclass:
            return ValidityType.subclass(*args_, **kwargs_)
        else:
            return ValidityType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ID(self): return self.ID
    def set_ID(self, ID): self.ID = ID
    def get_DeltaAction(self): return self.DeltaAction
    def set_DeltaAction(self, DeltaAction): self.DeltaAction = DeltaAction
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_DeltaActionSchemaType(self, value):
        # Validate type DeltaActionSchemaType, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['add', 'amend', 'delete', 'revise']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on DeltaActionSchemaType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='un:', name_='ValidityType', namespacedef_='xmlns:un="http://www.un.org/sanctions/1.0"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ValidityType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ValidityType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='un:', name_='ValidityType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='un:', name_='ValidityType'):
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            outfile.write(' ID="%s"' % self.gds_format_integer(self.ID, input_name='ID'))
        if self.DeltaAction is not None and 'DeltaAction' not in already_processed:
            already_processed.add('DeltaAction')
            outfile.write(' DeltaAction=%s' % (quote_attrib(self.DeltaAction), ))
    def exportChildren(self, outfile, level, namespace_='un:', name_='ValidityType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            try:
                self.ID = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.ID < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = find_attr_value_('DeltaAction', node)
        if value is not None and 'DeltaAction' not in already_processed:
            already_processed.add('DeltaAction')
            self.DeltaAction = value
            self.validate_DeltaActionSchemaType(self.DeltaAction)    # validate type DeltaActionSchemaType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ValidityType


class YearsType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, DeltaAction=None, valueOf_=None):
        self.original_tagname_ = None
        self.DeltaAction = _cast(None, DeltaAction)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, YearsType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if YearsType.subclass:
            return YearsType.subclass(*args_, **kwargs_)
        else:
            return YearsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_DeltaAction(self): return self.DeltaAction
    def set_DeltaAction(self, DeltaAction): self.DeltaAction = DeltaAction
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_DeltaActionSchemaType(self, value):
        # Validate type DeltaActionSchemaType, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['add', 'amend', 'delete', 'revise']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on DeltaActionSchemaType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='un:', name_='YearsType', namespacedef_='xmlns:un="http://www.un.org/sanctions/1.0"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('YearsType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='YearsType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='un:', name_='YearsType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='un:', name_='YearsType'):
        if self.DeltaAction is not None and 'DeltaAction' not in already_processed:
            already_processed.add('DeltaAction')
            outfile.write(' DeltaAction=%s' % (quote_attrib(self.DeltaAction), ))
    def exportChildren(self, outfile, level, namespace_='un:', name_='YearsType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('DeltaAction', node)
        if value is not None and 'DeltaAction' not in already_processed:
            already_processed.add('DeltaAction')
            self.DeltaAction = value
            self.validate_DeltaActionSchemaType(self.DeltaAction)    # validate type DeltaActionSchemaType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class YearsType


class MonthsType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, DeltaAction=None, valueOf_=None):
        self.original_tagname_ = None
        self.DeltaAction = _cast(None, DeltaAction)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MonthsType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MonthsType.subclass:
            return MonthsType.subclass(*args_, **kwargs_)
        else:
            return MonthsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_DeltaAction(self): return self.DeltaAction
    def set_DeltaAction(self, DeltaAction): self.DeltaAction = DeltaAction
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_DeltaActionSchemaType(self, value):
        # Validate type DeltaActionSchemaType, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['add', 'amend', 'delete', 'revise']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on DeltaActionSchemaType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='un:', name_='MonthsType', namespacedef_='xmlns:un="http://www.un.org/sanctions/1.0"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('MonthsType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MonthsType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='un:', name_='MonthsType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='un:', name_='MonthsType'):
        if self.DeltaAction is not None and 'DeltaAction' not in already_processed:
            already_processed.add('DeltaAction')
            outfile.write(' DeltaAction=%s' % (quote_attrib(self.DeltaAction), ))
    def exportChildren(self, outfile, level, namespace_='un:', name_='MonthsType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('DeltaAction', node)
        if value is not None and 'DeltaAction' not in already_processed:
            already_processed.add('DeltaAction')
            self.DeltaAction = value
            self.validate_DeltaActionSchemaType(self.DeltaAction)    # validate type DeltaActionSchemaType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class MonthsType


class DaysType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, DeltaAction=None, valueOf_=None):
        self.original_tagname_ = None
        self.DeltaAction = _cast(None, DeltaAction)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DaysType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DaysType.subclass:
            return DaysType.subclass(*args_, **kwargs_)
        else:
            return DaysType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_DeltaAction(self): return self.DeltaAction
    def set_DeltaAction(self, DeltaAction): self.DeltaAction = DeltaAction
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_DeltaActionSchemaType(self, value):
        # Validate type DeltaActionSchemaType, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['add', 'amend', 'delete', 'revise']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on DeltaActionSchemaType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='un:', name_='DaysType', namespacedef_='xmlns:un="http://www.un.org/sanctions/1.0"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DaysType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DaysType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='un:', name_='DaysType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='un:', name_='DaysType'):
        if self.DeltaAction is not None and 'DeltaAction' not in already_processed:
            already_processed.add('DeltaAction')
            outfile.write(' DeltaAction=%s' % (quote_attrib(self.DeltaAction), ))
    def exportChildren(self, outfile, level, namespace_='un:', name_='DaysType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('DeltaAction', node)
        if value is not None and 'DeltaAction' not in already_processed:
            already_processed.add('DeltaAction')
            self.DeltaAction = value
            self.validate_DeltaActionSchemaType(self.DeltaAction)    # validate type DeltaActionSchemaType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class DaysType


class LocationAreaCodeType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, AreaCodeID=None, DeltaAction=None):
        self.original_tagname_ = None
        self.AreaCodeID = _cast(int, AreaCodeID)
        self.DeltaAction = _cast(None, DeltaAction)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, LocationAreaCodeType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LocationAreaCodeType.subclass:
            return LocationAreaCodeType.subclass(*args_, **kwargs_)
        else:
            return LocationAreaCodeType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_AreaCodeID(self): return self.AreaCodeID
    def set_AreaCodeID(self, AreaCodeID): self.AreaCodeID = AreaCodeID
    def get_DeltaAction(self): return self.DeltaAction
    def set_DeltaAction(self, DeltaAction): self.DeltaAction = DeltaAction
    def validate_DeltaActionSchemaType(self, value):
        # Validate type DeltaActionSchemaType, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['add', 'amend', 'delete', 'revise']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on DeltaActionSchemaType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='un:', name_='LocationAreaCodeType', namespacedef_='xmlns:un="http://www.un.org/sanctions/1.0"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('LocationAreaCodeType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LocationAreaCodeType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='un:', name_='LocationAreaCodeType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='un:', name_='LocationAreaCodeType'):
        if self.AreaCodeID is not None and 'AreaCodeID' not in already_processed:
            already_processed.add('AreaCodeID')
            outfile.write(' AreaCodeID="%s"' % self.gds_format_integer(self.AreaCodeID, input_name='AreaCodeID'))
        if self.DeltaAction is not None and 'DeltaAction' not in already_processed:
            already_processed.add('DeltaAction')
            outfile.write(' DeltaAction=%s' % (quote_attrib(self.DeltaAction), ))
    def exportChildren(self, outfile, level, namespace_='un:', name_='LocationAreaCodeType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('AreaCodeID', node)
        if value is not None and 'AreaCodeID' not in already_processed:
            already_processed.add('AreaCodeID')
            try:
                self.AreaCodeID = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.AreaCodeID < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = find_attr_value_('DeltaAction', node)
        if value is not None and 'DeltaAction' not in already_processed:
            already_processed.add('DeltaAction')
            self.DeltaAction = value
            self.validate_DeltaActionSchemaType(self.DeltaAction)    # validate type DeltaActionSchemaType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class LocationAreaCodeType


class LocationCountryType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, CountryID=None, CountryRelevanceID=None, DeltaAction=None):
        self.original_tagname_ = None
        self.CountryID = _cast(int, CountryID)
        self.CountryRelevanceID = _cast(int, CountryRelevanceID)
        self.DeltaAction = _cast(None, DeltaAction)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, LocationCountryType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LocationCountryType.subclass:
            return LocationCountryType.subclass(*args_, **kwargs_)
        else:
            return LocationCountryType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_CountryID(self): return self.CountryID
    def set_CountryID(self, CountryID): self.CountryID = CountryID
    def get_CountryRelevanceID(self): return self.CountryRelevanceID
    def set_CountryRelevanceID(self, CountryRelevanceID): self.CountryRelevanceID = CountryRelevanceID
    def get_DeltaAction(self): return self.DeltaAction
    def set_DeltaAction(self, DeltaAction): self.DeltaAction = DeltaAction
    def validate_DeltaActionSchemaType(self, value):
        # Validate type DeltaActionSchemaType, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['add', 'amend', 'delete', 'revise']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on DeltaActionSchemaType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='un:', name_='LocationCountryType', namespacedef_='xmlns:un="http://www.un.org/sanctions/1.0"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('LocationCountryType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LocationCountryType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='un:', name_='LocationCountryType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='un:', name_='LocationCountryType'):
        if self.CountryID is not None and 'CountryID' not in already_processed:
            already_processed.add('CountryID')
            outfile.write(' CountryID="%s"' % self.gds_format_integer(self.CountryID, input_name='CountryID'))
        if self.CountryRelevanceID is not None and 'CountryRelevanceID' not in already_processed:
            already_processed.add('CountryRelevanceID')
            outfile.write(' CountryRelevanceID="%s"' % self.gds_format_integer(self.CountryRelevanceID, input_name='CountryRelevanceID'))
        if self.DeltaAction is not None and 'DeltaAction' not in already_processed:
            already_processed.add('DeltaAction')
            outfile.write(' DeltaAction=%s' % (quote_attrib(self.DeltaAction), ))
    def exportChildren(self, outfile, level, namespace_='un:', name_='LocationCountryType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('CountryID', node)
        if value is not None and 'CountryID' not in already_processed:
            already_processed.add('CountryID')
            try:
                self.CountryID = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.CountryID < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = find_attr_value_('CountryRelevanceID', node)
        if value is not None and 'CountryRelevanceID' not in already_processed:
            already_processed.add('CountryRelevanceID')
            try:
                self.CountryRelevanceID = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.CountryRelevanceID < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = find_attr_value_('DeltaAction', node)
        if value is not None and 'DeltaAction' not in already_processed:
            already_processed.add('DeltaAction')
            self.DeltaAction = value
            self.validate_DeltaActionSchemaType(self.DeltaAction)    # validate type DeltaActionSchemaType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class LocationCountryType


class LocationPartType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, LocPartTypeID=None, DeltaAction=None, LocationPartValue=None):
        self.original_tagname_ = None
        self.LocPartTypeID = _cast(int, LocPartTypeID)
        self.DeltaAction = _cast(None, DeltaAction)
        if LocationPartValue is None:
            self.LocationPartValue = []
        else:
            self.LocationPartValue = LocationPartValue
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, LocationPartType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LocationPartType.subclass:
            return LocationPartType.subclass(*args_, **kwargs_)
        else:
            return LocationPartType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_LocationPartValue(self): return self.LocationPartValue
    def set_LocationPartValue(self, LocationPartValue): self.LocationPartValue = LocationPartValue
    def add_LocationPartValue(self, value): self.LocationPartValue.append(value)
    def insert_LocationPartValue_at(self, index, value): self.LocationPartValue.insert(index, value)
    def replace_LocationPartValue_at(self, index, value): self.LocationPartValue[index] = value
    def get_LocPartTypeID(self): return self.LocPartTypeID
    def set_LocPartTypeID(self, LocPartTypeID): self.LocPartTypeID = LocPartTypeID
    def get_DeltaAction(self): return self.DeltaAction
    def set_DeltaAction(self, DeltaAction): self.DeltaAction = DeltaAction
    def validate_DeltaActionSchemaType(self, value):
        # Validate type DeltaActionSchemaType, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['add', 'amend', 'delete', 'revise']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on DeltaActionSchemaType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.LocationPartValue
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='un:', name_='LocationPartType', namespacedef_='xmlns:un="http://www.un.org/sanctions/1.0"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('LocationPartType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LocationPartType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='un:', name_='LocationPartType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='un:', name_='LocationPartType'):
        if self.LocPartTypeID is not None and 'LocPartTypeID' not in already_processed:
            already_processed.add('LocPartTypeID')
            outfile.write(' LocPartTypeID="%s"' % self.gds_format_integer(self.LocPartTypeID, input_name='LocPartTypeID'))
        if self.DeltaAction is not None and 'DeltaAction' not in already_processed:
            already_processed.add('DeltaAction')
            outfile.write(' DeltaAction=%s' % (quote_attrib(self.DeltaAction), ))
    def exportChildren(self, outfile, level, namespace_='un:', name_='LocationPartType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for LocationPartValue_ in self.LocationPartValue:
            LocationPartValue_.export(outfile, level, namespace_, name_='LocationPartValue', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('LocPartTypeID', node)
        if value is not None and 'LocPartTypeID' not in already_processed:
            already_processed.add('LocPartTypeID')
            try:
                self.LocPartTypeID = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.LocPartTypeID < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = find_attr_value_('DeltaAction', node)
        if value is not None and 'DeltaAction' not in already_processed:
            already_processed.add('DeltaAction')
            self.DeltaAction = value
            self.validate_DeltaActionSchemaType(self.DeltaAction)    # validate type DeltaActionSchemaType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'LocationPartValue':
            obj_ = LocationPartValueType.factory()
            obj_.build(child_)
            self.LocationPartValue.append(obj_)
            obj_.original_tagname_ = 'LocationPartValue'
# end class LocationPartType


class LocationPartValueType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Primary=None, LocPartValueTypeID=None, LocPartValueStatusID=None, DeltaAction=None, Comment=None, Value=None):
        self.original_tagname_ = None
        self.Primary = _cast(bool, Primary)
        self.LocPartValueTypeID = _cast(int, LocPartValueTypeID)
        self.LocPartValueStatusID = _cast(int, LocPartValueStatusID)
        self.DeltaAction = _cast(None, DeltaAction)
        self.Comment = Comment
        self.Value = Value
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, LocationPartValueType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LocationPartValueType.subclass:
            return LocationPartValueType.subclass(*args_, **kwargs_)
        else:
            return LocationPartValueType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Comment(self): return self.Comment
    def set_Comment(self, Comment): self.Comment = Comment
    def get_Value(self): return self.Value
    def set_Value(self, Value): self.Value = Value
    def get_Primary(self): return self.Primary
    def set_Primary(self, Primary): self.Primary = Primary
    def get_LocPartValueTypeID(self): return self.LocPartValueTypeID
    def set_LocPartValueTypeID(self, LocPartValueTypeID): self.LocPartValueTypeID = LocPartValueTypeID
    def get_LocPartValueStatusID(self): return self.LocPartValueStatusID
    def set_LocPartValueStatusID(self, LocPartValueStatusID): self.LocPartValueStatusID = LocPartValueStatusID
    def get_DeltaAction(self): return self.DeltaAction
    def set_DeltaAction(self, DeltaAction): self.DeltaAction = DeltaAction
    def validate_DeltaActionSchemaType(self, value):
        # Validate type DeltaActionSchemaType, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['add', 'amend', 'delete', 'revise']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on DeltaActionSchemaType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.Comment is not None or
            self.Value is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='un:', name_='LocationPartValueType', namespacedef_='xmlns:un="http://www.un.org/sanctions/1.0"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('LocationPartValueType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LocationPartValueType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='un:', name_='LocationPartValueType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='un:', name_='LocationPartValueType'):
        if self.Primary is not None and 'Primary' not in already_processed:
            already_processed.add('Primary')
            outfile.write(' Primary="%s"' % self.gds_format_boolean(self.Primary, input_name='Primary'))
        if self.LocPartValueTypeID is not None and 'LocPartValueTypeID' not in already_processed:
            already_processed.add('LocPartValueTypeID')
            outfile.write(' LocPartValueTypeID="%s"' % self.gds_format_integer(self.LocPartValueTypeID, input_name='LocPartValueTypeID'))
        if self.LocPartValueStatusID is not None and 'LocPartValueStatusID' not in already_processed:
            already_processed.add('LocPartValueStatusID')
            outfile.write(' LocPartValueStatusID="%s"' % self.gds_format_integer(self.LocPartValueStatusID, input_name='LocPartValueStatusID'))
        if self.DeltaAction is not None and 'DeltaAction' not in already_processed:
            already_processed.add('DeltaAction')
            outfile.write(' DeltaAction=%s' % (quote_attrib(self.DeltaAction), ))
    def exportChildren(self, outfile, level, namespace_='un:', name_='LocationPartValueType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Comment is not None:
            self.Comment.export(outfile, level, namespace_, name_='Comment', pretty_print=pretty_print)
        if self.Value is not None:
            self.Value.export(outfile, level, namespace_, name_='Value', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Primary', node)
        if value is not None and 'Primary' not in already_processed:
            already_processed.add('Primary')
            if value in ('true', '1'):
                self.Primary = True
            elif value in ('false', '0'):
                self.Primary = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('LocPartValueTypeID', node)
        if value is not None and 'LocPartValueTypeID' not in already_processed:
            already_processed.add('LocPartValueTypeID')
            try:
                self.LocPartValueTypeID = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.LocPartValueTypeID < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = find_attr_value_('LocPartValueStatusID', node)
        if value is not None and 'LocPartValueStatusID' not in already_processed:
            already_processed.add('LocPartValueStatusID')
            try:
                self.LocPartValueStatusID = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.LocPartValueStatusID < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = find_attr_value_('DeltaAction', node)
        if value is not None and 'DeltaAction' not in already_processed:
            already_processed.add('DeltaAction')
            self.DeltaAction = value
            self.validate_DeltaActionSchemaType(self.DeltaAction)    # validate type DeltaActionSchemaType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Comment':
            obj_ = Comment.factory()
            obj_.build(child_)
            self.Comment = obj_
            obj_.original_tagname_ = 'Comment'
        elif nodeName_ == 'Value':
            obj_ = ValueType.factory()
            obj_.build(child_)
            self.Value = obj_
            obj_.original_tagname_ = 'Value'
# end class LocationPartValueType


class ValueType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, DeltaAction=None, valueOf_=None):
        self.original_tagname_ = None
        self.DeltaAction = _cast(None, DeltaAction)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ValueType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ValueType.subclass:
            return ValueType.subclass(*args_, **kwargs_)
        else:
            return ValueType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_DeltaAction(self): return self.DeltaAction
    def set_DeltaAction(self, DeltaAction): self.DeltaAction = DeltaAction
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_DeltaActionSchemaType(self, value):
        # Validate type DeltaActionSchemaType, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['add', 'amend', 'delete', 'revise']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on DeltaActionSchemaType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='un:', name_='ValueType', namespacedef_='xmlns:un="http://www.un.org/sanctions/1.0"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ValueType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ValueType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='un:', name_='ValueType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='un:', name_='ValueType'):
        if self.DeltaAction is not None and 'DeltaAction' not in already_processed:
            already_processed.add('DeltaAction')
            outfile.write(' DeltaAction=%s' % (quote_attrib(self.DeltaAction), ))
    def exportChildren(self, outfile, level, namespace_='un:', name_='ValueType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('DeltaAction', node)
        if value is not None and 'DeltaAction' not in already_processed:
            already_processed.add('DeltaAction')
            self.DeltaAction = value
            self.validate_DeltaActionSchemaType(self.DeltaAction)    # validate type DeltaActionSchemaType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ValueType


class IDRegistrationNoType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, DeltaAction=None, valueOf_=None):
        self.original_tagname_ = None
        self.DeltaAction = _cast(None, DeltaAction)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, IDRegistrationNoType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if IDRegistrationNoType.subclass:
            return IDRegistrationNoType.subclass(*args_, **kwargs_)
        else:
            return IDRegistrationNoType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_DeltaAction(self): return self.DeltaAction
    def set_DeltaAction(self, DeltaAction): self.DeltaAction = DeltaAction
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_DeltaActionSchemaType(self, value):
        # Validate type DeltaActionSchemaType, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['add', 'amend', 'delete', 'revise']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on DeltaActionSchemaType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='un:', name_='IDRegistrationNoType', namespacedef_='xmlns:un="http://www.un.org/sanctions/1.0"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('IDRegistrationNoType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='IDRegistrationNoType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='un:', name_='IDRegistrationNoType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='un:', name_='IDRegistrationNoType'):
        if self.DeltaAction is not None and 'DeltaAction' not in already_processed:
            already_processed.add('DeltaAction')
            outfile.write(' DeltaAction=%s' % (quote_attrib(self.DeltaAction), ))
    def exportChildren(self, outfile, level, namespace_='un:', name_='IDRegistrationNoType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('DeltaAction', node)
        if value is not None and 'DeltaAction' not in already_processed:
            already_processed.add('DeltaAction')
            self.DeltaAction = value
            self.validate_DeltaActionSchemaType(self.DeltaAction)    # validate type DeltaActionSchemaType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class IDRegistrationNoType


class IssuingAuthorityType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, DeltaAction=None, valueOf_=None):
        self.original_tagname_ = None
        self.DeltaAction = _cast(None, DeltaAction)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, IssuingAuthorityType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if IssuingAuthorityType.subclass:
            return IssuingAuthorityType.subclass(*args_, **kwargs_)
        else:
            return IssuingAuthorityType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_DeltaAction(self): return self.DeltaAction
    def set_DeltaAction(self, DeltaAction): self.DeltaAction = DeltaAction
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_DeltaActionSchemaType(self, value):
        # Validate type DeltaActionSchemaType, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['add', 'amend', 'delete', 'revise']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on DeltaActionSchemaType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='un:', name_='IssuingAuthorityType', namespacedef_='xmlns:un="http://www.un.org/sanctions/1.0"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('IssuingAuthorityType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='IssuingAuthorityType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='un:', name_='IssuingAuthorityType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='un:', name_='IssuingAuthorityType'):
        if self.DeltaAction is not None and 'DeltaAction' not in already_processed:
            already_processed.add('DeltaAction')
            outfile.write(' DeltaAction=%s' % (quote_attrib(self.DeltaAction), ))
    def exportChildren(self, outfile, level, namespace_='un:', name_='IssuingAuthorityType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('DeltaAction', node)
        if value is not None and 'DeltaAction' not in already_processed:
            already_processed.add('DeltaAction')
            self.DeltaAction = value
            self.validate_DeltaActionSchemaType(self.DeltaAction)    # validate type DeltaActionSchemaType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class IssuingAuthorityType


class DocumentDateType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, IDRegDocDateTypeID=None, DeltaAction=None, DatePeriod=None):
        self.original_tagname_ = None
        self.IDRegDocDateTypeID = _cast(int, IDRegDocDateTypeID)
        self.DeltaAction = _cast(None, DeltaAction)
        self.DatePeriod = DatePeriod
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DocumentDateType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DocumentDateType.subclass:
            return DocumentDateType.subclass(*args_, **kwargs_)
        else:
            return DocumentDateType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_DatePeriod(self): return self.DatePeriod
    def set_DatePeriod(self, DatePeriod): self.DatePeriod = DatePeriod
    def get_IDRegDocDateTypeID(self): return self.IDRegDocDateTypeID
    def set_IDRegDocDateTypeID(self, IDRegDocDateTypeID): self.IDRegDocDateTypeID = IDRegDocDateTypeID
    def get_DeltaAction(self): return self.DeltaAction
    def set_DeltaAction(self, DeltaAction): self.DeltaAction = DeltaAction
    def validate_DeltaActionSchemaType(self, value):
        # Validate type DeltaActionSchemaType, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['add', 'amend', 'delete', 'revise']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on DeltaActionSchemaType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.DatePeriod is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='un:', name_='DocumentDateType', namespacedef_='xmlns:un="http://www.un.org/sanctions/1.0"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DocumentDateType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DocumentDateType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='un:', name_='DocumentDateType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='un:', name_='DocumentDateType'):
        if self.IDRegDocDateTypeID is not None and 'IDRegDocDateTypeID' not in already_processed:
            already_processed.add('IDRegDocDateTypeID')
            outfile.write(' IDRegDocDateTypeID="%s"' % self.gds_format_integer(self.IDRegDocDateTypeID, input_name='IDRegDocDateTypeID'))
        if self.DeltaAction is not None and 'DeltaAction' not in already_processed:
            already_processed.add('DeltaAction')
            outfile.write(' DeltaAction=%s' % (quote_attrib(self.DeltaAction), ))
    def exportChildren(self, outfile, level, namespace_='un:', name_='DocumentDateType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.DatePeriod is not None:
            self.DatePeriod.export(outfile, level, namespace_, name_='DatePeriod', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('IDRegDocDateTypeID', node)
        if value is not None and 'IDRegDocDateTypeID' not in already_processed:
            already_processed.add('IDRegDocDateTypeID')
            try:
                self.IDRegDocDateTypeID = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.IDRegDocDateTypeID < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = find_attr_value_('DeltaAction', node)
        if value is not None and 'DeltaAction' not in already_processed:
            already_processed.add('DeltaAction')
            self.DeltaAction = value
            self.validate_DeltaActionSchemaType(self.DeltaAction)    # validate type DeltaActionSchemaType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'DatePeriod':
            obj_ = DatePeriod.factory()
            obj_.build(child_)
            self.DatePeriod = obj_
            obj_.original_tagname_ = 'DatePeriod'
# end class DocumentDateType


class IDRegDocumentMentionType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, IDRegDocumentID=None, ReferenceType=None, DeltaAction=None):
        self.original_tagname_ = None
        self.IDRegDocumentID = _cast(int, IDRegDocumentID)
        self.ReferenceType = _cast(None, ReferenceType)
        self.DeltaAction = _cast(None, DeltaAction)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, IDRegDocumentMentionType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if IDRegDocumentMentionType.subclass:
            return IDRegDocumentMentionType.subclass(*args_, **kwargs_)
        else:
            return IDRegDocumentMentionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_IDRegDocumentID(self): return self.IDRegDocumentID
    def set_IDRegDocumentID(self, IDRegDocumentID): self.IDRegDocumentID = IDRegDocumentID
    def get_ReferenceType(self): return self.ReferenceType
    def set_ReferenceType(self, ReferenceType): self.ReferenceType = ReferenceType
    def get_DeltaAction(self): return self.DeltaAction
    def set_DeltaAction(self, DeltaAction): self.DeltaAction = DeltaAction
    def validate_ReferenceSchemaType(self, value):
        # Validate type ReferenceSchemaType, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['RefersTo', 'ReferencedBy']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on ReferenceSchemaType' % {"value" : value.encode("utf-8")} )
    def validate_DeltaActionSchemaType(self, value):
        # Validate type DeltaActionSchemaType, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['add', 'amend', 'delete', 'revise']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on DeltaActionSchemaType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='un:', name_='IDRegDocumentMentionType', namespacedef_='xmlns:un="http://www.un.org/sanctions/1.0"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('IDRegDocumentMentionType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='IDRegDocumentMentionType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='un:', name_='IDRegDocumentMentionType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='un:', name_='IDRegDocumentMentionType'):
        if self.IDRegDocumentID is not None and 'IDRegDocumentID' not in already_processed:
            already_processed.add('IDRegDocumentID')
            outfile.write(' IDRegDocumentID="%s"' % self.gds_format_integer(self.IDRegDocumentID, input_name='IDRegDocumentID'))
        if self.ReferenceType is not None and 'ReferenceType' not in already_processed:
            already_processed.add('ReferenceType')
            outfile.write(' ReferenceType=%s' % (quote_attrib(self.ReferenceType), ))
        if self.DeltaAction is not None and 'DeltaAction' not in already_processed:
            already_processed.add('DeltaAction')
            outfile.write(' DeltaAction=%s' % (quote_attrib(self.DeltaAction), ))
    def exportChildren(self, outfile, level, namespace_='un:', name_='IDRegDocumentMentionType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('IDRegDocumentID', node)
        if value is not None and 'IDRegDocumentID' not in already_processed:
            already_processed.add('IDRegDocumentID')
            try:
                self.IDRegDocumentID = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.IDRegDocumentID < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = find_attr_value_('ReferenceType', node)
        if value is not None and 'ReferenceType' not in already_processed:
            already_processed.add('ReferenceType')
            self.ReferenceType = value
            self.validate_ReferenceSchemaType(self.ReferenceType)    # validate type ReferenceSchemaType
        value = find_attr_value_('DeltaAction', node)
        if value is not None and 'DeltaAction' not in already_processed:
            already_processed.add('DeltaAction')
            self.DeltaAction = value
            self.validate_DeltaActionSchemaType(self.DeltaAction)    # validate type DeltaActionSchemaType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class IDRegDocumentMentionType


class DocumentedNameReferenceType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, DocumentedNameID=None, DeltaAction=None):
        self.original_tagname_ = None
        self.DocumentedNameID = _cast(int, DocumentedNameID)
        self.DeltaAction = _cast(None, DeltaAction)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DocumentedNameReferenceType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DocumentedNameReferenceType.subclass:
            return DocumentedNameReferenceType.subclass(*args_, **kwargs_)
        else:
            return DocumentedNameReferenceType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_DocumentedNameID(self): return self.DocumentedNameID
    def set_DocumentedNameID(self, DocumentedNameID): self.DocumentedNameID = DocumentedNameID
    def get_DeltaAction(self): return self.DeltaAction
    def set_DeltaAction(self, DeltaAction): self.DeltaAction = DeltaAction
    def validate_DeltaActionSchemaType(self, value):
        # Validate type DeltaActionSchemaType, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['add', 'amend', 'delete', 'revise']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on DeltaActionSchemaType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='un:', name_='DocumentedNameReferenceType', namespacedef_='xmlns:un="http://www.un.org/sanctions/1.0"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DocumentedNameReferenceType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DocumentedNameReferenceType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='un:', name_='DocumentedNameReferenceType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='un:', name_='DocumentedNameReferenceType'):
        if self.DocumentedNameID is not None and 'DocumentedNameID' not in already_processed:
            already_processed.add('DocumentedNameID')
            outfile.write(' DocumentedNameID="%s"' % self.gds_format_integer(self.DocumentedNameID, input_name='DocumentedNameID'))
        if self.DeltaAction is not None and 'DeltaAction' not in already_processed:
            already_processed.add('DeltaAction')
            outfile.write(' DeltaAction=%s' % (quote_attrib(self.DeltaAction), ))
    def exportChildren(self, outfile, level, namespace_='un:', name_='DocumentedNameReferenceType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('DocumentedNameID', node)
        if value is not None and 'DocumentedNameID' not in already_processed:
            already_processed.add('DocumentedNameID')
            try:
                self.DocumentedNameID = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.DocumentedNameID < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = find_attr_value_('DeltaAction', node)
        if value is not None and 'DeltaAction' not in already_processed:
            already_processed.add('DeltaAction')
            self.DeltaAction = value
            self.validate_DeltaActionSchemaType(self.DeltaAction)    # validate type DeltaActionSchemaType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class DocumentedNameReferenceType


class ProfileType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ID=None, PartySubTypeID=None, DeltaAction=None, Comment=None, Identity=None, Feature=None, SanctionsEntryReference=None, ExternalReference=None):
        self.original_tagname_ = None
        self.ID = _cast(int, ID)
        self.PartySubTypeID = _cast(int, PartySubTypeID)
        self.DeltaAction = _cast(None, DeltaAction)
        if Comment is None:
            self.Comment = []
        else:
            self.Comment = Comment
        if Identity is None:
            self.Identity = []
        else:
            self.Identity = Identity
        if Feature is None:
            self.Feature = []
        else:
            self.Feature = Feature
        if SanctionsEntryReference is None:
            self.SanctionsEntryReference = []
        else:
            self.SanctionsEntryReference = SanctionsEntryReference
        if ExternalReference is None:
            self.ExternalReference = []
        else:
            self.ExternalReference = ExternalReference
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ProfileType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ProfileType.subclass:
            return ProfileType.subclass(*args_, **kwargs_)
        else:
            return ProfileType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Comment(self): return self.Comment
    def set_Comment(self, Comment): self.Comment = Comment
    def add_Comment(self, value): self.Comment.append(value)
    def insert_Comment_at(self, index, value): self.Comment.insert(index, value)
    def replace_Comment_at(self, index, value): self.Comment[index] = value
    def get_Identity(self): return self.Identity
    def set_Identity(self, Identity): self.Identity = Identity
    def add_Identity(self, value): self.Identity.append(value)
    def insert_Identity_at(self, index, value): self.Identity.insert(index, value)
    def replace_Identity_at(self, index, value): self.Identity[index] = value
    def get_Feature(self): return self.Feature
    def set_Feature(self, Feature): self.Feature = Feature
    def add_Feature(self, value): self.Feature.append(value)
    def insert_Feature_at(self, index, value): self.Feature.insert(index, value)
    def replace_Feature_at(self, index, value): self.Feature[index] = value
    def get_SanctionsEntryReference(self): return self.SanctionsEntryReference
    def set_SanctionsEntryReference(self, SanctionsEntryReference): self.SanctionsEntryReference = SanctionsEntryReference
    def add_SanctionsEntryReference(self, value): self.SanctionsEntryReference.append(value)
    def insert_SanctionsEntryReference_at(self, index, value): self.SanctionsEntryReference.insert(index, value)
    def replace_SanctionsEntryReference_at(self, index, value): self.SanctionsEntryReference[index] = value
    def get_ExternalReference(self): return self.ExternalReference
    def set_ExternalReference(self, ExternalReference): self.ExternalReference = ExternalReference
    def add_ExternalReference(self, value): self.ExternalReference.append(value)
    def insert_ExternalReference_at(self, index, value): self.ExternalReference.insert(index, value)
    def replace_ExternalReference_at(self, index, value): self.ExternalReference[index] = value
    def get_ID(self): return self.ID
    def set_ID(self, ID): self.ID = ID
    def get_PartySubTypeID(self): return self.PartySubTypeID
    def set_PartySubTypeID(self, PartySubTypeID): self.PartySubTypeID = PartySubTypeID
    def get_DeltaAction(self): return self.DeltaAction
    def set_DeltaAction(self, DeltaAction): self.DeltaAction = DeltaAction
    def validate_DeltaActionSchemaType(self, value):
        # Validate type DeltaActionSchemaType, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['add', 'amend', 'delete', 'revise']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on DeltaActionSchemaType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.Comment or
            self.Identity or
            self.Feature or
            self.SanctionsEntryReference or
            self.ExternalReference
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='un:', name_='ProfileType', namespacedef_='xmlns:un="http://www.un.org/sanctions/1.0"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ProfileType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ProfileType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='un:', name_='ProfileType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='un:', name_='ProfileType'):
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            outfile.write(' ID="%s"' % self.gds_format_integer(self.ID, input_name='ID'))
        if self.PartySubTypeID is not None and 'PartySubTypeID' not in already_processed:
            already_processed.add('PartySubTypeID')
            outfile.write(' PartySubTypeID="%s"' % self.gds_format_integer(self.PartySubTypeID, input_name='PartySubTypeID'))
        if self.DeltaAction is not None and 'DeltaAction' not in already_processed:
            already_processed.add('DeltaAction')
            outfile.write(' DeltaAction=%s' % (quote_attrib(self.DeltaAction), ))
    def exportChildren(self, outfile, level, namespace_='un:', name_='ProfileType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Comment_ in self.Comment:
            Comment_.export(outfile, level, namespace_, name_='Comment', pretty_print=pretty_print)
        for Identity_ in self.Identity:
            Identity_.export(outfile, level, namespace_, name_='Identity', pretty_print=pretty_print)
        for Feature_ in self.Feature:
            Feature_.export(outfile, level, namespace_, name_='Feature', pretty_print=pretty_print)
        for SanctionsEntryReference_ in self.SanctionsEntryReference:
            SanctionsEntryReference_.export(outfile, level, namespace_, name_='SanctionsEntryReference', pretty_print=pretty_print)
        for ExternalReference_ in self.ExternalReference:
            ExternalReference_.export(outfile, level, namespace_, name_='ExternalReference', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            try:
                self.ID = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.ID < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = find_attr_value_('PartySubTypeID', node)
        if value is not None and 'PartySubTypeID' not in already_processed:
            already_processed.add('PartySubTypeID')
            try:
                self.PartySubTypeID = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.PartySubTypeID < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = find_attr_value_('DeltaAction', node)
        if value is not None and 'DeltaAction' not in already_processed:
            already_processed.add('DeltaAction')
            self.DeltaAction = value
            self.validate_DeltaActionSchemaType(self.DeltaAction)    # validate type DeltaActionSchemaType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Comment':
            obj_ = Comment.factory()
            obj_.build(child_)
            self.Comment.append(obj_)
            obj_.original_tagname_ = 'Comment'
        elif nodeName_ == 'Identity':
            obj_ = IdentitySchemaType.factory()
            obj_.build(child_)
            self.Identity.append(obj_)
            obj_.original_tagname_ = 'Identity'
        elif nodeName_ == 'Feature':
            obj_ = FeatureSchemaType.factory()
            obj_.build(child_)
            self.Feature.append(obj_)
            obj_.original_tagname_ = 'Feature'
        elif nodeName_ == 'SanctionsEntryReference':
            obj_ = SanctionsEntryReferenceType.factory()
            obj_.build(child_)
            self.SanctionsEntryReference.append(obj_)
            obj_.original_tagname_ = 'SanctionsEntryReference'
        elif nodeName_ == 'ExternalReference':
            obj_ = ExternalReferenceType.factory()
            obj_.build(child_)
            self.ExternalReference.append(obj_)
            obj_.original_tagname_ = 'ExternalReference'
# end class ProfileType


class SanctionsEntryReferenceType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, SanctionsEntryID=None, DeltaAction=None):
        self.original_tagname_ = None
        self.SanctionsEntryID = _cast(int, SanctionsEntryID)
        self.DeltaAction = _cast(None, DeltaAction)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SanctionsEntryReferenceType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SanctionsEntryReferenceType.subclass:
            return SanctionsEntryReferenceType.subclass(*args_, **kwargs_)
        else:
            return SanctionsEntryReferenceType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_SanctionsEntryID(self): return self.SanctionsEntryID
    def set_SanctionsEntryID(self, SanctionsEntryID): self.SanctionsEntryID = SanctionsEntryID
    def get_DeltaAction(self): return self.DeltaAction
    def set_DeltaAction(self, DeltaAction): self.DeltaAction = DeltaAction
    def validate_DeltaActionSchemaType(self, value):
        # Validate type DeltaActionSchemaType, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['add', 'amend', 'delete', 'revise']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on DeltaActionSchemaType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='un:', name_='SanctionsEntryReferenceType', namespacedef_='xmlns:un="http://www.un.org/sanctions/1.0"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SanctionsEntryReferenceType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SanctionsEntryReferenceType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='un:', name_='SanctionsEntryReferenceType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='un:', name_='SanctionsEntryReferenceType'):
        if self.SanctionsEntryID is not None and 'SanctionsEntryID' not in already_processed:
            already_processed.add('SanctionsEntryID')
            outfile.write(' SanctionsEntryID="%s"' % self.gds_format_integer(self.SanctionsEntryID, input_name='SanctionsEntryID'))
        if self.DeltaAction is not None and 'DeltaAction' not in already_processed:
            already_processed.add('DeltaAction')
            outfile.write(' DeltaAction=%s' % (quote_attrib(self.DeltaAction), ))
    def exportChildren(self, outfile, level, namespace_='un:', name_='SanctionsEntryReferenceType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('SanctionsEntryID', node)
        if value is not None and 'SanctionsEntryID' not in already_processed:
            already_processed.add('SanctionsEntryID')
            try:
                self.SanctionsEntryID = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.SanctionsEntryID < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = find_attr_value_('DeltaAction', node)
        if value is not None and 'DeltaAction' not in already_processed:
            already_processed.add('DeltaAction')
            self.DeltaAction = value
            self.validate_DeltaActionSchemaType(self.DeltaAction)    # validate type DeltaActionSchemaType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class SanctionsEntryReferenceType


class ExternalReferenceType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ExRefTypeID=None, DeltaAction=None, Comment=None, ExRefValue=None, DirectURL=None, SubLink=None):
        self.original_tagname_ = None
        self.ExRefTypeID = _cast(int, ExRefTypeID)
        self.DeltaAction = _cast(None, DeltaAction)
        self.Comment = Comment
        self.ExRefValue = ExRefValue
        self.DirectURL = DirectURL
        if SubLink is None:
            self.SubLink = []
        else:
            self.SubLink = SubLink
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ExternalReferenceType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ExternalReferenceType.subclass:
            return ExternalReferenceType.subclass(*args_, **kwargs_)
        else:
            return ExternalReferenceType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Comment(self): return self.Comment
    def set_Comment(self, Comment): self.Comment = Comment
    def get_ExRefValue(self): return self.ExRefValue
    def set_ExRefValue(self, ExRefValue): self.ExRefValue = ExRefValue
    def get_DirectURL(self): return self.DirectURL
    def set_DirectURL(self, DirectURL): self.DirectURL = DirectURL
    def get_SubLink(self): return self.SubLink
    def set_SubLink(self, SubLink): self.SubLink = SubLink
    def add_SubLink(self, value): self.SubLink.append(value)
    def insert_SubLink_at(self, index, value): self.SubLink.insert(index, value)
    def replace_SubLink_at(self, index, value): self.SubLink[index] = value
    def get_ExRefTypeID(self): return self.ExRefTypeID
    def set_ExRefTypeID(self, ExRefTypeID): self.ExRefTypeID = ExRefTypeID
    def get_DeltaAction(self): return self.DeltaAction
    def set_DeltaAction(self, DeltaAction): self.DeltaAction = DeltaAction
    def validate_DeltaActionSchemaType(self, value):
        # Validate type DeltaActionSchemaType, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['add', 'amend', 'delete', 'revise']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on DeltaActionSchemaType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.Comment is not None or
            self.ExRefValue is not None or
            self.DirectURL is not None or
            self.SubLink
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='un:', name_='ExternalReferenceType', namespacedef_='xmlns:un="http://www.un.org/sanctions/1.0"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ExternalReferenceType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ExternalReferenceType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='un:', name_='ExternalReferenceType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='un:', name_='ExternalReferenceType'):
        if self.ExRefTypeID is not None and 'ExRefTypeID' not in already_processed:
            already_processed.add('ExRefTypeID')
            outfile.write(' ExRefTypeID="%s"' % self.gds_format_integer(self.ExRefTypeID, input_name='ExRefTypeID'))
        if self.DeltaAction is not None and 'DeltaAction' not in already_processed:
            already_processed.add('DeltaAction')
            outfile.write(' DeltaAction=%s' % (quote_attrib(self.DeltaAction), ))
    def exportChildren(self, outfile, level, namespace_='un:', name_='ExternalReferenceType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Comment is not None:
            self.Comment.export(outfile, level, namespace_, name_='Comment', pretty_print=pretty_print)
        if self.ExRefValue is not None:
            self.ExRefValue.export(outfile, level, namespace_, name_='ExRefValue', pretty_print=pretty_print)
        if self.DirectURL is not None:
            self.DirectURL.export(outfile, level, namespace_, name_='DirectURL', pretty_print=pretty_print)
        for SubLink_ in self.SubLink:
            SubLink_.export(outfile, level, namespace_, name_='SubLink', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ExRefTypeID', node)
        if value is not None and 'ExRefTypeID' not in already_processed:
            already_processed.add('ExRefTypeID')
            try:
                self.ExRefTypeID = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.ExRefTypeID < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = find_attr_value_('DeltaAction', node)
        if value is not None and 'DeltaAction' not in already_processed:
            already_processed.add('DeltaAction')
            self.DeltaAction = value
            self.validate_DeltaActionSchemaType(self.DeltaAction)    # validate type DeltaActionSchemaType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Comment':
            obj_ = Comment.factory()
            obj_.build(child_)
            self.Comment = obj_
            obj_.original_tagname_ = 'Comment'
        elif nodeName_ == 'ExRefValue':
            obj_ = ExRefValueType.factory()
            obj_.build(child_)
            self.ExRefValue = obj_
            obj_.original_tagname_ = 'ExRefValue'
        elif nodeName_ == 'DirectURL':
            obj_ = DirectURL.factory()
            obj_.build(child_)
            self.DirectURL = obj_
            obj_.original_tagname_ = 'DirectURL'
        elif nodeName_ == 'SubLink':
            obj_ = SubLinkType.factory()
            obj_.build(child_)
            self.SubLink.append(obj_)
            obj_.original_tagname_ = 'SubLink'
# end class ExternalReferenceType


class ExRefValueType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, DeltaAction=None, valueOf_=None):
        self.original_tagname_ = None
        self.DeltaAction = _cast(None, DeltaAction)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ExRefValueType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ExRefValueType.subclass:
            return ExRefValueType.subclass(*args_, **kwargs_)
        else:
            return ExRefValueType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_DeltaAction(self): return self.DeltaAction
    def set_DeltaAction(self, DeltaAction): self.DeltaAction = DeltaAction
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_DeltaActionSchemaType(self, value):
        # Validate type DeltaActionSchemaType, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['add', 'amend', 'delete', 'revise']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on DeltaActionSchemaType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='un:', name_='ExRefValueType', namespacedef_='xmlns:un="http://www.un.org/sanctions/1.0"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ExRefValueType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ExRefValueType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='un:', name_='ExRefValueType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='un:', name_='ExRefValueType'):
        if self.DeltaAction is not None and 'DeltaAction' not in already_processed:
            already_processed.add('DeltaAction')
            outfile.write(' DeltaAction=%s' % (quote_attrib(self.DeltaAction), ))
    def exportChildren(self, outfile, level, namespace_='un:', name_='ExRefValueType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('DeltaAction', node)
        if value is not None and 'DeltaAction' not in already_processed:
            already_processed.add('DeltaAction')
            self.DeltaAction = value
            self.validate_DeltaActionSchemaType(self.DeltaAction)    # validate type DeltaActionSchemaType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ExRefValueType


class SubLinkType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, TargetTypeID=None, DeltaAction=None, Description=None, DirectURL=None):
        self.original_tagname_ = None
        self.TargetTypeID = _cast(int, TargetTypeID)
        self.DeltaAction = _cast(None, DeltaAction)
        self.Description = Description
        self.DirectURL = DirectURL
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SubLinkType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SubLinkType.subclass:
            return SubLinkType.subclass(*args_, **kwargs_)
        else:
            return SubLinkType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Description(self): return self.Description
    def set_Description(self, Description): self.Description = Description
    def get_DirectURL(self): return self.DirectURL
    def set_DirectURL(self, DirectURL): self.DirectURL = DirectURL
    def get_TargetTypeID(self): return self.TargetTypeID
    def set_TargetTypeID(self, TargetTypeID): self.TargetTypeID = TargetTypeID
    def get_DeltaAction(self): return self.DeltaAction
    def set_DeltaAction(self, DeltaAction): self.DeltaAction = DeltaAction
    def validate_DeltaActionSchemaType(self, value):
        # Validate type DeltaActionSchemaType, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['add', 'amend', 'delete', 'revise']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on DeltaActionSchemaType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.Description is not None or
            self.DirectURL is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='un:', name_='SubLinkType', namespacedef_='xmlns:un="http://www.un.org/sanctions/1.0"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SubLinkType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SubLinkType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='un:', name_='SubLinkType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='un:', name_='SubLinkType'):
        if self.TargetTypeID is not None and 'TargetTypeID' not in already_processed:
            already_processed.add('TargetTypeID')
            outfile.write(' TargetTypeID="%s"' % self.gds_format_integer(self.TargetTypeID, input_name='TargetTypeID'))
        if self.DeltaAction is not None and 'DeltaAction' not in already_processed:
            already_processed.add('DeltaAction')
            outfile.write(' DeltaAction=%s' % (quote_attrib(self.DeltaAction), ))
    def exportChildren(self, outfile, level, namespace_='un:', name_='SubLinkType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Description is not None:
            self.Description.export(outfile, level, namespace_, name_='Description', pretty_print=pretty_print)
        if self.DirectURL is not None:
            self.DirectURL.export(outfile, level, namespace_, name_='DirectURL', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('TargetTypeID', node)
        if value is not None and 'TargetTypeID' not in already_processed:
            already_processed.add('TargetTypeID')
            try:
                self.TargetTypeID = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.TargetTypeID < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = find_attr_value_('DeltaAction', node)
        if value is not None and 'DeltaAction' not in already_processed:
            already_processed.add('DeltaAction')
            self.DeltaAction = value
            self.validate_DeltaActionSchemaType(self.DeltaAction)    # validate type DeltaActionSchemaType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Description':
            obj_ = DescriptionType.factory()
            obj_.build(child_)
            self.Description = obj_
            obj_.original_tagname_ = 'Description'
        elif nodeName_ == 'DirectURL':
            obj_ = DirectURL.factory()
            obj_.build(child_)
            self.DirectURL = obj_
            obj_.original_tagname_ = 'DirectURL'
# end class SubLinkType


class DescriptionType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, DeltaAction=None, valueOf_=None):
        self.original_tagname_ = None
        self.DeltaAction = _cast(None, DeltaAction)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DescriptionType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DescriptionType.subclass:
            return DescriptionType.subclass(*args_, **kwargs_)
        else:
            return DescriptionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_DeltaAction(self): return self.DeltaAction
    def set_DeltaAction(self, DeltaAction): self.DeltaAction = DeltaAction
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_DeltaActionSchemaType(self, value):
        # Validate type DeltaActionSchemaType, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['add', 'amend', 'delete', 'revise']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on DeltaActionSchemaType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='un:', name_='DescriptionType', namespacedef_='xmlns:un="http://www.un.org/sanctions/1.0"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DescriptionType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DescriptionType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='un:', name_='DescriptionType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='un:', name_='DescriptionType'):
        if self.DeltaAction is not None and 'DeltaAction' not in already_processed:
            already_processed.add('DeltaAction')
            outfile.write(' DeltaAction=%s' % (quote_attrib(self.DeltaAction), ))
    def exportChildren(self, outfile, level, namespace_='un:', name_='DescriptionType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('DeltaAction', node)
        if value is not None and 'DeltaAction' not in already_processed:
            already_processed.add('DeltaAction')
            self.DeltaAction = value
            self.validate_DeltaActionSchemaType(self.DeltaAction)    # validate type DeltaActionSchemaType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class DescriptionType


class FeatureVersionType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ID=None, ReliabilityID=None, DeltaAction=None, Comment=None, DatePeriod=None, VersionDetail=None, VersionLocation=None, IDRegDocumentReference=None):
        self.original_tagname_ = None
        self.ID = _cast(int, ID)
        self.ReliabilityID = _cast(int, ReliabilityID)
        self.DeltaAction = _cast(None, DeltaAction)
        self.Comment = Comment
        if DatePeriod is None:
            self.DatePeriod = []
        else:
            self.DatePeriod = DatePeriod
        if VersionDetail is None:
            self.VersionDetail = []
        else:
            self.VersionDetail = VersionDetail
        if VersionLocation is None:
            self.VersionLocation = []
        else:
            self.VersionLocation = VersionLocation
        if IDRegDocumentReference is None:
            self.IDRegDocumentReference = []
        else:
            self.IDRegDocumentReference = IDRegDocumentReference
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FeatureVersionType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FeatureVersionType.subclass:
            return FeatureVersionType.subclass(*args_, **kwargs_)
        else:
            return FeatureVersionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Comment(self): return self.Comment
    def set_Comment(self, Comment): self.Comment = Comment
    def get_DatePeriod(self): return self.DatePeriod
    def set_DatePeriod(self, DatePeriod): self.DatePeriod = DatePeriod
    def add_DatePeriod(self, value): self.DatePeriod.append(value)
    def insert_DatePeriod_at(self, index, value): self.DatePeriod.insert(index, value)
    def replace_DatePeriod_at(self, index, value): self.DatePeriod[index] = value
    def get_VersionDetail(self): return self.VersionDetail
    def set_VersionDetail(self, VersionDetail): self.VersionDetail = VersionDetail
    def add_VersionDetail(self, value): self.VersionDetail.append(value)
    def insert_VersionDetail_at(self, index, value): self.VersionDetail.insert(index, value)
    def replace_VersionDetail_at(self, index, value): self.VersionDetail[index] = value
    def get_VersionLocation(self): return self.VersionLocation
    def set_VersionLocation(self, VersionLocation): self.VersionLocation = VersionLocation
    def add_VersionLocation(self, value): self.VersionLocation.append(value)
    def insert_VersionLocation_at(self, index, value): self.VersionLocation.insert(index, value)
    def replace_VersionLocation_at(self, index, value): self.VersionLocation[index] = value
    def get_IDRegDocumentReference(self): return self.IDRegDocumentReference
    def set_IDRegDocumentReference(self, IDRegDocumentReference): self.IDRegDocumentReference = IDRegDocumentReference
    def add_IDRegDocumentReference(self, value): self.IDRegDocumentReference.append(value)
    def insert_IDRegDocumentReference_at(self, index, value): self.IDRegDocumentReference.insert(index, value)
    def replace_IDRegDocumentReference_at(self, index, value): self.IDRegDocumentReference[index] = value
    def get_ID(self): return self.ID
    def set_ID(self, ID): self.ID = ID
    def get_ReliabilityID(self): return self.ReliabilityID
    def set_ReliabilityID(self, ReliabilityID): self.ReliabilityID = ReliabilityID
    def get_DeltaAction(self): return self.DeltaAction
    def set_DeltaAction(self, DeltaAction): self.DeltaAction = DeltaAction
    def validate_DeltaActionSchemaType(self, value):
        # Validate type DeltaActionSchemaType, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['add', 'amend', 'delete', 'revise']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on DeltaActionSchemaType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.Comment is not None or
            self.DatePeriod or
            self.VersionDetail or
            self.VersionLocation or
            self.IDRegDocumentReference
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='un:', name_='FeatureVersionType', namespacedef_='xmlns:un="http://www.un.org/sanctions/1.0"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('FeatureVersionType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FeatureVersionType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='un:', name_='FeatureVersionType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='un:', name_='FeatureVersionType'):
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            outfile.write(' ID="%s"' % self.gds_format_integer(self.ID, input_name='ID'))
        if self.ReliabilityID is not None and 'ReliabilityID' not in already_processed:
            already_processed.add('ReliabilityID')
            outfile.write(' ReliabilityID="%s"' % self.gds_format_integer(self.ReliabilityID, input_name='ReliabilityID'))
        if self.DeltaAction is not None and 'DeltaAction' not in already_processed:
            already_processed.add('DeltaAction')
            outfile.write(' DeltaAction=%s' % (quote_attrib(self.DeltaAction), ))
    def exportChildren(self, outfile, level, namespace_='un:', name_='FeatureVersionType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Comment is not None:
            self.Comment.export(outfile, level, namespace_, name_='Comment', pretty_print=pretty_print)
        for DatePeriod_ in self.DatePeriod:
            DatePeriod_.export(outfile, level, namespace_, name_='DatePeriod', pretty_print=pretty_print)
        for VersionDetail_ in self.VersionDetail:
            VersionDetail_.export(outfile, level, namespace_, name_='VersionDetail', pretty_print=pretty_print)
        for VersionLocation_ in self.VersionLocation:
            VersionLocation_.export(outfile, level, namespace_, name_='VersionLocation', pretty_print=pretty_print)
        for IDRegDocumentReference_ in self.IDRegDocumentReference:
            IDRegDocumentReference_.export(outfile, level, namespace_, name_='IDRegDocumentReference', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            try:
                self.ID = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.ID < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = find_attr_value_('ReliabilityID', node)
        if value is not None and 'ReliabilityID' not in already_processed:
            already_processed.add('ReliabilityID')
            try:
                self.ReliabilityID = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.ReliabilityID < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = find_attr_value_('DeltaAction', node)
        if value is not None and 'DeltaAction' not in already_processed:
            already_processed.add('DeltaAction')
            self.DeltaAction = value
            self.validate_DeltaActionSchemaType(self.DeltaAction)    # validate type DeltaActionSchemaType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Comment':
            obj_ = Comment.factory()
            obj_.build(child_)
            self.Comment = obj_
            obj_.original_tagname_ = 'Comment'
        elif nodeName_ == 'DatePeriod':
            obj_ = DatePeriod.factory()
            obj_.build(child_)
            self.DatePeriod.append(obj_)
            obj_.original_tagname_ = 'DatePeriod'
        elif nodeName_ == 'VersionDetail':
            obj_ = VersionDetailType.factory()
            obj_.build(child_)
            self.VersionDetail.append(obj_)
            obj_.original_tagname_ = 'VersionDetail'
        elif nodeName_ == 'VersionLocation':
            obj_ = VersionLocationType.factory()
            obj_.build(child_)
            self.VersionLocation.append(obj_)
            obj_.original_tagname_ = 'VersionLocation'
        elif nodeName_ == 'IDRegDocumentReference':
            obj_ = IDRegDocumentReference.factory()
            obj_.build(child_)
            self.IDRegDocumentReference.append(obj_)
            obj_.original_tagname_ = 'IDRegDocumentReference'
# end class FeatureVersionType


class VersionDetailType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, DetailTypeID=None, DetailReferenceID=None, DeltaAction=None, valueOf_=None):
        self.original_tagname_ = None
        self.DetailTypeID = _cast(int, DetailTypeID)
        self.DetailReferenceID = _cast(int, DetailReferenceID)
        self.DeltaAction = _cast(None, DeltaAction)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, VersionDetailType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if VersionDetailType.subclass:
            return VersionDetailType.subclass(*args_, **kwargs_)
        else:
            return VersionDetailType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_DetailTypeID(self): return self.DetailTypeID
    def set_DetailTypeID(self, DetailTypeID): self.DetailTypeID = DetailTypeID
    def get_DetailReferenceID(self): return self.DetailReferenceID
    def set_DetailReferenceID(self, DetailReferenceID): self.DetailReferenceID = DetailReferenceID
    def get_DeltaAction(self): return self.DeltaAction
    def set_DeltaAction(self, DeltaAction): self.DeltaAction = DeltaAction
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_DeltaActionSchemaType(self, value):
        # Validate type DeltaActionSchemaType, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['add', 'amend', 'delete', 'revise']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on DeltaActionSchemaType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='un:', name_='VersionDetailType', namespacedef_='xmlns:un="http://www.un.org/sanctions/1.0"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('VersionDetailType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='VersionDetailType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='un:', name_='VersionDetailType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='un:', name_='VersionDetailType'):
        if self.DetailTypeID is not None and 'DetailTypeID' not in already_processed:
            already_processed.add('DetailTypeID')
            outfile.write(' DetailTypeID="%s"' % self.gds_format_integer(self.DetailTypeID, input_name='DetailTypeID'))
        if self.DetailReferenceID is not None and 'DetailReferenceID' not in already_processed:
            already_processed.add('DetailReferenceID')
            outfile.write(' DetailReferenceID="%s"' % self.gds_format_integer(self.DetailReferenceID, input_name='DetailReferenceID'))
        if self.DeltaAction is not None and 'DeltaAction' not in already_processed:
            already_processed.add('DeltaAction')
            outfile.write(' DeltaAction=%s' % (quote_attrib(self.DeltaAction), ))
    def exportChildren(self, outfile, level, namespace_='un:', name_='VersionDetailType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('DetailTypeID', node)
        if value is not None and 'DetailTypeID' not in already_processed:
            already_processed.add('DetailTypeID')
            try:
                self.DetailTypeID = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.DetailTypeID < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = find_attr_value_('DetailReferenceID', node)
        if value is not None and 'DetailReferenceID' not in already_processed:
            already_processed.add('DetailReferenceID')
            try:
                self.DetailReferenceID = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.DetailReferenceID < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = find_attr_value_('DeltaAction', node)
        if value is not None and 'DeltaAction' not in already_processed:
            already_processed.add('DeltaAction')
            self.DeltaAction = value
            self.validate_DeltaActionSchemaType(self.DeltaAction)    # validate type DeltaActionSchemaType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class VersionDetailType


class VersionLocationType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, LocationID=None, DeltaAction=None):
        self.original_tagname_ = None
        self.LocationID = _cast(int, LocationID)
        self.DeltaAction = _cast(None, DeltaAction)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, VersionLocationType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if VersionLocationType.subclass:
            return VersionLocationType.subclass(*args_, **kwargs_)
        else:
            return VersionLocationType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_LocationID(self): return self.LocationID
    def set_LocationID(self, LocationID): self.LocationID = LocationID
    def get_DeltaAction(self): return self.DeltaAction
    def set_DeltaAction(self, DeltaAction): self.DeltaAction = DeltaAction
    def validate_DeltaActionSchemaType(self, value):
        # Validate type DeltaActionSchemaType, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['add', 'amend', 'delete', 'revise']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on DeltaActionSchemaType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='un:', name_='VersionLocationType', namespacedef_='xmlns:un="http://www.un.org/sanctions/1.0"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('VersionLocationType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='VersionLocationType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='un:', name_='VersionLocationType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='un:', name_='VersionLocationType'):
        if self.LocationID is not None and 'LocationID' not in already_processed:
            already_processed.add('LocationID')
            outfile.write(' LocationID="%s"' % self.gds_format_integer(self.LocationID, input_name='LocationID'))
        if self.DeltaAction is not None and 'DeltaAction' not in already_processed:
            already_processed.add('DeltaAction')
            outfile.write(' DeltaAction=%s' % (quote_attrib(self.DeltaAction), ))
    def exportChildren(self, outfile, level, namespace_='un:', name_='VersionLocationType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('LocationID', node)
        if value is not None and 'LocationID' not in already_processed:
            already_processed.add('LocationID')
            try:
                self.LocationID = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.LocationID < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = find_attr_value_('DeltaAction', node)
        if value is not None and 'DeltaAction' not in already_processed:
            already_processed.add('DeltaAction')
            self.DeltaAction = value
            self.validate_DeltaActionSchemaType(self.DeltaAction)    # validate type DeltaActionSchemaType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class VersionLocationType


class IdentityReferenceType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, IdentityID=None, IdentityFeatureLinkTypeID=None, DeltaAction=None):
        self.original_tagname_ = None
        self.IdentityID = _cast(int, IdentityID)
        self.IdentityFeatureLinkTypeID = _cast(int, IdentityFeatureLinkTypeID)
        self.DeltaAction = _cast(None, DeltaAction)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, IdentityReferenceType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if IdentityReferenceType.subclass:
            return IdentityReferenceType.subclass(*args_, **kwargs_)
        else:
            return IdentityReferenceType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_IdentityID(self): return self.IdentityID
    def set_IdentityID(self, IdentityID): self.IdentityID = IdentityID
    def get_IdentityFeatureLinkTypeID(self): return self.IdentityFeatureLinkTypeID
    def set_IdentityFeatureLinkTypeID(self, IdentityFeatureLinkTypeID): self.IdentityFeatureLinkTypeID = IdentityFeatureLinkTypeID
    def get_DeltaAction(self): return self.DeltaAction
    def set_DeltaAction(self, DeltaAction): self.DeltaAction = DeltaAction
    def validate_DeltaActionSchemaType(self, value):
        # Validate type DeltaActionSchemaType, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['add', 'amend', 'delete', 'revise']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on DeltaActionSchemaType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='un:', name_='IdentityReferenceType', namespacedef_='xmlns:un="http://www.un.org/sanctions/1.0"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('IdentityReferenceType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='IdentityReferenceType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='un:', name_='IdentityReferenceType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='un:', name_='IdentityReferenceType'):
        if self.IdentityID is not None and 'IdentityID' not in already_processed:
            already_processed.add('IdentityID')
            outfile.write(' IdentityID="%s"' % self.gds_format_integer(self.IdentityID, input_name='IdentityID'))
        if self.IdentityFeatureLinkTypeID is not None and 'IdentityFeatureLinkTypeID' not in already_processed:
            already_processed.add('IdentityFeatureLinkTypeID')
            outfile.write(' IdentityFeatureLinkTypeID="%s"' % self.gds_format_integer(self.IdentityFeatureLinkTypeID, input_name='IdentityFeatureLinkTypeID'))
        if self.DeltaAction is not None and 'DeltaAction' not in already_processed:
            already_processed.add('DeltaAction')
            outfile.write(' DeltaAction=%s' % (quote_attrib(self.DeltaAction), ))
    def exportChildren(self, outfile, level, namespace_='un:', name_='IdentityReferenceType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('IdentityID', node)
        if value is not None and 'IdentityID' not in already_processed:
            already_processed.add('IdentityID')
            try:
                self.IdentityID = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.IdentityID < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = find_attr_value_('IdentityFeatureLinkTypeID', node)
        if value is not None and 'IdentityFeatureLinkTypeID' not in already_processed:
            already_processed.add('IdentityFeatureLinkTypeID')
            try:
                self.IdentityFeatureLinkTypeID = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.IdentityFeatureLinkTypeID < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = find_attr_value_('DeltaAction', node)
        if value is not None and 'DeltaAction' not in already_processed:
            already_processed.add('DeltaAction')
            self.DeltaAction = value
            self.validate_DeltaActionSchemaType(self.DeltaAction)    # validate type DeltaActionSchemaType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class IdentityReferenceType


class AliasType3(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, FixedRef=None, AliasTypeID=None, Primary=None, LowQuality=None, DeltaAction=None, Comment=None, DatePeriod=None, DocumentedName=None):
        self.original_tagname_ = None
        self.FixedRef = _cast(None, FixedRef)
        self.AliasTypeID = _cast(int, AliasTypeID)
        self.Primary = _cast(bool, Primary)
        self.LowQuality = _cast(bool, LowQuality)
        self.DeltaAction = _cast(None, DeltaAction)
        self.Comment = Comment
        self.DatePeriod = DatePeriod
        if DocumentedName is None:
            self.DocumentedName = []
        else:
            self.DocumentedName = DocumentedName
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AliasType3)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AliasType3.subclass:
            return AliasType3.subclass(*args_, **kwargs_)
        else:
            return AliasType3(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Comment(self): return self.Comment
    def set_Comment(self, Comment): self.Comment = Comment
    def get_DatePeriod(self): return self.DatePeriod
    def set_DatePeriod(self, DatePeriod): self.DatePeriod = DatePeriod
    def get_DocumentedName(self): return self.DocumentedName
    def set_DocumentedName(self, DocumentedName): self.DocumentedName = DocumentedName
    def add_DocumentedName(self, value): self.DocumentedName.append(value)
    def insert_DocumentedName_at(self, index, value): self.DocumentedName.insert(index, value)
    def replace_DocumentedName_at(self, index, value): self.DocumentedName[index] = value
    def get_FixedRef(self): return self.FixedRef
    def set_FixedRef(self, FixedRef): self.FixedRef = FixedRef
    def get_AliasTypeID(self): return self.AliasTypeID
    def set_AliasTypeID(self, AliasTypeID): self.AliasTypeID = AliasTypeID
    def get_Primary(self): return self.Primary
    def set_Primary(self, Primary): self.Primary = Primary
    def get_LowQuality(self): return self.LowQuality
    def set_LowQuality(self, LowQuality): self.LowQuality = LowQuality
    def get_DeltaAction(self): return self.DeltaAction
    def set_DeltaAction(self, DeltaAction): self.DeltaAction = DeltaAction
    def validate_DeltaActionSchemaType(self, value):
        # Validate type DeltaActionSchemaType, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['add', 'amend', 'delete', 'revise']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on DeltaActionSchemaType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.Comment is not None or
            self.DatePeriod is not None or
            self.DocumentedName
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='un:', name_='AliasType3', namespacedef_='xmlns:un="http://www.un.org/sanctions/1.0"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('AliasType3')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AliasType3')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='un:', name_='AliasType3', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='un:', name_='AliasType3'):
        if self.FixedRef is not None and 'FixedRef' not in already_processed:
            already_processed.add('FixedRef')
            outfile.write(' FixedRef=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.FixedRef), input_name='FixedRef')), ))
        if self.AliasTypeID is not None and 'AliasTypeID' not in already_processed:
            already_processed.add('AliasTypeID')
            outfile.write(' AliasTypeID="%s"' % self.gds_format_integer(self.AliasTypeID, input_name='AliasTypeID'))
        if self.Primary is not None and 'Primary' not in already_processed:
            already_processed.add('Primary')
            outfile.write(' Primary="%s"' % self.gds_format_boolean(self.Primary, input_name='Primary'))
        if self.LowQuality is not None and 'LowQuality' not in already_processed:
            already_processed.add('LowQuality')
            outfile.write(' LowQuality="%s"' % self.gds_format_boolean(self.LowQuality, input_name='LowQuality'))
        if self.DeltaAction is not None and 'DeltaAction' not in already_processed:
            already_processed.add('DeltaAction')
            outfile.write(' DeltaAction=%s' % (quote_attrib(self.DeltaAction), ))
    def exportChildren(self, outfile, level, namespace_='un:', name_='AliasType3', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Comment is not None:
            self.Comment.export(outfile, level, namespace_, name_='Comment', pretty_print=pretty_print)
        if self.DatePeriod is not None:
            self.DatePeriod.export(outfile, level, namespace_, name_='DatePeriod', pretty_print=pretty_print)
        for DocumentedName_ in self.DocumentedName:
            DocumentedName_.export(outfile, level, namespace_, name_='DocumentedName', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('FixedRef', node)
        if value is not None and 'FixedRef' not in already_processed:
            already_processed.add('FixedRef')
            self.FixedRef = value
        value = find_attr_value_('AliasTypeID', node)
        if value is not None and 'AliasTypeID' not in already_processed:
            already_processed.add('AliasTypeID')
            try:
                self.AliasTypeID = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.AliasTypeID < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = find_attr_value_('Primary', node)
        if value is not None and 'Primary' not in already_processed:
            already_processed.add('Primary')
            if value in ('true', '1'):
                self.Primary = True
            elif value in ('false', '0'):
                self.Primary = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('LowQuality', node)
        if value is not None and 'LowQuality' not in already_processed:
            already_processed.add('LowQuality')
            if value in ('true', '1'):
                self.LowQuality = True
            elif value in ('false', '0'):
                self.LowQuality = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('DeltaAction', node)
        if value is not None and 'DeltaAction' not in already_processed:
            already_processed.add('DeltaAction')
            self.DeltaAction = value
            self.validate_DeltaActionSchemaType(self.DeltaAction)    # validate type DeltaActionSchemaType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Comment':
            obj_ = Comment.factory()
            obj_.build(child_)
            self.Comment = obj_
            obj_.original_tagname_ = 'Comment'
        elif nodeName_ == 'DatePeriod':
            obj_ = DatePeriod.factory()
            obj_.build(child_)
            self.DatePeriod = obj_
            obj_.original_tagname_ = 'DatePeriod'
        elif nodeName_ == 'DocumentedName':
            obj_ = DocumentedNameSchemaType.factory()
            obj_.build(child_)
            self.DocumentedName.append(obj_)
            obj_.original_tagname_ = 'DocumentedName'
# end class AliasType3


class NamePartGroupsType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, DeltaAction=None, MasterNamePartGroup=None):
        self.original_tagname_ = None
        self.DeltaAction = _cast(None, DeltaAction)
        if MasterNamePartGroup is None:
            self.MasterNamePartGroup = []
        else:
            self.MasterNamePartGroup = MasterNamePartGroup
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, NamePartGroupsType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if NamePartGroupsType.subclass:
            return NamePartGroupsType.subclass(*args_, **kwargs_)
        else:
            return NamePartGroupsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_MasterNamePartGroup(self): return self.MasterNamePartGroup
    def set_MasterNamePartGroup(self, MasterNamePartGroup): self.MasterNamePartGroup = MasterNamePartGroup
    def add_MasterNamePartGroup(self, value): self.MasterNamePartGroup.append(value)
    def insert_MasterNamePartGroup_at(self, index, value): self.MasterNamePartGroup.insert(index, value)
    def replace_MasterNamePartGroup_at(self, index, value): self.MasterNamePartGroup[index] = value
    def get_DeltaAction(self): return self.DeltaAction
    def set_DeltaAction(self, DeltaAction): self.DeltaAction = DeltaAction
    def validate_DeltaActionSchemaType(self, value):
        # Validate type DeltaActionSchemaType, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['add', 'amend', 'delete', 'revise']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on DeltaActionSchemaType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.MasterNamePartGroup
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='un:', name_='NamePartGroupsType', namespacedef_='xmlns:un="http://www.un.org/sanctions/1.0"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('NamePartGroupsType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='NamePartGroupsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='un:', name_='NamePartGroupsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='un:', name_='NamePartGroupsType'):
        if self.DeltaAction is not None and 'DeltaAction' not in already_processed:
            already_processed.add('DeltaAction')
            outfile.write(' DeltaAction=%s' % (quote_attrib(self.DeltaAction), ))
    def exportChildren(self, outfile, level, namespace_='un:', name_='NamePartGroupsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for MasterNamePartGroup_ in self.MasterNamePartGroup:
            MasterNamePartGroup_.export(outfile, level, namespace_, name_='MasterNamePartGroup', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('DeltaAction', node)
        if value is not None and 'DeltaAction' not in already_processed:
            already_processed.add('DeltaAction')
            self.DeltaAction = value
            self.validate_DeltaActionSchemaType(self.DeltaAction)    # validate type DeltaActionSchemaType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'MasterNamePartGroup':
            obj_ = MasterNamePartGroupType.factory()
            obj_.build(child_)
            self.MasterNamePartGroup.append(obj_)
            obj_.original_tagname_ = 'MasterNamePartGroup'
# end class NamePartGroupsType


class MasterNamePartGroupType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, DeltaAction=None, NamePartGroup=None):
        self.original_tagname_ = None
        self.DeltaAction = _cast(None, DeltaAction)
        if NamePartGroup is None:
            self.NamePartGroup = []
        else:
            self.NamePartGroup = NamePartGroup
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MasterNamePartGroupType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MasterNamePartGroupType.subclass:
            return MasterNamePartGroupType.subclass(*args_, **kwargs_)
        else:
            return MasterNamePartGroupType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_NamePartGroup(self): return self.NamePartGroup
    def set_NamePartGroup(self, NamePartGroup): self.NamePartGroup = NamePartGroup
    def add_NamePartGroup(self, value): self.NamePartGroup.append(value)
    def insert_NamePartGroup_at(self, index, value): self.NamePartGroup.insert(index, value)
    def replace_NamePartGroup_at(self, index, value): self.NamePartGroup[index] = value
    def get_DeltaAction(self): return self.DeltaAction
    def set_DeltaAction(self, DeltaAction): self.DeltaAction = DeltaAction
    def validate_DeltaActionSchemaType(self, value):
        # Validate type DeltaActionSchemaType, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['add', 'amend', 'delete', 'revise']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on DeltaActionSchemaType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.NamePartGroup
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='un:', name_='MasterNamePartGroupType', namespacedef_='xmlns:un="http://www.un.org/sanctions/1.0"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('MasterNamePartGroupType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MasterNamePartGroupType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='un:', name_='MasterNamePartGroupType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='un:', name_='MasterNamePartGroupType'):
        if self.DeltaAction is not None and 'DeltaAction' not in already_processed:
            already_processed.add('DeltaAction')
            outfile.write(' DeltaAction=%s' % (quote_attrib(self.DeltaAction), ))
    def exportChildren(self, outfile, level, namespace_='un:', name_='MasterNamePartGroupType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for NamePartGroup_ in self.NamePartGroup:
            NamePartGroup_.export(outfile, level, namespace_, name_='NamePartGroup', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('DeltaAction', node)
        if value is not None and 'DeltaAction' not in already_processed:
            already_processed.add('DeltaAction')
            self.DeltaAction = value
            self.validate_DeltaActionSchemaType(self.DeltaAction)    # validate type DeltaActionSchemaType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'NamePartGroup':
            obj_ = NamePartGroupType.factory()
            obj_.build(child_)
            self.NamePartGroup.append(obj_)
            obj_.original_tagname_ = 'NamePartGroup'
# end class MasterNamePartGroupType


class NamePartGroupType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ID=None, NamePartTypeID=None, DeltaAction=None):
        self.original_tagname_ = None
        self.ID = _cast(int, ID)
        self.NamePartTypeID = _cast(int, NamePartTypeID)
        self.DeltaAction = _cast(None, DeltaAction)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, NamePartGroupType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if NamePartGroupType.subclass:
            return NamePartGroupType.subclass(*args_, **kwargs_)
        else:
            return NamePartGroupType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ID(self): return self.ID
    def set_ID(self, ID): self.ID = ID
    def get_NamePartTypeID(self): return self.NamePartTypeID
    def set_NamePartTypeID(self, NamePartTypeID): self.NamePartTypeID = NamePartTypeID
    def get_DeltaAction(self): return self.DeltaAction
    def set_DeltaAction(self, DeltaAction): self.DeltaAction = DeltaAction
    def validate_DeltaActionSchemaType(self, value):
        # Validate type DeltaActionSchemaType, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['add', 'amend', 'delete', 'revise']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on DeltaActionSchemaType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='un:', name_='NamePartGroupType', namespacedef_='xmlns:un="http://www.un.org/sanctions/1.0"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('NamePartGroupType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='NamePartGroupType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='un:', name_='NamePartGroupType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='un:', name_='NamePartGroupType'):
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            outfile.write(' ID="%s"' % self.gds_format_integer(self.ID, input_name='ID'))
        if self.NamePartTypeID is not None and 'NamePartTypeID' not in already_processed:
            already_processed.add('NamePartTypeID')
            outfile.write(' NamePartTypeID="%s"' % self.gds_format_integer(self.NamePartTypeID, input_name='NamePartTypeID'))
        if self.DeltaAction is not None and 'DeltaAction' not in already_processed:
            already_processed.add('DeltaAction')
            outfile.write(' DeltaAction=%s' % (quote_attrib(self.DeltaAction), ))
    def exportChildren(self, outfile, level, namespace_='un:', name_='NamePartGroupType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            try:
                self.ID = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.ID < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = find_attr_value_('NamePartTypeID', node)
        if value is not None and 'NamePartTypeID' not in already_processed:
            already_processed.add('NamePartTypeID')
            try:
                self.NamePartTypeID = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.NamePartTypeID < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = find_attr_value_('DeltaAction', node)
        if value is not None and 'DeltaAction' not in already_processed:
            already_processed.add('DeltaAction')
            self.DeltaAction = value
            self.validate_DeltaActionSchemaType(self.DeltaAction)    # validate type DeltaActionSchemaType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class NamePartGroupType


class DocumentedNamePartType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, LeadingChars=None, TrailingChars=None, DeltaAction=None, NamePartValue=None):
        self.original_tagname_ = None
        self.LeadingChars = _cast(None, LeadingChars)
        self.TrailingChars = _cast(None, TrailingChars)
        self.DeltaAction = _cast(None, DeltaAction)
        self.NamePartValue = NamePartValue
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DocumentedNamePartType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DocumentedNamePartType.subclass:
            return DocumentedNamePartType.subclass(*args_, **kwargs_)
        else:
            return DocumentedNamePartType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_NamePartValue(self): return self.NamePartValue
    def set_NamePartValue(self, NamePartValue): self.NamePartValue = NamePartValue
    def get_LeadingChars(self): return self.LeadingChars
    def set_LeadingChars(self, LeadingChars): self.LeadingChars = LeadingChars
    def get_TrailingChars(self): return self.TrailingChars
    def set_TrailingChars(self, TrailingChars): self.TrailingChars = TrailingChars
    def get_DeltaAction(self): return self.DeltaAction
    def set_DeltaAction(self, DeltaAction): self.DeltaAction = DeltaAction
    def validate_DeltaActionSchemaType(self, value):
        # Validate type DeltaActionSchemaType, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['add', 'amend', 'delete', 'revise']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on DeltaActionSchemaType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.NamePartValue is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='un:', name_='DocumentedNamePartType', namespacedef_='xmlns:un="http://www.un.org/sanctions/1.0"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DocumentedNamePartType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DocumentedNamePartType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='un:', name_='DocumentedNamePartType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='un:', name_='DocumentedNamePartType'):
        if self.LeadingChars is not None and 'LeadingChars' not in already_processed:
            already_processed.add('LeadingChars')
            outfile.write(' LeadingChars=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.LeadingChars), input_name='LeadingChars')), ))
        if self.TrailingChars is not None and 'TrailingChars' not in already_processed:
            already_processed.add('TrailingChars')
            outfile.write(' TrailingChars=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.TrailingChars), input_name='TrailingChars')), ))
        if self.DeltaAction is not None and 'DeltaAction' not in already_processed:
            already_processed.add('DeltaAction')
            outfile.write(' DeltaAction=%s' % (quote_attrib(self.DeltaAction), ))
    def exportChildren(self, outfile, level, namespace_='un:', name_='DocumentedNamePartType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.NamePartValue is not None:
            self.NamePartValue.export(outfile, level, namespace_, name_='NamePartValue', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('LeadingChars', node)
        if value is not None and 'LeadingChars' not in already_processed:
            already_processed.add('LeadingChars')
            self.LeadingChars = value
        value = find_attr_value_('TrailingChars', node)
        if value is not None and 'TrailingChars' not in already_processed:
            already_processed.add('TrailingChars')
            self.TrailingChars = value
        value = find_attr_value_('DeltaAction', node)
        if value is not None and 'DeltaAction' not in already_processed:
            already_processed.add('DeltaAction')
            self.DeltaAction = value
            self.validate_DeltaActionSchemaType(self.DeltaAction)    # validate type DeltaActionSchemaType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'NamePartValue':
            obj_ = NamePartValueType.factory()
            obj_.build(child_)
            self.NamePartValue = obj_
            obj_.original_tagname_ = 'NamePartValue'
# end class DocumentedNamePartType


class NamePartValueType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, NamePartGroupID=None, ScriptID=None, ScriptStatusID=None, Acronym=None, DeltaAction=None, valueOf_=None):
        self.original_tagname_ = None
        self.NamePartGroupID = _cast(int, NamePartGroupID)
        self.ScriptID = _cast(int, ScriptID)
        self.ScriptStatusID = _cast(int, ScriptStatusID)
        self.Acronym = _cast(bool, Acronym)
        self.DeltaAction = _cast(None, DeltaAction)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, NamePartValueType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if NamePartValueType.subclass:
            return NamePartValueType.subclass(*args_, **kwargs_)
        else:
            return NamePartValueType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_NamePartGroupID(self): return self.NamePartGroupID
    def set_NamePartGroupID(self, NamePartGroupID): self.NamePartGroupID = NamePartGroupID
    def get_ScriptID(self): return self.ScriptID
    def set_ScriptID(self, ScriptID): self.ScriptID = ScriptID
    def get_ScriptStatusID(self): return self.ScriptStatusID
    def set_ScriptStatusID(self, ScriptStatusID): self.ScriptStatusID = ScriptStatusID
    def get_Acronym(self): return self.Acronym
    def set_Acronym(self, Acronym): self.Acronym = Acronym
    def get_DeltaAction(self): return self.DeltaAction
    def set_DeltaAction(self, DeltaAction): self.DeltaAction = DeltaAction
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_DeltaActionSchemaType(self, value):
        # Validate type DeltaActionSchemaType, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['add', 'amend', 'delete', 'revise']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on DeltaActionSchemaType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='un:', name_='NamePartValueType', namespacedef_='xmlns:un="http://www.un.org/sanctions/1.0"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('NamePartValueType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='NamePartValueType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='un:', name_='NamePartValueType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='un:', name_='NamePartValueType'):
        if self.NamePartGroupID is not None and 'NamePartGroupID' not in already_processed:
            already_processed.add('NamePartGroupID')
            outfile.write(' NamePartGroupID="%s"' % self.gds_format_integer(self.NamePartGroupID, input_name='NamePartGroupID'))
        if self.ScriptID is not None and 'ScriptID' not in already_processed:
            already_processed.add('ScriptID')
            outfile.write(' ScriptID="%s"' % self.gds_format_integer(self.ScriptID, input_name='ScriptID'))
        if self.ScriptStatusID is not None and 'ScriptStatusID' not in already_processed:
            already_processed.add('ScriptStatusID')
            outfile.write(' ScriptStatusID="%s"' % self.gds_format_integer(self.ScriptStatusID, input_name='ScriptStatusID'))
        if self.Acronym is not None and 'Acronym' not in already_processed:
            already_processed.add('Acronym')
            outfile.write(' Acronym="%s"' % self.gds_format_boolean(self.Acronym, input_name='Acronym'))
        if self.DeltaAction is not None and 'DeltaAction' not in already_processed:
            already_processed.add('DeltaAction')
            outfile.write(' DeltaAction=%s' % (quote_attrib(self.DeltaAction), ))
    def exportChildren(self, outfile, level, namespace_='un:', name_='NamePartValueType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('NamePartGroupID', node)
        if value is not None and 'NamePartGroupID' not in already_processed:
            already_processed.add('NamePartGroupID')
            try:
                self.NamePartGroupID = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.NamePartGroupID < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = find_attr_value_('ScriptID', node)
        if value is not None and 'ScriptID' not in already_processed:
            already_processed.add('ScriptID')
            try:
                self.ScriptID = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.ScriptID < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = find_attr_value_('ScriptStatusID', node)
        if value is not None and 'ScriptStatusID' not in already_processed:
            already_processed.add('ScriptStatusID')
            try:
                self.ScriptStatusID = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.ScriptStatusID < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = find_attr_value_('Acronym', node)
        if value is not None and 'Acronym' not in already_processed:
            already_processed.add('Acronym')
            if value in ('true', '1'):
                self.Acronym = True
            elif value in ('false', '0'):
                self.Acronym = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('DeltaAction', node)
        if value is not None and 'DeltaAction' not in already_processed:
            already_processed.add('DeltaAction')
            self.DeltaAction = value
            self.validate_DeltaActionSchemaType(self.DeltaAction)    # validate type DeltaActionSchemaType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class NamePartValueType


class DocumentedNameCountryType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, CountryID=None, DeltaAction=None, Comment=None):
        self.original_tagname_ = None
        self.CountryID = _cast(int, CountryID)
        self.DeltaAction = _cast(None, DeltaAction)
        self.Comment = Comment
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DocumentedNameCountryType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DocumentedNameCountryType.subclass:
            return DocumentedNameCountryType.subclass(*args_, **kwargs_)
        else:
            return DocumentedNameCountryType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Comment(self): return self.Comment
    def set_Comment(self, Comment): self.Comment = Comment
    def get_CountryID(self): return self.CountryID
    def set_CountryID(self, CountryID): self.CountryID = CountryID
    def get_DeltaAction(self): return self.DeltaAction
    def set_DeltaAction(self, DeltaAction): self.DeltaAction = DeltaAction
    def validate_DeltaActionSchemaType(self, value):
        # Validate type DeltaActionSchemaType, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['add', 'amend', 'delete', 'revise']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on DeltaActionSchemaType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.Comment is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='un:', name_='DocumentedNameCountryType', namespacedef_='xmlns:un="http://www.un.org/sanctions/1.0"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DocumentedNameCountryType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DocumentedNameCountryType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='un:', name_='DocumentedNameCountryType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='un:', name_='DocumentedNameCountryType'):
        if self.CountryID is not None and 'CountryID' not in already_processed:
            already_processed.add('CountryID')
            outfile.write(' CountryID="%s"' % self.gds_format_integer(self.CountryID, input_name='CountryID'))
        if self.DeltaAction is not None and 'DeltaAction' not in already_processed:
            already_processed.add('DeltaAction')
            outfile.write(' DeltaAction=%s' % (quote_attrib(self.DeltaAction), ))
    def exportChildren(self, outfile, level, namespace_='un:', name_='DocumentedNameCountryType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Comment is not None:
            self.Comment.export(outfile, level, namespace_, name_='Comment', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('CountryID', node)
        if value is not None and 'CountryID' not in already_processed:
            already_processed.add('CountryID')
            try:
                self.CountryID = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.CountryID < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = find_attr_value_('DeltaAction', node)
        if value is not None and 'DeltaAction' not in already_processed:
            already_processed.add('DeltaAction')
            self.DeltaAction = value
            self.validate_DeltaActionSchemaType(self.DeltaAction)    # validate type DeltaActionSchemaType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Comment':
            obj_ = Comment.factory()
            obj_.build(child_)
            self.Comment = obj_
            obj_.original_tagname_ = 'Comment'
# end class DocumentedNameCountryType


class LimitationsToListingType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, DeltaAction=None, valueOf_=None):
        self.original_tagname_ = None
        self.DeltaAction = _cast(None, DeltaAction)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, LimitationsToListingType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LimitationsToListingType.subclass:
            return LimitationsToListingType.subclass(*args_, **kwargs_)
        else:
            return LimitationsToListingType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_DeltaAction(self): return self.DeltaAction
    def set_DeltaAction(self, DeltaAction): self.DeltaAction = DeltaAction
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_DeltaActionSchemaType(self, value):
        # Validate type DeltaActionSchemaType, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['add', 'amend', 'delete', 'revise']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on DeltaActionSchemaType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='un:', name_='LimitationsToListingType', namespacedef_='xmlns:un="http://www.un.org/sanctions/1.0"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('LimitationsToListingType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LimitationsToListingType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='un:', name_='LimitationsToListingType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='un:', name_='LimitationsToListingType'):
        if self.DeltaAction is not None and 'DeltaAction' not in already_processed:
            already_processed.add('DeltaAction')
            outfile.write(' DeltaAction=%s' % (quote_attrib(self.DeltaAction), ))
    def exportChildren(self, outfile, level, namespace_='un:', name_='LimitationsToListingType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('DeltaAction', node)
        if value is not None and 'DeltaAction' not in already_processed:
            already_processed.add('DeltaAction')
            self.DeltaAction = value
            self.validate_DeltaActionSchemaType(self.DeltaAction)    # validate type DeltaActionSchemaType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class LimitationsToListingType


class EntryEventType4(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ID=None, EntryEventTypeID=None, LegalBasisID=None, DeltaAction=None, Comment=None, Date=None):
        self.original_tagname_ = None
        self.ID = _cast(int, ID)
        self.EntryEventTypeID = _cast(int, EntryEventTypeID)
        self.LegalBasisID = _cast(int, LegalBasisID)
        self.DeltaAction = _cast(None, DeltaAction)
        self.Comment = Comment
        self.Date = Date
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, EntryEventType4)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if EntryEventType4.subclass:
            return EntryEventType4.subclass(*args_, **kwargs_)
        else:
            return EntryEventType4(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Comment(self): return self.Comment
    def set_Comment(self, Comment): self.Comment = Comment
    def get_Date(self): return self.Date
    def set_Date(self, Date): self.Date = Date
    def get_ID(self): return self.ID
    def set_ID(self, ID): self.ID = ID
    def get_EntryEventTypeID(self): return self.EntryEventTypeID
    def set_EntryEventTypeID(self, EntryEventTypeID): self.EntryEventTypeID = EntryEventTypeID
    def get_LegalBasisID(self): return self.LegalBasisID
    def set_LegalBasisID(self, LegalBasisID): self.LegalBasisID = LegalBasisID
    def get_DeltaAction(self): return self.DeltaAction
    def set_DeltaAction(self, DeltaAction): self.DeltaAction = DeltaAction
    def validate_DeltaActionSchemaType(self, value):
        # Validate type DeltaActionSchemaType, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['add', 'amend', 'delete', 'revise']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on DeltaActionSchemaType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.Comment is not None or
            self.Date is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='un:', name_='EntryEventType4', namespacedef_='xmlns:un="http://www.un.org/sanctions/1.0"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('EntryEventType4')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='EntryEventType4')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='un:', name_='EntryEventType4', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='un:', name_='EntryEventType4'):
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            outfile.write(' ID="%s"' % self.gds_format_integer(self.ID, input_name='ID'))
        if self.EntryEventTypeID is not None and 'EntryEventTypeID' not in already_processed:
            already_processed.add('EntryEventTypeID')
            outfile.write(' EntryEventTypeID="%s"' % self.gds_format_integer(self.EntryEventTypeID, input_name='EntryEventTypeID'))
        if self.LegalBasisID is not None and 'LegalBasisID' not in already_processed:
            already_processed.add('LegalBasisID')
            outfile.write(' LegalBasisID="%s"' % self.gds_format_integer(self.LegalBasisID, input_name='LegalBasisID'))
        if self.DeltaAction is not None and 'DeltaAction' not in already_processed:
            already_processed.add('DeltaAction')
            outfile.write(' DeltaAction=%s' % (quote_attrib(self.DeltaAction), ))
    def exportChildren(self, outfile, level, namespace_='un:', name_='EntryEventType4', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Comment is not None:
            self.Comment.export(outfile, level, namespace_, name_='Comment', pretty_print=pretty_print)
        if self.Date is not None:
            self.Date.export(outfile, level, namespace_, name_='Date', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            try:
                self.ID = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.ID < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = find_attr_value_('EntryEventTypeID', node)
        if value is not None and 'EntryEventTypeID' not in already_processed:
            already_processed.add('EntryEventTypeID')
            try:
                self.EntryEventTypeID = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.EntryEventTypeID < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = find_attr_value_('LegalBasisID', node)
        if value is not None and 'LegalBasisID' not in already_processed:
            already_processed.add('LegalBasisID')
            try:
                self.LegalBasisID = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.LegalBasisID < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = find_attr_value_('DeltaAction', node)
        if value is not None and 'DeltaAction' not in already_processed:
            already_processed.add('DeltaAction')
            self.DeltaAction = value
            self.validate_DeltaActionSchemaType(self.DeltaAction)    # validate type DeltaActionSchemaType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Comment':
            obj_ = Comment.factory()
            obj_.build(child_)
            self.Comment = obj_
            obj_.original_tagname_ = 'Comment'
        elif nodeName_ == 'Date':
            obj_ = DateSchemaType.factory()
            obj_.build(child_)
            self.Date = obj_
            obj_.original_tagname_ = 'Date'
# end class EntryEventType4


class SanctionsMeasureType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ID=None, SanctionsTypeID=None, DeltaAction=None, Comment=None, DatePeriod=None):
        self.original_tagname_ = None
        self.ID = _cast(int, ID)
        self.SanctionsTypeID = _cast(int, SanctionsTypeID)
        self.DeltaAction = _cast(None, DeltaAction)
        self.Comment = Comment
        self.DatePeriod = DatePeriod
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SanctionsMeasureType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SanctionsMeasureType.subclass:
            return SanctionsMeasureType.subclass(*args_, **kwargs_)
        else:
            return SanctionsMeasureType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Comment(self): return self.Comment
    def set_Comment(self, Comment): self.Comment = Comment
    def get_DatePeriod(self): return self.DatePeriod
    def set_DatePeriod(self, DatePeriod): self.DatePeriod = DatePeriod
    def get_ID(self): return self.ID
    def set_ID(self, ID): self.ID = ID
    def get_SanctionsTypeID(self): return self.SanctionsTypeID
    def set_SanctionsTypeID(self, SanctionsTypeID): self.SanctionsTypeID = SanctionsTypeID
    def get_DeltaAction(self): return self.DeltaAction
    def set_DeltaAction(self, DeltaAction): self.DeltaAction = DeltaAction
    def validate_DeltaActionSchemaType(self, value):
        # Validate type DeltaActionSchemaType, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['add', 'amend', 'delete', 'revise']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on DeltaActionSchemaType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.Comment is not None or
            self.DatePeriod is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='un:', name_='SanctionsMeasureType', namespacedef_='xmlns:un="http://www.un.org/sanctions/1.0"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SanctionsMeasureType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SanctionsMeasureType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='un:', name_='SanctionsMeasureType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='un:', name_='SanctionsMeasureType'):
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            outfile.write(' ID="%s"' % self.gds_format_integer(self.ID, input_name='ID'))
        if self.SanctionsTypeID is not None and 'SanctionsTypeID' not in already_processed:
            already_processed.add('SanctionsTypeID')
            outfile.write(' SanctionsTypeID="%s"' % self.gds_format_integer(self.SanctionsTypeID, input_name='SanctionsTypeID'))
        if self.DeltaAction is not None and 'DeltaAction' not in already_processed:
            already_processed.add('DeltaAction')
            outfile.write(' DeltaAction=%s' % (quote_attrib(self.DeltaAction), ))
    def exportChildren(self, outfile, level, namespace_='un:', name_='SanctionsMeasureType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Comment is not None:
            self.Comment.export(outfile, level, namespace_, name_='Comment', pretty_print=pretty_print)
        if self.DatePeriod is not None:
            self.DatePeriod.export(outfile, level, namespace_, name_='DatePeriod', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            try:
                self.ID = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.ID < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = find_attr_value_('SanctionsTypeID', node)
        if value is not None and 'SanctionsTypeID' not in already_processed:
            already_processed.add('SanctionsTypeID')
            try:
                self.SanctionsTypeID = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.SanctionsTypeID < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = find_attr_value_('DeltaAction', node)
        if value is not None and 'DeltaAction' not in already_processed:
            already_processed.add('DeltaAction')
            self.DeltaAction = value
            self.validate_DeltaActionSchemaType(self.DeltaAction)    # validate type DeltaActionSchemaType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Comment':
            obj_ = Comment.factory()
            obj_.build(child_)
            self.Comment = obj_
            obj_.original_tagname_ = 'Comment'
        elif nodeName_ == 'DatePeriod':
            obj_ = DatePeriod.factory()
            obj_.build(child_)
            self.DatePeriod = obj_
            obj_.original_tagname_ = 'DatePeriod'
# end class SanctionsMeasureType


class SupportingInfoType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ID=None, SupInfoTypeID=None, DeltaAction=None, Text=None, DirectURL=None):
        self.original_tagname_ = None
        self.ID = _cast(int, ID)
        self.SupInfoTypeID = _cast(int, SupInfoTypeID)
        self.DeltaAction = _cast(None, DeltaAction)
        self.Text = Text
        self.DirectURL = DirectURL
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SupportingInfoType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SupportingInfoType.subclass:
            return SupportingInfoType.subclass(*args_, **kwargs_)
        else:
            return SupportingInfoType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Text(self): return self.Text
    def set_Text(self, Text): self.Text = Text
    def get_DirectURL(self): return self.DirectURL
    def set_DirectURL(self, DirectURL): self.DirectURL = DirectURL
    def get_ID(self): return self.ID
    def set_ID(self, ID): self.ID = ID
    def get_SupInfoTypeID(self): return self.SupInfoTypeID
    def set_SupInfoTypeID(self, SupInfoTypeID): self.SupInfoTypeID = SupInfoTypeID
    def get_DeltaAction(self): return self.DeltaAction
    def set_DeltaAction(self, DeltaAction): self.DeltaAction = DeltaAction
    def validate_DeltaActionSchemaType(self, value):
        # Validate type DeltaActionSchemaType, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['add', 'amend', 'delete', 'revise']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on DeltaActionSchemaType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.Text is not None or
            self.DirectURL is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='un:', name_='SupportingInfoType', namespacedef_='xmlns:un="http://www.un.org/sanctions/1.0"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SupportingInfoType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SupportingInfoType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='un:', name_='SupportingInfoType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='un:', name_='SupportingInfoType'):
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            outfile.write(' ID="%s"' % self.gds_format_integer(self.ID, input_name='ID'))
        if self.SupInfoTypeID is not None and 'SupInfoTypeID' not in already_processed:
            already_processed.add('SupInfoTypeID')
            outfile.write(' SupInfoTypeID="%s"' % self.gds_format_integer(self.SupInfoTypeID, input_name='SupInfoTypeID'))
        if self.DeltaAction is not None and 'DeltaAction' not in already_processed:
            already_processed.add('DeltaAction')
            outfile.write(' DeltaAction=%s' % (quote_attrib(self.DeltaAction), ))
    def exportChildren(self, outfile, level, namespace_='un:', name_='SupportingInfoType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Text is not None:
            self.Text.export(outfile, level, namespace_, name_='Text', pretty_print=pretty_print)
        if self.DirectURL is not None:
            self.DirectURL.export(outfile, level, namespace_, name_='DirectURL', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            try:
                self.ID = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.ID < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = find_attr_value_('SupInfoTypeID', node)
        if value is not None and 'SupInfoTypeID' not in already_processed:
            already_processed.add('SupInfoTypeID')
            try:
                self.SupInfoTypeID = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.SupInfoTypeID < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = find_attr_value_('DeltaAction', node)
        if value is not None and 'DeltaAction' not in already_processed:
            already_processed.add('DeltaAction')
            self.DeltaAction = value
            self.validate_DeltaActionSchemaType(self.DeltaAction)    # validate type DeltaActionSchemaType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Text':
            obj_ = TextType.factory()
            obj_.build(child_)
            self.Text = obj_
            obj_.original_tagname_ = 'Text'
        elif nodeName_ == 'DirectURL':
            obj_ = DirectURL.factory()
            obj_.build(child_)
            self.DirectURL = obj_
            obj_.original_tagname_ = 'DirectURL'
# end class SupportingInfoType


class TextType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, DeltaAction=None, valueOf_=None):
        self.original_tagname_ = None
        self.DeltaAction = _cast(None, DeltaAction)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TextType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TextType.subclass:
            return TextType.subclass(*args_, **kwargs_)
        else:
            return TextType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_DeltaAction(self): return self.DeltaAction
    def set_DeltaAction(self, DeltaAction): self.DeltaAction = DeltaAction
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_DeltaActionSchemaType(self, value):
        # Validate type DeltaActionSchemaType, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['add', 'amend', 'delete', 'revise']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on DeltaActionSchemaType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='un:', name_='TextType', namespacedef_='xmlns:un="http://www.un.org/sanctions/1.0"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TextType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TextType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='un:', name_='TextType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='un:', name_='TextType'):
        if self.DeltaAction is not None and 'DeltaAction' not in already_processed:
            already_processed.add('DeltaAction')
            outfile.write(' DeltaAction=%s' % (quote_attrib(self.DeltaAction), ))
    def exportChildren(self, outfile, level, namespace_='un:', name_='TextType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('DeltaAction', node)
        if value is not None and 'DeltaAction' not in already_processed:
            already_processed.add('DeltaAction')
            self.DeltaAction = value
            self.validate_DeltaActionSchemaType(self.DeltaAction)    # validate type DeltaActionSchemaType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class TextType


GDSClassesMapping = {
}


USAGE_TEXT = """
Usage: python <Parser>.py [ -s ] <in_xml_file>
"""


def usage():
    print(USAGE_TEXT)
    sys.exit(1)


def get_root_tag(node):
    tag = Tag_pattern_.match(node.tag).groups()[-1]
    rootClass = GDSClassesMapping.get(tag)
    if rootClass is None:
        rootClass = globals().get(tag)
    return tag, rootClass


def parse(inFileName, silence=False):
    parser = None
    doc = parsexml_(inFileName, parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'Sanctions'
        rootClass = Sanctions
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    if not silence:
        sys.stdout.write('<?xml version="1.0" ?>\n')
        rootObj.export(
            sys.stdout, 0, name_=rootTag,
            namespacedef_='xmlns:un="http://www.un.org/sanctions/1.0"',
            pretty_print=True)
    return rootObj


def parseEtree(inFileName, silence=False):
    parser = None
    doc = parsexml_(inFileName, parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'Sanctions'
        rootClass = Sanctions
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    mapping = {}
    rootElement = rootObj.to_etree(None, name_=rootTag, mapping_=mapping)
    reverse_mapping = rootObj.gds_reverse_node_mapping(mapping)
    if not silence:
        content = etree_.tostring(
            rootElement, pretty_print=True,
            xml_declaration=True, encoding="utf-8")
        sys.stdout.write(content)
        sys.stdout.write('\n')
    return rootObj, rootElement, mapping, reverse_mapping


def parseString(inString, silence=False):
    '''Parse a string, create the object tree, and export it.

    Arguments:
    - inString -- A string.  This XML fragment should not start
      with an XML declaration containing an encoding.
    - silence -- A boolean.  If False, export the object.
    Returns -- The root object in the tree.
    '''
    parser = None
    rootNode= parsexmlstring_(inString, parser)
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'Sanctions'
        rootClass = Sanctions
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    if not silence:
        sys.stdout.write('<?xml version="1.0" ?>\n')
        rootObj.export(
            sys.stdout, 0, name_=rootTag,
            namespacedef_='xmlns:un="http://www.un.org/sanctions/1.0"')
    return rootObj


def parseLiteral(inFileName, silence=False):
    parser = None
    doc = parsexml_(inFileName, parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'Sanctions'
        rootClass = Sanctions
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    if not silence:
        sys.stdout.write('#from sdn import *\n\n')
        sys.stdout.write('import sdn as model_\n\n')
        sys.stdout.write('rootObj = model_.rootClass(\n')
        rootObj.exportLiteral(sys.stdout, 0, name_=rootTag)
        sys.stdout.write(')\n')
    return rootObj


def main():
    args = sys.argv[1:]
    if len(args) == 1:
        parse(args[0])
    else:
        usage()


if __name__ == '__main__':
    #import pdb; pdb.set_trace()
    main()


__all__ = [
    "AliasType3",
    "AliasTypeType",
    "AliasTypeValuesType",
    "AreaCodeType1",
    "AreaCodeTypeType",
    "AreaCodeTypeValuesType",
    "AreaCodeValuesType",
    "CalendarTypeType",
    "CalendarTypeValuesType",
    "Comment",
    "CountryRelevanceType",
    "CountryRelevanceValuesType",
    "CountryType",
    "CountryValuesType",
    "DateBoundarySchemaType",
    "DatePeriod",
    "DatePointSchemaType",
    "DateSchemaType",
    "Day",
    "DaysType",
    "DecisionMakingBodyType",
    "DecisionMakingBodyValuesType",
    "DescriptionType",
    "DetailReferenceType",
    "DetailReferenceValuesType",
    "DetailTypeType",
    "DetailTypeValuesType",
    "DirectURL",
    "DistinctPartiesType",
    "DistinctPartySchemaType",
    "DocNameStatusType",
    "DocNameStatusValuesType",
    "DocumentDateType",
    "DocumentedNameCountryType",
    "DocumentedNamePartType",
    "DocumentedNameReferenceType",
    "DocumentedNameSchemaType",
    "DurationSchemaType",
    "EntryEventType4",
    "EntryEventTypeType",
    "EntryEventTypeValuesType",
    "EntryLinkTypeType",
    "EntryLinkTypeValuesType",
    "ExRefTypeType",
    "ExRefTypeValuesType",
    "ExRefValueType",
    "ExternalReferenceType",
    "FeatureSchemaType",
    "FeatureTypeGroupType",
    "FeatureTypeGroupValuesType",
    "FeatureTypeType",
    "FeatureTypeValuesType",
    "FeatureVersionReference",
    "FeatureVersionType",
    "IDRegDocDateTypeType",
    "IDRegDocDateTypeValuesType",
    "IDRegDocTypeType",
    "IDRegDocTypeValuesType",
    "IDRegDocumentMentionType",
    "IDRegDocumentReference",
    "IDRegDocumentSchemaType",
    "IDRegDocumentsType",
    "IDRegistrationNoType",
    "IdentityFeatureLinkTypeType",
    "IdentityFeatureLinkTypeValuesType",
    "IdentityReferenceType",
    "IdentitySchemaType",
    "IssuingAuthorityType",
    "LegalBasisType2",
    "LegalBasisTypeType",
    "LegalBasisTypeValuesType",
    "LegalBasisValuesType",
    "LimitationsToListingType",
    "ListType",
    "ListValuesType",
    "LocPartTypeType",
    "LocPartTypeValuesType",
    "LocPartValueStatusType",
    "LocPartValueStatusValuesType",
    "LocPartValueTypeType",
    "LocPartValueTypeValuesType",
    "LocationAreaCodeType",
    "LocationCountryType",
    "LocationPartType",
    "LocationPartValueType",
    "LocationSchemaType",
    "LocationsType",
    "MasterNamePartGroupType",
    "Month",
    "MonthsType",
    "NamePartGroupType",
    "NamePartGroupsType",
    "NamePartTypeType",
    "NamePartTypeValuesType",
    "NamePartValueType",
    "OrganisationType",
    "OrganisationValuesType",
    "PartySubTypeType",
    "PartySubTypeValuesType",
    "PartyTypeType",
    "PartyTypeValuesType",
    "ProfileRelationshipReference",
    "ProfileRelationshipSchemaType",
    "ProfileRelationshipsType",
    "ProfileType",
    "ReferenceValueSetsSchemaType",
    "RelationQualityType",
    "RelationQualityValuesType",
    "RelationTypeType",
    "RelationTypeValuesType",
    "ReliabilityType",
    "ReliabilityValuesType",
    "Sanctions",
    "SanctionsEntriesType",
    "SanctionsEntryLinkSchemaType",
    "SanctionsEntryLinksType",
    "SanctionsEntryReferenceType",
    "SanctionsEntrySchemaType",
    "SanctionsMeasureType",
    "SanctionsProgramType",
    "SanctionsProgramValuesType",
    "SanctionsTypeType",
    "SanctionsTypeValuesType",
    "ScriptStatusType",
    "ScriptStatusValuesType",
    "ScriptType",
    "ScriptValuesType",
    "SubLinkType",
    "SubsidiaryBodyType",
    "SubsidiaryBodyValuesType",
    "SupInfoTypeType",
    "SupInfoTypeValuesType",
    "SupportingInfoType",
    "TargetTypeType",
    "TargetTypeValuesType",
    "TextType",
    "ValidityType",
    "ValidityValuesType",
    "ValueType",
    "VersionDetailType",
    "VersionLocationType",
    "Year",
    "YearsType"
]
